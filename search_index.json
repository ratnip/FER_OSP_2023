[["index.html", "Programirajmo u R-u (Udžbenik za predmet “Osnove statističkog programiranja”) Predgovor", " Programirajmo u R-u Damir Pintar 2024-01-18 (Udžbenik za predmet “Osnove statističkog programiranja”) ** NAPOMENA: Za vrijeme odvijanja predmeta “Osnove statističkog programiranja” u tekućoj akademskoj godini provodi se revizija poglavlja udžbenika. Nakon što se materija odradi na predavanjima te završi ciklus predaje radnih bilježnica nova poglavlja će se dinamički dodavati u ovaj HTML dokument. Ukoliko vam je nužno potreban pristup cjelokupnim materijalima kontaktirajte autora udžbenika na damir.pintar@fer.hr ** Predgovor Ovaj udžbenik nastao je iz interaktivnih lekcija korištenih na predmetu “Osnove statističkog programiranja” na Fakultetu elektrotehnike i računarstva Sveučilišta u Zagrebu. No teme koje se ovdje obrađuju nisu korisne samo studentima navedenog fakulteta - poznavanje jezika R dobro će doći kako u akademskom, tako i u poslovnom svijetu. Iako je R poznat kao “programski jezik napravljen od statističara, za statističare” te se najčešće povezuje sa poljem podatkovne znanosti unutar kojeg se koristi za složene statističke i dubinske analize, on se može pokazati vrlo koristan i za poslove vezane uz upravljanje manjim ili većim podatkovnim skupovima koji nisu nužno strogo orijentirani naprednoj analitici. Naime, popularni grafički alati sa svojim interaktivnim tabličnim prikazom vrlo su intuitivni i odlični za jednostavnije poslove, no kako se pojavljuju potrebe za složenijim zadacima oni vrlo brzo gube na učinkovitosti i jednostavnosti; s druge strane, interaktivni programski pristup kojeg nudi R inicijalno je nešto zahtjevniji, no dugoročno vrlo isplativ jer se i vrlo složeni zadaci mogu rješavati na učinkovit, konzistentan i pregledan način. Upravo iz tog razloga u poslovnom svijetu pojavljuje se jasna tendencija odmaka od klasičnih grafičkih alata prema platformama sa boljom podrškom za provođenje složenijih izračuna i stvaranje atraktivnih vizualizacija. Ovo se očituje snažnim porastom popularnosti jezika R i drugih platformi sa sličnim pristupom analizi podataka. Navedena popularnost jezika R rezultira i povećanom potrebom za resursima za učenje, kojih na hrvatskom jeziku trenutno nema baš previše. Ovaj udžbenik svojim pristupom “učenja kroz primjere” pokušati će učenje R-a učiniti što lakšim i zanimljivijim. Naglasak će biti stavljen prvenstveno na svladavanje R-a kao programskog jezika. Upravo zbog toga početna poglavlja baviti će se poglavito “programerskim aspektima”, a potom će biti dan pregled dostupnih alata za zadatke za koje pretpostavlja da su korisni najširem skupu čitatelja - upravljanje podatkovnim skupovima, izvlačenje korisnih informacija i stvaranje vizualizacija. Budući da je R ipak domenski orijentirani jezik, priča o R-u zaokružiti će se kratkim uvidom u njegovu podršku za statističke analize te pregledom odabranih metoda strojnog učenja i njihove primjene. Iako će biti dano dovoljno informacija da se sve prikazane metode stave u kontekst, ideja ovog udžbenika nije naučiti čitatelja statistiku niti duboko ući u polje strojnog učenja - namjera autora jest zaintrigirati čitatelja da nastavi istraživanje ovog interesantnog područja, adekvatno naoružanog znanjem platforme koje će omogućiti da sva novousvojena znanja odmah praktično primjeni u svojim daljnjim istraživanjima. "],["uvod.html", "1 Uvod 1.1 Što je programski jezik R? 1.2 Instalacija programske podrške 1.3 Pregled razvojnog sučelja RStudio 1.4 Organizacija procesa podatkovne analize uz R i RStudio 1.5 Kako koristiti ovaj udžbenik?", " 1 Uvod 1.1 Što je programski jezik R? 1.1.1 Općenito o R-u Programski jezik R proizašao je iz programskog jezika S, razvijenog za potrebe Bell Telephone Laboratorija u vlasništvu AT &amp; T korporacije. Zamišljen je kao interni alat za statističku analizu. Osnovna filozofija jezika S (koju je naslijedio i programski jezik R) bila je domenska orijentiranost - tj. olakšavanje posla podatkovnim analitičarima bez potrebe za prilagođavanjem konvencijama tradicionalnih programskih jezika. Jezik S je kroz 80.-te i 90.-te dosegnuo značajnu popularnost u krugovima poslovnih analitičara i statističara, no dostupan samo kroz komercijalnu varijantu nazvanoj S-PLUS. Programski jezik R nastao je na sveučilištu u Aucklandu (NZ) po uzoru na S, a 2000. objavljuje se pod GNU licencom otvorenog koda. Standardna distribucija R programskog jezika sastoji se od: “jezgre” R-a, sa temeljnim funkcijama i tzv. base paketom koji omogućuje osnovnu funkcionalnost kolekcijom dodatnih paketa (“osnovni” - base i “preporučeni” - recommended) za upravljanje podacima, vizualizacije i statističke analize Ovdje ne treba zanemariti izvrsnu integraciju R-a sa bogatim repozitorijem paketa zvanom CRAN (Coprehensive R Archive Network) koja omogućuje brzu i jednostavnu instalaciju bilo kojeg paketa iz navedenog repozitorija nakon čega on postaje dio lokalne R instalacije. Budući da je za jezik R specifičan iznimno jaki utjecaj R zajednice na razvoj novih paketa, često se nakon pojavljivanja novih eksperimentalnih metoda i pristupa podatkovne analize vrlo brzo na CRAN-u mogu pronaći paketi koji iste implementiraju, a također treba spomenuti i snažni i kontinuirani entuzijazam R zajednice za razvoj poboljšanja postojećih elemenata R-a koji ublažavaju ili uklanjaju veliki broj uočenih manjkavosti jezika. R se zbog toga često zna uspoređivati sa “uradi sam” projektom gdje korisnik, nakon upoznavanja sa isporučenim “tvorničkim” komponentama (u ovom slučaju temeljnim funkcijama i paketima), počinje prilagođavati svoju razvojnu okolinu odabirom paketa koji točno odgovaraju njegovim potrebama i preferencama. Kreativnost i fleksibilnost u korištenju R-a se smatra njegovom velikom prednošću, iako rezultira određenom neformalnošću i liberalnim pristupom programiranju koji nije omiljen korisnicima naviknutim na stroge i formalne programske okvire sa jasnim skupom smjernica i pravila koja se moraju slijediti. Usprkos iznimno velikoj prihvaćenosti jezika R za podatkovne analize te mnoštvu opcija koje nudi korisniku, potrebno je odmah u početku biti svjestan i njegovih određenih ograničenja: R jako intenzivno koristi radnu memoriju što je dugo vremena smatrano ozbiljnim ograničenjem; porastom kapaciteta modernih hardverskih sustava ovo ograničenje je danas puno prihvatljivije, a također su se pojavili brojni paketi koji racionaliziraju korištenje memorije. Ipak ostaje činjenica da R brzo “pojede” RAM našeg računala, iako je to često i rezultat nepažnje ili neznanja programera koji nije dovoljno dobro usvojio “R-ovski” način programiranja. R je prilično nekonvencionalan tako da je krivulja učenja inicijalno nešto strmija, pogotovo za programere naviknute na standardne konvencije drugih programskih jezika. S druge strane, ako se gleda dugoročno, programiranje u R-u je prilično jednostavno budući da je većina kompleksnih zadataka apstrahirana u visokorazinske funkcije koje transparentno obavljaju operativne poslove niske razine. Često se kaže da je R više orijentiran cilju kojeg želimo postići a manje detaljima oko puta kojim do njega stižemo. R nije “brzi” jezik; iako se radi o jeziku koji očekivano radi nad velikim skupovima podataka, R nije optimiziran za brzinu izvođenja, pa čak ni za višedretvenost; iako je veliki trud uložen da se gotovo sve ključne rutine implementiraju u C-u i da se spriječe znatna usporavanja, a postoji i niz paketa koji omogućuju višedretveno izvođenje R programa, i dalje stoji činjenica da R nije dizajniran s ciljem da se izvršava što je brže moguće; ukoliko je brzina prioritet, često je potrebno tražiti alternativna rješenja - zbog čega se često zna reći da je R primarno istraživački jezik, ne produkcijski. R je prvenstveno namijenjen za interaktivni rad, tj. izvođenje niza strojnih instrukcija koje se dinamički upisuju i izvode uz pomoć programske konzole. Ovo je prilagođeno standardnom procesu analize podataka gdje analitičar može učitavati podatke, čistiti ih, transformirati, razvijati modele, testirati i sl. uz konstantnu povratnu informaciju od računala, mogućnost pregleda međurezultata, izmjene procesa prema trenutnim saznanjima i sl. Ovo ne znači da se u programskom jeziku ne može programirati na klasičan “proceduralni” način, razvojem algoritama enkapsuliranih u funkcije koje onda nakon pozivanja automatski obavljaju svoje zadatke, ali činjenica jest da se učinkovitost R-a upravo odražava u interaktivnom radu. Ovaj princip se prenosi i na učenje R-a; programski jezik R puno se lakše uči interaktivnim pristupom uz izvršavanje konkretnih zadataka, eksperimentiranjem s podatkovnim skupovima, dostupnim metodama i sl. nego “klasičnim” pristupom izrade programskih skripti koje implementiraju neke niskorazinske poslove. 1.1.2 Alternative jeziku R Programski jezik R je popularno, ali ne i jedino rješenje za interaktivnu analizu podataka i statističko programiranje. U nastavku ćemo dati kratki pregled nekih popularnijih tehnologija i rješenja koje se danas koriste u ovu svrhu, uz kratku usporedbu i osvrt na prednosti i nedostatke u usporedbi sa onim što nudi jezik R. SAS i SPSS – SAS (Statistical Analysis System, razvijen od strane SAS Institute) i SPSS (Software Package for Statistical Analysis, razvijen od strane IBM-a) su dva različita softverska paketa koje stavljamo pod istu stavku prvenstveno zato što se radi o komercijalnim alatima, tj. alatima koji za svoju punu funkcionalnost zahtijevaju plaćanje licence. Isto tako, SAS i SPSS se relativno lako uče a svoju funkcionalnost u velikoj mjeri zasnivaju na pomno dizajniranim korisničkim sučeljima. Ovi alati naglasak stavljaju na učinkovitost i odlična su opcija za velike tvrtke koje traže konzistentno, robusno rješenje za svoju analitiku i kojima ne smeta komercijalna priroda takvih rješenja. Weka i Orange – Weka (Waikato Environment for Knowledge Analysis, razvijen od strane sveučilišta Waikato na Novom Zelandu) i Orange (alat za dubinsku analizu podataka razvijen na sveučilištu u Ljubljani) su besplatan softver za eksploratornu analizu podataka i dubinsku analizu koji svoju funkcionalnost zasnivaju na relativno jednostavnim grafičkim sučeljima i vizualnom pristupu programiranju. Ova rješenja vrlo su dobra za korisnike koji nisu previše zahtjevni glede fleksibilnosti i kompleksnosti svojih analiza jer na vrlo pristupačan i jasan način omogućuju provedbu definiranih koraka procesa analize. To ne znači da se u ovim alatima ne mogu raditi i kompleksnije analize, samo da su oni ipak prilagođeniji analizama kroz predefinirane funkcionalnosti pruženog grafičkog sučelja. Python (Numpy / Pandas / Scikit) – u zadnjih nekoliko godina upravo je Python najozbiljniji konkurent jeziku R, prvenstveno zbog činjenice da je Python sam po sebi vrlo popularan programski jezik koji za potrebe analize podataka koristi pakete s vrlo sličnim pristupom procesu analize onom kojeg koristi i jezik R. Rasprava o tome koji jezik odabrati je vrlo česta u polju znanosti o podacima, obično bez jasnog konačnog zaključka. Lako s uvjeriti da su razlike zapravo u nijansama - dok je R snažno domenski orijentiran i veći naglasak stavlja na lakoću i jednostavnost korištenja uz široku paletu dostupnih paketa sa preklapajućim funkcionalnostima kako bi korisnik mogao odabrati onaj koji mu najviše odgovara, Python naglašava rigidnu formalnu strukturu i princip “za jedan posao jedan način obavljanja”. Stoga bi se moglo reći da je R nešto pogodniji za “istraživanje podataka” dok je prednost Pythona lakši razvoj i integracija analitičkih modula u nekom produkcijskom okruženju, pogotovo ako je navedeno okruženje već izvedeno u Pythonu. No snažnim razvojem oba jezika i međusobnim praćenjem funkcionalnosti i ova navedena razlika postaje sve manje relevantna - danas više nije problem integrirati R skripte u postojeće sustave neovisno o platformi na kojoj su izvedeni, a u Python zajednica razvija svoje inačice popularnih paketa iz R-a koje vjerno preslikavaju njihovu funkcionalnost. U konačnici se može reći da inicijalni odabir između ove dvije alternative i nije toliko bitan - pristup kojeg koriste je toliko sličan a praćenje funkcionalnosti toliko izraženo da se učenjem jednog jezika svladava većina bitnih koncepata iz drugog tako da se podatkovni znanstvenici često na kraju odlučuju na svladavanje oba jezika, kako bi se lako prilagodili velikom broju okruženja u kojima moraju provoditi svoje analize. 1.2 Instalacija programske podrške Instalacija programske podrške za jezik R je prilično jednostavna, pogotovo ako se kao platforma koristi preporučeno razvojno sučelje RStudio. Ovo nije jedina opcija - jedna od popularnih alternativa jest i višejezična platforma Jupyter Notebook koja nudi vlastitu podršku za R. Čitateljima se dugoročno preporučuje istraživanje svih dostupnih opcija i konačni odabir onog sučelja koje osobno procijene najboljim za svoje potrebe, no ovaj udžbenik će se usredotočiti na RStudio ponajviše zbog jasnog, preglednog sučelja, lake instalacije i vrlo bogate podrške za različite funkcionalnosti - od instalacije novih paketa, lakog dohvaćanja dokumentacije, prikaza vizualizacija do stvaranja i objave izvještaja. Radne bilježnice o kojima će više riječi biti u nastavku uglavnom pretpostavljaju da ste odabrali sučelje RStudio. Za uspješno postavljanje razvojne platforme potrebno je instalirati dvije stvari distribuciju jezika R razvojno sučelje RStudio Preporučuje se koristiti najnovije dostupne inačice. U trenutku pisanja ovog dokumenta to su R 4.2.2 i RStudio 2022.07.2. Ukoliko se ove inačice razlikuju od one koje se nalaze na vašem računalu, vjerojatno neće biti problema ukoliko su brojevi inačica viši od navedenih; u suprotnom preporučuje se njihova nadogradnja. U nastavku će se opisati postupak za instalaciju navedenog softvera na operacijski sustav Microsoft Windows. Ukoliko radite na nekom od drugih operacijskih sustava, kao što je neka od Linux distribucija ili Mac OS procedura je nešto drugačija, no i dalje ne previše složena - dovoljno je pratiti upute na web stranicama spomenutim u nastavku koje su orijentirane platformi koju koristite. Kako bi pronašli spomenuti softver u tražilicu upišite sljedeće pojmove: download R download RStudio U oba slučaja dobiti ćete stranice sa poveznicama na izvršne datoteke koje morate pokrenuti kako bi se softver instalirao na vaše računalo. U slučaju jezika R to može biti datoteka R-4.2.2-win.exe (točni brojevi se mogu razlikovati). Kod sučelja RStudio možete vidjeti više opcija - odaberite besplatnu “desktop” inačicu. Komercijalne inačice imaju neke dodatne funkcionalnosti koje su većinom orijentirane uporabi u profesionalnim, višekorisničkim okruženjima te nisu bitne za uobičajeni rad. Izvršne datoteke možete pokrenuti i pustiti čarobnjaka da instalira sve potrebne komponente na vaše računalo. Preporučuje se prihvatiti sve nazivne opcije osim mape instalacije - umjesto podmape “Program Files” bolje je instalirati R direktno u osnovnu mapu (npr. “C:\\R\\R-4.2.2”). Na ovaj način biti će lakše pronaći trenutno instaliranu inačicu i eventualno kasnije ažurirati. Iz istih razloga preporučuje se RStudio instalirati u mapu “C:\\R\\RStudio”. U slučaju da niste mogućnosti ili ne želite odabrati ove mape, možete definirati neke druge ili zadržati nazivne opcije - ovaj izbor ne bi u konačnici trebao bitno utjecati na daljnji rad. Nakon instalacije sučelja RStudio dovoljno je isto jednostavno pokrenuti uz pomoć stvorene kratice na radnoj mapi (ili alternativno, uz pomoć izvršne datoteke RStudio.exe u odabranoj mapi za instalaciju). Nakon pokretanja aplikacija bi trebala izgledati slično sljedećoj slici: Slika 1.1: Izgled sučelja RStudio Ukoliko je došlo do nekih problema, provjerite da li ste ispravno proveli sve navedene korake instalacije. U nastavku ćemo se pozabaviti detaljima prikazanog sučelja. 1.3 Pregled razvojnog sučelja RStudio Pogledajmo sučelje RStudio. Vidimo da je podijeljeno na tri prozora - lijevi dio je “radni” i u njega upisujemo programski kod. S desne strane se nalaze pomoćni prozori koji prikazuju različite stvari, ovisno o odabranoj kartici; u gornjem desnom dijelu između ostalog možemo vidjeti što se trenutno nalazi u našoj radnoj okolini (koja je na početku prazna) te povijest naredbi koje smo izvršavali. Donji dio služi za prikaz dokumentacije, datoteka u radnoj mapi, instaliranih paketa, vizualizacija i sl. 1.3.1 Interaktivna konzola Vratimo se na lijevi dio sučelja. Ovdje se zapravo radi o tzv. “interaktivnoj konzoli”. Naime, po svojoj prirodi R je tzv. “interpreterski jezik” u smislu da se naredbe odmah interpretiraju i izvršavaju. Iako je moguće izrađivati i veće skripte koje se onda izvršavaju “u komadu”, rad sa jezikom R vrlo često se svodi na princip naredba - odgovor. Upravo zbog toga govorimo o “interaktivnoj programskoj analizi podataka” - analitičar “programira” upisivanjem naredbi te u svakom trenutku može proučiti dobivene međurezultate i odlučiti se na daljnje korake. Prikažimo kako radi interaktivna konzola. Uz pomoć tipkovnice možemo utipkati jednostavan matematički izraz - npr. 3 + 2 i stisnuti tipku ENTER. Vidimo da će nam R odmah pružiti rezultat - možemo ga koristiti i kao kalkulator! Za matematičke izraze koje nije jednostavno “utipkati” moramo koristiti funkcije. Tako npr. drugi korijen možemo izračunati uz pomoć funkcije sqrt(). Pokušajmo u konzolu utipkati sqrt(10) i stisnuti ENTER. R nam opet odmah prikazuje rezultat. U ovom trenutku zaslon bi nam trebao izgledati otprilike kao na sljedećoj slici. Slika 1.2: R kao kalkulator Jedan od problema ovakvog načina korištenja R-a jest taj što nam se miješaju naredbe i rezultati, a povijest niza naredbi postaje sve teže vidljiva kako se korištenjem konzole spuštamo sve “niže i niže”. Isto tako, ako iz nekog razloga naredba koju izvršavamo rezultira greškom koju pokušavamo ispraviti, konzola vrlo brzo postaje “prljava” budući da se miješaju korektni pozivi sa izvještajima o greškama čime bilo kakva složenija procedura koju želimo provesti postaje “rastrgana” i nepregledna. Zbog toga analitičari vrlo često koriste tzv. “R skripte” koje omogućuju da vizualno izdvojimo naredbe koje želimo izvršiti od same konzole, ali i dalje uz mogućnost da ih lako upišemo u konzolu, slijedno izvršimo i pogledamo rezultat. 1.3.2 Pisanje R skripti Na alatnoj traci odaberimo File -&gt; New File -&gt; R Script (ili stisnemo kombinaciju tipaka CTRL + SHIFT + N). Vidimo da se “radni dio” na lijevoj strani razdvojio na dva dijela. Gornji dio predstavlja prostor za našu “skriptu” - zapravo niz naredbi koje želimo izvršiti - dok interaktivna konzola sada zauzima donji dio radne plohe. Ukoliko želimo, možemo pomicanjem granice promijeniti veličinu ovih (a i ostalih prozora), no za sada je bitno da imamo pregled i skripte i konzole. Upišimo dvije naredbe u prozor za pisanje skripte - prva neka bude print(\"Pozdrav!\") a ispod nje opet jednostavan matematički izraz 3 + 4. Vratimo kursor na prvi redak i stisnimo kombinaciju tipki CTRL + ENTER. Ukoliko smo ispravno pratili navedene korake, naredba na mjestu koje se nalazio kursor automatski će se preslikati u interaktivnu konzolu i izvršiti. Kursor će sada biti na mjestu sljedeće naredbe koju također možemo izvršiti sa CTRL + ENTER. Zaslon bi sada trebao izgledati slično sljedećoj slici. Slika 1.3: R skripta Ovo je zapravo uobičajeni način rada u jeziku R - u prostor za skripte upisujemo naredbe koje potom izvršavamo njihovim automatskim preslikavanjem u konzolu. Ako nešto ne štima s naredbom, lako ju preinačimo i ponovo izvršimo. Ukoliko želimo izvesti blok naredbi, odaberemo ih povlačenjem miša i izvršimo kombinacijom tipaka CTRL + ENTER. Skripte možemo proširiti komentarima (koji počinju znakom # kojeg R interpretira kao “ovaj redak ignoriraj”), a na kraju rada spremiti pod odabranim imenom na čvrsti disk. No možemo otići i korak dalje. Iako su R skripte sasvim adekvatne za ugodan rad u jeziku R, postoji dodatna tehnologija koja nam omogućuje još veću fleksibilnost u radu sa programskim jezikom R - R Markdown. 1.3.3 Instalacija dodatnih paketa standardna R distribucija dolazi sa dvije kolekcije paketa (nazvanih r-base i r-recommended) koje sadrže svojevrsnu “jezgru” jezika R - skup elemenata dostatnih za provođenje standardnih tipova podatkovnih analiza uz pomoć programskog jezika R. Uz to, CRAN (Comprehensive R Archive Network) predstavlja bogati repozitorij dodatnih paketa za najrazličitije primjene, od “popravljanja” osnovnih elemenata jezika R do strogo specijaliziranih paketa za posebne tipove analiza. Kao što je uobičajena praksa u drugim programskim jezicima, R koristi sustav “paketa” ili “biblioteka” (engl. package ili library) kako bi logički organizirao već “isprogramirane” kolekcije podataka, skupova i prevedenog programskog koda. # učitavanje paketa &#39;dplyr&#39; library(dplyr) Ukoliko ovaj paket već postoji na lokalnom računalu - u mapi predodređenoj za dodatne pakete koju možete lako pronaći u instalacijskoj mapi R distribucije - on će u ovom trenutku biti učitan u radnu okolinu. Uspješno učitavanje paketa može biti popraćeno određenim statusnim porukama koje u ovom trenutku možemo ignorirati, budući da je to tema jednog od nastupajućih poglavlja. Ukoliko na lokalnom računalu nemamo navedeni paket dobivamo poruku o grešci da taj paket ne postoji. U tom slučaju potrebno je prvo dohvatiti paket iz CRAN repozitorija uz pomoć funkcije install.packages kojoj dajemo naziv jednog ili više paketa (s navodnicima!) kao parametre. Navedena funkcija pretpostavlja da R okolina ima definiran CRAN mirror tj. konkretnu adresu CRAN repozitorija odakle će se paket dohvatiti. Veliki broj država ima svoju “kopiju” CRAN repozitorija, no nažalost Republika Hrvatska iz nejasnih razloga više nema svoj CRAN repozitorij te u trenutku pisanja ove bilježnice nema pokazatelja da će se isti uspostaviti. Ako radimo u sučelju RStudio, CRAN repozitorij smo vrlo vjerojatno postavili kod prvog pokretanja, (tj. odabrali smo opciju Global koja naše zahtjeve za instaliranjem paketa automatski prosljeđuje najbližem CRAN repozitoriju) no ako to nismo obavili ili radimo u nekom drugom razvojnom sučelju onda uz pomoć dokumentacije moramo potražiti način postavljanja CRAN repozitorija ako želimo učitavati dodatne pakete. # spuštanje paketa &#39;dplyr&#39; na lokalno računalo install.packages(&quot;dplyr&quot;) Uočite izvjesnu nedosljednost korištenja navodnih znakova - kod spuštanja paketa se moraju koristiti (budući da je parametar ove funkcije znakovni niz), ali kod učitavanja u radnu memoriju nisu nužni. Također uočite da u programskom jeziku R nazivi funkcija mogu imati točku, što često nije slučaj u drugim programskim jezicima. Ukoliko paket kojeg spuštamo ima dodatne pakete čije funkcije koristi, oni će se također spustiti na lokalno računalo. NAPOMENA: naredbe spuštanja paketa na lokalno računalo uvijek radimo na interaktivno konzoli, nikada unutar skripti ili radnih bilježnica. Razlog tome jest što spuštanje (nove) inačice u pravilu radimo jednom, dok skriptu/radnu bilježnicu obrađujemo veći broj puta, tako da bi konstantno spuštanje paketa koji su već pohranjeni na lokalno računalo nepotrebno usporavalo proces. Prije nastavka, uputno je na lokalno računalo spustiti kolekciju paketa koji će se koristiti u narednim poglavljima, a koji između ostalog uključuju i pakete nužne za ispravno korištenje radnih bilježnica. Zadatak 1.1 - Instalacija nužnih paketa # sljedeće naredbe izvršiti u konzoli install.packages(&quot;rmarkdown&quot;) install.packages(&quot;tidyverse&quot;) # ovo može potrajati! Novije inačice sučelja RStudija će automatski uočiti da skripta koristi paketa koji nisu u lokalnoj distribuciji te će ponuditi opciju njihovog spuštanja - odabir opcije “install” u iskočnom izborniku imati će ekvivalentni učinak instalacije paketa preko konzole. 1.3.4 R Markdown Pisanje R skripti vrlo je slično klasičnom poimanju “programiranja” - pišemo programske naredbe koje se u pravilu izvršavaju slijedno te kojima opcionalno dodajemo komentare u svrhu dokumentacije. No budući da je rad u R-u vrlo često interaktivne prirode te da se kao završni korak neke analize podataka obično očekuje oblikovanje izvještaja koji će na adekvatan način prikazati dobivene rezultate, sučelje RStudio podržava tehnologiju koja omogućuje učinkovitu kombinacije programiranja i strukturiranog dokumentiranja na principu “interaktivne bilježnice”“; analitičar može pisati”čisti” tekst, opcionalno sa formulama, slikama te izmjenama veličine i prirode tekstualnog fonta, da bi potom u takav tekst “ugradio” izvršivi programski kod zajedno sa njegovim rezultatima. Tehnologija koja ovo omogućuje je tzv. R Markdown, koji je relativno nedavno proširen novim konceptom nazvanim R Notebook. Rad ove tehnologije najlakše je prikazati preko primjera - u alatnoj traci odaberimo File -&gt; New File -&gt; R Markdown... te u idućem prozoru odaberimo proizvoljni naslov (npr. Proba), opcionalno ime autora te jednu od opcija za konačni oblik izvještaja (preporučeno HTML zbog najmanje ovisnosti o dodatnim paketima). Za razliku od R skripte, R će kod novog R Markdown dokumenta stvoriti “popunjeni” dokument. Ovo je izvedeno na ovaj način iz jednostavnog razloga da korisnik dobije predložak koji istovremeno služi i kao podsjetnik te kojeg onda lako izmjeni prema svojem nahođenju. Mi ćemo za naše potrebe obrisati veći dio ovog predloška - sve poslije inicijalnog zaglavlja, tj. ispod druge pojave znakova ---. Potom možemo ispod napisati bilo kakav tekst. Znakovima #, ##, ### itd. možemo postaviti naslov određene kategorije (to sada nisu komentari, jer ovo zapravo nije R kod!), dok znakovima * i ** ispred i iza odabranih riječi odabiremo nakošeni ili masni otisak u konačnom izvještaju. Ovo je tzv. čisti “markdown”, tj. običan tekst koji se uz pomoć dodatnih alata može pretvoriti u oblikovani tekst, ukoliko želimo. Kada želimo u ovaj naš “izvještaj” ugraditi programski kod, moramo stvoriti tzv. “isječak” (engl. chunk). To možemo učiniti odabirom Insert -&gt; R na alatnoj traci ili kombinacijom tipaka CTRL + ALT + I. Uočite da isječak počinje i završava posebno odabranim nizom znakova - tri “apostrofa nalijevo” (engl. backticks). Isto tako, početak isječka u vitičastim zagradama opisuje parametre isječka, od čega je najvažniji programski jezik kojeg ćemo koristiti. U ovom udžbeniku ćemo gotovo isključivo koristiti jezik R, iako je moguće koristiti i druge jezike ukoliko su oni instalirani na platformi na kojoj je pokrenut RStudio. Isječak koda ponaša se isto kao i standardna R skripta - možemo upisivati naredbe i izvršavati ih. Razlika je samo u tome što - ukoliko želimo - rezultate možemo vidjeti i odmah u samom R Markdown dokumentu. Ako nam ova opcija smeta možemo ju isključiti (klik na zupčanik u alatnoj traci i odabir Chunk output in console) no u pravilu nam odgovara da se rezultat ugradi u dokument kako bi naknadno mogli ponovo pregledavati rezultate prethodnih isječaka. Ako smo pratili upute, zaslon bi mogao izgledati slično sljedećoj slici: Slika 1.4: R Markdown dokument Ukoliko želimo, možemo pokušati stvoriti “izvještaj” od trenutnog dokumenta. Prvo ga moramo spremiti pod određenim imenom (npr. Proba.rmd), a potom možemo kliknuti na gumb Knit koji će dokument iz čistog teksta pretvoriti u HTML datoteku. R Markdown dokumenti su puno moćniji nego što se možda daje naslutiti do sada prikazanim elementima. Isječcima možemo dodavati niz parametara kako bismo utjecali na njihovo ponašanje. Izlazni oblik može biti PDF, DOCX ali i drugi oblici kao što slajdovi raznih tehnologija, knjige namijenjene mobilnim uređajima, interaktivna Web aplikacija i sl. Udžbenik kojeg čitate zapravo nije ništa drugo do niz RMD datoteka pretvoren u adekvatni oblik kojeg trenutno koristite. Kao što ćemo objasniti u sljedećem poglavlju, RMD datoteke su također i glavni način na kojeg ćete moći na interaktivan način pratiti ovaj udžbenik i isprobavati primjere i zadatke koje slijede. Univerzalnost i fleksibilnost tehnologije R Markdown je iznimno velika, čemu u prilog govori i njezina velika popularnost u R zajednici. 1.4 Organizacija procesa podatkovne analize uz R i RStudio 1.4.1 Poželjne karakteristike procesa analize podataka Analiza podataka kroz programske skripte specifičan je proces koji se razlikuje od uobičajenog pristupa programiranju. Ovo je pogotovo slučaj kada se radi o inicijalnom, istraživačkom segmentu analize gdje smo usredotočeni na otkrivanje karakteristika podatkovnog skupa, definiranje određenih pretpostavki, postavljanje hipoteza i donošenje zaključaka. Ovakva analiza podatake je često, složen, iterativan i naglašeno interaktivan proces, koji zahtjeva strogo kontrolorani i organizirani pristup njegovoj provedbi. Slika 1.5: R Markdown dokument Postoje određene poželjne karakteristike analitičkog procesa koje bismo trebali osigurati kako kroz usredotočenost na discipliniranu provedbu, ali i odabir adekvatne razvojne okoline koja će te karakteristike učinkovito potpomagati. Portal RevolutionAnalytics (https://blog.revolutionanalytics.com/) definira sljedeće poželjne karakteristike organizacije analitičkoga procesa: transparentnost – logička i jasna organizacija projekta koju će lako razumjeti i promatrač sa strane održivost – laka modifikacija i prilagodba projekta, dobra dokumentacija, korištenje konzistentnog imenovanja skripti i mapa modularnost – dobro rastavljanje pojedinih diskretnih zadataka u zasebne segmente kako bi se lakše provodile izmjene i povećala mogućnost ponovne iskoristivosti prenosivost – dobra organizacija trebala bi omogućiti lako prenošenje procesa na drugu platformu, operacijski sustav ili bilo kakvo drugo novo okruženje (višekorisničko, distribuirano itd.) reproducibilnost – svi rezultati (i međurezultati!) projekta trebali bi se moći lako reproducirati ponavljanjem istovjetnoga procesa nad istim podacima učinkovitost – ovdje se misli na učinkovitost s gledišta ljudskoga korisnika, ne računala; proces bi trebao koristiti sve mogućnosti ubrzavanja, automatiziranja ili bilo kakvoga drugog olakšavanja provedbe procesa koliko god je to moguće dok god se ne kompromitira kvaliteta analize ili neka od drugih bitnih karakteristika procesa. Prvi korak u organiziranom procesu analize podataka jest priprema adekvatne podatkovne strukture. 1.4.2 Organizacija mapa za potrebe analize podataka Ne postoji jedinstvena organizacija mapa koja će biti univerzalno podobna za sve procese analize i za sve analitičare. U praksi svaki analitičar (ili tim analitičara) treba odabrati onaj način koji mu najviše odgovara kako bi se zadržale sve pozitivne strane organizacije, a koji neće sam po sebi predstavljati dodatno opterećenje u pogledu administracije i održavanja. Za početak nije nužno koristiti dodatni softver ili pakete kako bi se provela organizacija procesa analize – dovoljno je osigurati konzistentnu strukturu mapa u koju će se postavljati određene datoteke, po mogućnosti po odabranim smjernicama. Jedan od jednostavnijih primjera organizacije mapa može biti sljedeći: U podatkovnoj strukturi platforme na kojoj radimo stvorimo zasebnu mapu u koju ćemo smjestiti sve datoteke potrebne za analizu; poželjno je mapu postaviti na logično mjesto te odabrati intuitivan naziv, npr. R/projekti/OSP U osnovnoj mapi projekta treba stvoriti mape sljedećih naziva: Rscripts – u ovu mapu stavljamo vlastite R-skripte koje će se koristiti u projektu; najčešće se radi o različitim funkcijama (npr. za čišćenje i obradu podataka); datoteke u ovoj mapi nazivamo ime_datoteke.R, a u izvještajima ih učitavamo uz pomoć funkcije source data – u ovoj mapi nalaze se podaci – ulazni podaci te podaci koji su prošli određene korake čišćenja i prilagodbe, tj. međurezultati. Ove međurezultate možemo spremati u obliku CSV datoteke (ekstenzija CSV) ili u R-ovu native obliku (ekstenzija RData). Ako imamo više međurezultata nastalih sekvencijalnim procesom obrade, poželjno ih je nazvati intuitivnim imenima koja odražavaju tijek obrade (npr. podaci_01.csv, podaci_02.csv i sl.). figures – u ovu mapu stavljamo sve interesantne vizualizacije koje smo stvorili tijekom analize (najčešće u obliku PDF ili PNG datoteke). Vizualizacija mora imati dovoljno podataka kako bi se kasnije mogla interpretirati (i rekonstruirati), a za vizualizacije koje ćemo kasnije ugrađivati u izvještaj preporuka je sačuvati i programski kod koji ih je stvorio. Ako želimo, u ovoj mapi možemo napraviti i podmape expl i report kako bismo razdvojili vizualizacije kojima samo istražujemo podatke od onih koje ćemo uključiti u izvještaj. reports – u ovoj mapi radimo R Markdown izvještaje. Ako se radi o složenijem procesu analize podataka, preporučeno je slijedno numerirati izvještaje (01-ucitavanje.Rmd, 02-transformacija.Rmd itd.); analiza bi trebala imati dovoljno informacija da lako osigurava ponovo izvođenje ispočetka uz identične rezultate. Pored gore navedenih mapa i pripadnih datoteka, u osnovnu mapu projekta preporučuje se stvoriti i dvije tekstualne datoteke: log.txt – nakon svakog rada na podacima na vrh ove datoteke ukratko upišemo što se napravilo i koji su okvirni rezultati TODO.txt – kratak opis planiranih zadataka za iduću sesiju. Sada, kada smo priredili ove mape i datoteke, moramo se potruditi konzistentno ih koristiti tijekom analize (prikupljene podatke stavimo u data mapu, prvi RMD dokument stvorimo u mapi reports i sl.). Ako smo dosljedni i disciplinirani, znatno ćemo podići razinu održivosti i konzistentnosti projekta te olakšati dugoročan rad na njemu. Kod manjih projekata moguće je pojednostaviti ovaj pristup korištenjem samo jedne krovne mape (uz “projektni” pristup objašnjen u nastavku), no već kod projekata srednje složenosti gdje uočavamo potrebu za korištenjem više podatkovnih skupova (što uključuje i pohranu međurezultata) te generiranjem većeg broja izvještajnih datoteka i/ili vizualizacija preporučljivo je prijeći na organizirani pristup sa adekvatnim korištenjem podmapa. 1.4.3 Pojam projekta Sučelje RStudija može nam dodatno olakšati organizaciju procesa analize, pogotovo u slučajevima kada radimo više paralelnih analiza, ili hoćemo raditi neke druge poslove u R-u koji nisu vezani s analizom u tijeku. Za te potrebe RStudio koristi pojam „R projekta“. R projekt možemo zamisliti kao spremljenu inačicu sučelja za potrebe jednoga scenarija korištenja, nešto slično spremanju pozicije u računalnim igrama. Kada radimo u okviru projekta te u jednom trenutku završimo s radom, R će „spremiti poziciju“ – izgled sučelja, učitane objekte, otvorene dokumente i sl. – čime nam omogućuje da naknadim otvaranjem ovoga projekta rekonstruiramo sučelje i objekte točno onakvima kakvima smo ih ostavili. Isto tako, ako paralelno radimo više različitih analiza, na ovaj način možemo imati zasebna sučelja za svaku analizu, bez nezgodnog miješanja objekata, datoteka i izvještaja. Novi projekt možemo napraviti uz pomoć opcije File -&gt; New Project.... Ako smo unaprijed pripremili mapu za projekt, preporuka je da prije stvaranja novoga projekta postavimo tu mapu kao radnu (uz pomoć naredbe setwd ili odabirom mape u donjem desnom dijelu sučelja te potom opcije More -&gt; Set As Working Directory). Kad odaberemo New Project... vidljive su sljedeće opcije: Slika 1.6: Novi projekt Ako smo dobro odabrali mapu, najbolja je opcija Existing Directory. Potom – ako želimo zadržati postojeću sesiju – označimo opciju Open in a New Session te potom Create Project. Možemo vidjeti da smo dobili potpuno novu, čistu inačicu RStudio sučelja. Ako pogledamo mapu u kojoj smo stvorili projekt, vidjet ćemo novu datoteku s ekstenzijom .RProj. Sada možemo raditi unutar ovog projekta, a nakon završetka posla samo sve spremimo i zatvorimo sučelje. Dvoklikom na .RProj datoteku sučelje RStudija će se otvoriti i rekonstruirati okolinu točno onako kako je izgledala kada smo ju zatvorili. Usprkos tome što ova funkcionalnost sučelja RStudija može značajno pomoći kod rada na analizi u više sesija, preporučuje se da se ne oslanjamo previše na rekonstrukciju okoline, pogotovo kada se radi o objektima, učitanim podacima i sl. Puno je bolja praksa – koja se i često eksplicitno preporučuje u literaturi – u novoj sesiji krenuti od nule ili od pomno odabrane polazišne točke (npr. konkretnoga međurezultata). Ovo će nas natjerati da pažljivije organiziramo analizu, da budemo svjesni u kojem koraku se nalazimo te da detaljno znamo sve učitane objekte, njihovu ulogu i način na koji su nastali. Nadalje, na ovaj način značajno podižemo održivost, prenosivost i reproducibilnost projekta, što su bitne karakteristike organizacije procesa. Jedan od načina kako ovo provesti jest natjerati se da na kraju svake sesije uvijek izvedemo naredbu rm(list = ls()) koja briše sve varijable globalne okoline. Iako ovo djeluje destruktivno i rizično jer potencijalno trajno brišemo korisne rezultate, saznanje da će svi objekti u jednom trenutku nestati natjerat će nas da pažljivo organiziramo analizu i naglasak stavimo upravo na sljedivost procesa i reproducibilnost, a manje na vjeru da su objekti koje trebamo već učitani i spremni za daljnje korake. Konačno, ako uistinu želimo podići organizaciju procesa analize na višu razinu te smo spremni detaljno upravljati i održavati ovaj proces na konzistentan, uniforman i održiv način gdje što manje stvari radimo ručno, možemo odabrati softversku podršku za upravljanje ovakvim projektima. Postoji više popularnih rješenja kako ovo izvesti, a ovdje ćemo na informativnoj razini prikazati samo jedno od njih. Radi se o paketu ProjectTemplate. Prema riječima autora ovoga paketa, on osigurava automatsko: upravljanje datotekama projekta učitavanje potrebnih R paketa učitavanje podatkovnih skupova u memoriju pripremu i pretprocesiranje podataka Ovaj paket također pruža predloške programskoga koda za dijagnostiku i transformaciju podataka te profiliranje i testiranje razvijenih programskih skripti. Na sljedećoj slici možemo vidjeti strukturu mapa koju koristi ovaj paket: Slika 1.7: Mape koje stvara ProjectTemplate Detaljno objašnjenje svih funkcionalnosti ovoga paketa izlazi iz okvira ovoga udžbenika, a čitatelji koje zanima više detalja o ovom paketu mogu ih pronaći na poveznici http://projecttemplate.net/getting_started.html. 1.5 Kako koristiti ovaj udžbenik? Osnovna ideja ovog udžbenika jest “učenje kroz primjenu”. Zbog toga se u lekcijama u nastavku neće koristiti previše primjera, već se čitatelja potiče da svaki novi koncept usvoji kroz rješavanje niza lakših i težih zadataka. Svako poglavlje koje slijedi ima prateću “radnu bilježnicu”. Jednostavno rečeno, radi se o RMD datoteci koja sadrži sve primjere iz zadatke iz ovog udžbenika, popraćene sažetim tekstom radi lakšeg snalaženja i referenciranja na koncepte koji se obrađuju. Osnovna ideja je da čitatelj paralelno čita udžbenik i rješava radnu bilježnicu, gledajući rješenje zadatka tek nakon što ga samostalno riješi unutar programskog alata. Poneki zadaci zahtijevati će jednostavno uklanjanje znaka # (koji označava “komentar”) sa početka naredbe te njezino izvršavanje. Usprkos trivijalnom pristupu, na ovaj način se ipak jasnije potiče čitatelja za samostalno isprobavanje naredbe, umjesto da samo pogleda njezin rezultat. Drugi zadaci zahtijevati će nešto veći angažman. Konačno, nakon svake lekcije nalazi se niz “Zadataka za vježbu” uz koje se neće nalaziti rješenje te koji će predstavljati svojevrsnu provjeru svih danih koncepata lekcije. Čitateljima se snažno preporučuje rješavanje svih primjera i zadataka prije prelaska na iduću lekciju, budući da lekcije koje slijede pretpostavljaju dobro usvojeno znanje svih do tada obrađenih tema. Naravno, udžbenik je moguće čitati i bez navedenog “interaktivnog” pristupa. Rješenja uz zadatke otkrivaju ispravnu metodu pristupa problemu, a većina naredbi popraćena je ispisom kojeg bi korisnik dobio na zaslonu njihovim izvršavanjem. Usprkos tome, stav autora udžbenika jest da se programski jezici ne mogu učiti čitanjem te da se dodatni trud isprobavanja svih, pa čak i najjednostavnijih koncepata, u konačnici višestruko isplati. Upoznajmo se pobliže sa konceptom radnih bilježnica. Prvo je potrebno pronaći i otvoriti radnu bilježnicu koja odgovara lekciji koju čitate. Nju je lako prepoznati prema odgovarajućem broju lekcije - radna bilježnica za ovu lekciju nosi naziv 01_Uvod_RB.Rmd. Preporučuje se da sve radne bilježnice na kojima namjeravati raditi kopirate negdje na lokalno računalo zajedno sa svim pratećim datotekama koje se nalaze u istoj mapi ako ih ima. Kao što je rečeno, radna bilježnica će u pravilu sadržavati sav programski kod lekcije na koje se odnosi, ali samo dio teksta koliko je dovoljno za lakše snalaženje. Ukoliko ovaj tekst čitate direktno iz radne bilježnice, a ne kao dio udžbenika, možete vidjeti da nedostaje cijeli prethodni dio lekcije; to je zato što se uvodni koraci opisani u njemu tiču koncepata koje je potrebno usvojiti prije korištenja radne bilježnice. Ako ih niste prošli, preporuka je da se vratite i prođete ih te potom nastavite sa primjerima i zadacima koji slijede. Radne bilježnice razlikuju Primjere i Zadatke. Primjere je u pravilu potrebno samo izvršiti. Zadaci s druge strane očekuju izvjesne preinake ili unos novog programskog koda. Kao što je rečeno, udžbenik će postaviti daleko veći naglasak na zadatke. Primjer može izgledati ovako: Primjer - nekoliko jednostavnih naredbi R programskog jezika 3+2 #zbrajanje log(10) # prirodni logaritam! log10(10) # ovo je logaritam baze 10! Usput, komentare pišemo znakom &quot;#&quot; sin(0.5 * pi) # pi je jedna od ugrađenih konstanti ## [1] 5 ## [1] 2.302585 ## [1] 1 ## [1] 1 Naredbe iz primjera možete izvršiti pojedinačno, ili cijeli isječak odjednom kombinacijom tipaka CTRL + SHIFT + ENTER. Nikakve preinake koda nisu nužne (iako često nije loše eksperimentirati sa danim naredbama!). Zadaci s druge strane uvijek traže određenu - makar minimalnu - intervenciju. Zadatak 1.2 - naredbe za provjeru i izmjenu radne mape # izvršite sljedeće naredbe uklanjanjem znaka komentara #getwd() # mapa u kojoj trenutno radimo #setwd(&quot;.&quot;) # ovdje možemo navesti novu radnu mapu ukoliko želimo getwd() # mapa u kojoj trenutno radimo setwd(&quot;.&quot;) # ovdje možemo navesti novu radnu mapu ukoliko želimo Zadatak će se često odnositi na upravo uvedeni koncept. Npr. zgodno je za napomenuti da, iako jezik R podržava operator = za pridruživanje vrijednosti nekoj varijabli, preporučuje se korištenje operatora &lt;- u tu svrhu koji je nešto više “R-ovski”. Također, uočimo da R podržava tzv. autoprint, tj. uvijek će ispisati rezultat zadnje naredbe na zaslon. To znači da ako u isječku stvaramo novu varijablu x te ju želimo ispisati na zaslon, ne moramo kao zadnju naredbu staviti print(x) već je dovoljno staviti samo x. Isprobajmo ovo u zadatku. Zadatak 1.3 - R-ovski operator pridruživanja # upišite `5` u varijablu `x` # potom ispišite varijablu `x` na zaslon x &lt;- 5 x ## [1] 5 Konačno, na kraju većine poglavlja nalaziti će se Zadaci za vježbu, koji kroz interaktivno praćenje predmeta ujedno predstavljaju i domaće zadaće. Bitno je napomenuti da u ovisnosti o kontekstu u kojem čitatelji udžbenika usvajaju gradivo, zadaci na kraju radnih bilježnica se mogu u određenim elementima razlikovati od onoga vidljivom u samom udžbeniku. Programirajmo u R-u by Damir Pintar is licensed under a Creative Commons Attribution-NonCommercial-NoDerivatives 4.0 International License.Based on a work at https://ratnip.github.io/FER_OPJR/ "],["tipovi.html", "2 Osnovni tipovi podataka 2.1 Osnovni tipovi podataka 2.2 Operatori 2.3 Nedostajuće, nepoznate i nemoguće vrijednosti Zadaci za vježbu", " 2 Osnovni tipovi podataka “Osnovni” ili “primitivni” tipovi podataka su temeljni izgradbeni blokovi programskih jezika. Ovdje se najčešće misli na ugrađene mehanizme koji omogućuju pohrane elementarne informacije - najčešće logičkog, numeričkog ili znakovnog tipa. Većina programskih jezika koristi iste ili vrlo slične načine pohrane takvih informacija, što znači da implementira slične osnovne tipove podataka - razlika je često u detaljima kao što su odabrani nazivu tipa, nazivni broj bajtova i sl. U svakom slučaju najčešći prvi korak kod učenja novog programskog jezika jest upoznavanje osnovnih tipova podataka koje isti podržava. Sljedeća stvar koja nas potom može zanimati jest sintaksa jezika, tj. način na kojeg pišemo naredbe koje interpreter jezika može razumjeti i izvršiti. Jezik R u svojoj sintaksi slijedi slične konvencije viđene u jezicima kao što su Python, Ruby ili Java, naravno uz određene specifičnosti (kao i svaki pojedini programski jezik). Neka osnovna sintaksna pravila su: svaka naredba u pravilu mora ići u svoj redak, ali uvlačenje naredbi nije bitno kao ni stavljanje točke-zareza na kraj naredbe; blokove definiramo vitičastim zagradama; tipove varijabli ne moramo definirati unaprijed već se oni samo prilagođavaju pridruženoj vrijednosti; komentari započinju znakom #; i sl. Sintaksu ćemo najbolje naučiti kroz primjere - učenjem elemenata jezika sintaksna pravila često postaju intuitivno jasna. Najbolje je krenuti sa jednostavnim funkcijama i operatorima, što ćemo i učiniti u ovoj lekciji. Lekciju ćemo završiti raspravom o tzv. “nedostajućim” ili “nepostojećim” vrijednostima. Budući da R ima svoj vlastiti način definiranja takve vrste vrijednosti, odmah ćemo pojasniti način na koji su one u R-u implementirane kako bi u lekcijama koje slijede bili pripremljeni za lako upravljanje takvim vrijednostima (koje se vrlo često susreću u radu sa stvarnim podatkovnim skupovima). 2.1 Osnovni tipovi podataka R poznaje šest osnovnih tipova podataka: tip izvorni naziv tipa primjeri logički logical TRUE, FALSE ili T, F cjelobrojni integer 2L, 5L, 123456789L realni double 4, 6, 3.14, 2e5 kompleksni complex 5 + 2i, 7 + 1i znakovni character \"A\", \"B\", \"Pero\", \"ABCDEFGHijklmnoPQRSTUVwyz\" bajtovi raw as.raw(2), charToRaw(\"1\") Neke opaske: cjelobrojni i realni tipovi se često zajedno tretiraju kao tip numeric (iako ovo nije u potpunosti konzistentno!) kompleksni tip mora imati deklariranu imaginarnu konstantu čak i ako je ona 1 (2 + i nije dobar zapis!) tip “sirovih” bajtova se relativno rijetko koristi Provjeru da li je neka varijabla određenog tipa možemo raditi uz pomoć funkcije is.&lt;naziv_tipa&gt;. Ovo ćemo isprobati u sljedećem zadatku. Prije nego što počnemo s rješavanjem uvedimo jedan novitet: u zadacima gdje ispisujemo više stvari na zaslon korisno je vizualno odvojiti različite segmente ispisa kako bismo lakše shvatili na koji dio koda se referenciraju. U tu svrhu ćemo koristiti naredbu cat(\"-----------\\n\") koja jednostavno na zaslon ispisuje niz crtica i prelazi u novi red. Mogli smo koristiti i funkciju print(), no ona uvijek započinje ispis sa indeksom elementa dok naredba cat predstavlja “sirovi” ispis, što nam u ovom slučaju više odgovara. Zadatak 2.1 - provjera tipova podataka #isprobajte sljedeće naredbe: #is.logical(FALSE) #is.integer(2L) #is.double(1.11) # izvedite sljedeće provjere: # da li je 5L numerički tip? # da li je 3.14 numerički tip? # da li je &quot;ABC&quot; znakovni tip? # da li je 4 + 2i kompleksni tip? # da li je 5 cjelobrojni tip? is.logical(FALSE) is.integer(2L) is.double(1.11) cat(&quot;-----------\\n&quot;) is.numeric(5L) is.numeric(3.14) is.character(&quot;ABC&quot;) is.complex(4 + 2i) is.integer(5) ## [1] TRUE ## [1] TRUE ## [1] TRUE ## ----------- ## [1] TRUE ## [1] TRUE ## [1] TRUE ## [1] TRUE ## [1] FALSE Da li ste uočili nešto neobično u ovim provjerama? Pokušajte objasniti dobiveni rezultat. Tip neke varijable ili konstante možemo dohvatiti uz pomoć funkcija typeof ili class. Razlika između njih je sljedeća: typeof - dohvaća “primitivni” ili “osnovni” tip podatka (integer, double ) class - “objektni tip”, zapravo vrijednost atributa class Zadatak 2.2 - dohvat naziva tipa podatka # ispišite tipove sljedećih konstanti: TRUE, 2L, F, 3.14, &quot;ABC&quot; # ispišite klase istih konstanti. Ima li razlike? typeof(TRUE) typeof(2L) typeof(F) typeof(3.14) typeof(&quot;ABC&quot;) cat(&quot;-----------\\n&quot;) class(TRUE) class(2L) class(F) class(3.14) class(&quot;ABC&quot;) ## [1] &quot;logical&quot; ## [1] &quot;integer&quot; ## [1] &quot;logical&quot; ## [1] &quot;double&quot; ## [1] &quot;character&quot; ## ----------- ## [1] &quot;logical&quot; ## [1] &quot;integer&quot; ## [1] &quot;logical&quot; ## [1] &quot;numeric&quot; ## [1] &quot;character&quot; Podatke možemo eksplicitno pretvarati iz jednog tipa u drugi uz pomoć funkcije as.&lt;naziv_tipa&gt;: Zadatak 2.3 - pretvorba tipova podataka # Izvedite sljedeće pretvorbe i ispišite rezultat # 2.35 u integer # TRUE u numeric # 100L u character # 2.35 u character # 2e2 u character # 0 u logical # 2.75 u logical as.integer(2.35) as.numeric(TRUE) as.character(100L) as.character(2.35) as.character(2e2) as.logical(0) as.logical(2.75) ## [1] 2 ## [1] 1 ## [1] &quot;100&quot; ## [1] &quot;2.35&quot; ## [1] &quot;200&quot; ## [1] FALSE ## [1] TRUE R će sam provoditi implicitnu pretvorbu ukoliko je moguća: Zadatak 2.4 - implicitna pretvorba # napišite izraze koji odgovaraju sljedećem i ispišite rezultat: # aritmetički operator između logičke i numeričke varijable # aritmetički operator između cjelobrojne i numeričke varijable # logički operator negacije primjenjen na numeričku varijablu # aritmetički operator između logičke i numeričke varijable TRUE + 5 # aritmetički operator između cjelobrojne i numeričke varijable 5L + 3.14 # logički operator negacije primjenjen na numeričku varijablu !25 ## [1] 6 ## [1] 8.14 ## [1] FALSE Implicitna pretvorba će se izvesti samo ako je smislen - npr. aritmetički operator između znakovne i numeričke varijable rezultirati će greškom. 2.2 Operatori Kao i u drugim programskim jezicima, R dozvoljava korištenje operatora u izrazima. Neki od češće korištenih operatora su: aritmetički +, -, *, /, ** (potencija), %% (modulo), %/% (cjelobrojno dijeljenje) usporedni &lt;, &lt;=, &gt;, &gt;=, ==, != logički ! (negacija), &amp;&amp; (skalarni “i”), || (skalarni “ili”), &amp; (vektorski “i”), | (vektorski “ili”) pridruživanje &lt;- ili = Zadatak 2.5 - operatori # provjerite koliko iznosi &quot;17 na kvadrat&quot; i &quot;ostatak dijeljenja 101 sa 12&quot; # provjerite što je rezultat sljedećih izraza: `17 &gt; 13`, `!TRUE`, `5 &amp;&amp; 0`, `0. || 2` # provjerite koliko iznosi &quot;17 na kvadrat&quot; i &quot;ostatak dijeljenja 101 sa 12&quot; 17 ** 2 # radi i 17 ^ 2 101 %% 12 cat(&quot;-----------\\n&quot;) # provjerite što je rezultat sljedećih izraza: `17 &gt; 13`, `!TRUE`, `5 &amp;&amp; 0`, `0. || 2`, 17 &gt; 13 !TRUE 5 &amp;&amp; 0 0. || 2 ## [1] 289 ## [1] 5 ## ----------- ## [1] TRUE ## [1] FALSE ## [1] FALSE ## [1] TRUE Logičke vrijednosti i usporedne operatore najčešće ćemo koristiti kod tzv. “uvjetnog izvođenja naredbi”, poznatog iz drugih programskih jezika kao “IF ELSE” naredba. U R-u njezina sintaksa izgleda ovako: if (izraz) {blok} else {blok} Isprobajmo ovu naredbu na sljedećem zadatku: Zadatak 2.6 - uvjetno izvođenje naredbi # napišite naredbu koja izvodi sljedeće: # &quot;ako je 100 paran broj ispiši &#39;Uspjeh!&#39;&quot; if (100 %% 2 == 0) print(&quot;Uspjeh!&quot;) ## [1] &quot;Uspjeh!&quot; Uočili smo gore da imamo dvije vrste logičkih operatora za “i” i “ili”. Razliku ćemo objasniti kasnije, za sada je dovoljno reći da se kod uvjetnog izvođenja naredbi ili programskih petlji gotovo isključivo koristimo operatorima &amp;&amp; i || (“C++ - ovski” operatori!). Isto tako, već smo spomenuli da R nudi dva operatora pridruživanja, &lt;- i =. Između njih postoje neke sitne razlike, no one nemaju gotovo nikakav utjecaj na uobičajeno korištenje ovog operatora u praksi. U literaturi se za pridruživanje vrijednosti novim varijablama može vidjeti i jedna i druga inačica, no mi ćemo u nastavku primarno i konzistentno koristiti &lt;-, ponajviše zato kako bi programski kod bio vizualno distinktivniji od drugih programskih jezika. NAPOMENA: za jednostavniji upis operatora &lt;- možemo se koristiti kombinacijom tipaka ALT i - Kod pridruživanja pazimo da je s lijeve strane tzv. “lijeva vrijednost” (engl. lvalue). Ovo u programerskom smislu interpretiramo kao “nešto u što se može pohraniti izračunata vrijednost”. x + 1 &lt;- 2 # greška!!!] U pravilu se u R-u kao lvalue koristi varijabla, iako se tu ponekad može pojaviti i poziv funkcije. Ovu možda inicijalno zbunjujuću pojavu razjasniti ćemo kasnije. Imenovanje varijabli uglavnom slijedi pravila iz drugih programskih jezika - dozvoljena su slova, brojke, podcrta ali i točka . Prvi simbol mora biti slovo ili točka. .mojaVarijabla &lt;- 5 #OK moja.Varijabla &lt;- 5 #OK _mojaVarijabla &lt;- 5 # nije OK 123Varijabla &lt;- 5 # nije OK U praksi za varijable složenih imena trebamo odabrati jednu od sljedećih konvencija: mojaVarijabla &lt;- 1 # tzv. camelcase moja_varijabla &lt;- 2 # podcrta ili moja.varijabla &lt;- 3 # točka Bitno je da u programskom kodu ne miješamo konvencije tj. da nakon odabira budemo konzistentni. Ukoliko baš inzistiramo na čudnim imenima koja koriste specijalne znakove, onda ih moramo staviti pod tzv. “lijeve jednostruke apostrofe” (engl. backticks): Zadatak 2.7 - ime varijable sa specijalnim znakovima # upišite proizvoljno ime sa specijalnim znakovima unutar lijevih apostrofa # i ispišite vrijednost varijable #`` &lt;- 2 `!%^$*@__=` &lt;- 2 `!%^$*@__=` ## [1] 2 Ovakav način imenovanja varijabli nije previše koristan u praksi, ali ima i svoju svrhu - budući da su operatori u R-u zapravo funkcije (čija su imena doslovno +, ** i sl.) upotrebom lijevih apostrofa možemo ih direktno referencirati u njihovom originalnom obliku, što se može pokazati vrlo praktičnim kod tzv. funkcijskog programiranja (o čemu ćemo govoriti u jednoj od budućih lekcija). Pridjeljivanje vrijednosti novim nazivima varijabli mi zapravo stvaramo nove varijable u radnoj okolini (koja se u R-u naziva “globalna okolina”). Sve varijable koje smo do sada stvorili možemo vidjeti uz pomoć funkcije ls(). Ukoliko želimo obrisati neke varijable, samo navedemo njihova imena u pozivu funkcije rm() (npr. rm(x, y, z)). Za brisanje svih varijabli iz radne okoline koristimo poziv rm(list=ls()), s time što tu moramo biti oprezni (nema “undo”!). Zadatak 2.8 - ispis i brisanje varijabli globalne okoline # ispišite sve do sada stvorene varijable globalne okoline # obrišite neke od gore ispisanih varijabli - npr. rm(x, y, z) # ponovo ispišite dostupne varijable # obrišite SVE varijable globalne okoline # (oprezno s ovim pozivom u praksi!) # uvjerite se da je globalna okolina prazna # ispišite sve do sada stvorene varijable globalne okoline ls() # obrišite neke od upravo ispisanih varijabli - npr. rm(x, y, z) # ponovo ispišite dostupne varijable rm(x, y) ls() # obrišite SVE varijable globalne okoline # (oprezno s ovim pozivom u praksi!) # uvjerite se da je globalna okolina prazna rm(list=ls()) ls() Konačno, kad god nam treba pomoć oko neke funkcije, imamo sljedeće opcije na raspolaganju: napišemo samo &lt;ime_funkcije&gt; (bez zagrada sa parametrima) i stisnemo - ukoliko je funkcija pisana u R-u (a nije samo proxy prema implementaciji u C-u) na zaslon ćemo dobiti ispis izvornog koda funkcije napišemo help(&lt;ime_funkcije&gt;) ili ?&lt;ime_funkcije&gt; čime dobijamo stranicu pomoći o funkciji sa popisom parametara, primjerima i sl. napišemo example(&lt;ime_funkcije&gt;) pri čemu dobijemo popis primjera korištenja funkcije i dobivenih rezultata Sljedeći isječak koda prikazuje način korištenja gornjih metoda (zbog štednje prostora ne prikazujemo njihov rezultat). #programski kod funkcije `ls` ls # pomoć za funkciju `ls` ?ls # ili help(ls) # primjeri korištenja funkcije `ls` example(ls) 2.3 Nedostajuće, nepoznate i nemoguće vrijednosti U R-u postoji tri načina modeliranja “nepostojećih” vrijednosti: NA - (not available) nedostajuća ili nepoznata vrijednost određenog tipa NaN - (not a number) “nemogući” broj, npr. 0/0 NULL - nepostojeća vrijednost, doslovno “ništa” Zadatak 2.9 - rad sa NA, NaN i NULL # Koliko je &quot;5 + nepoznati broj&quot;? # Koliko je &quot;5 + nepostojeći broj&quot;? # provjerite klase sljedećih konstanti i izraza: # NA # aritmetička operacija između numeric i NA # NaN # NULL # Koliko je &quot;5 + nepoznati broj&quot;? 5 + NaN # Koliko je &quot;5 + nepostojeći broj&quot;? 5 + NA cat(&quot;-----------\\n&quot;) # provjerite klase sljedećih konstanti i izraza i objasnite rezultat: # NA # aritmetička operacija između numeric i NA # NaN # NULL class(NA) # logički tip je &quot;najslabiji&quot;! class(5 + NA) class(NaN) class(NULL) ## [1] NaN ## [1] NA ## ----------- ## [1] &quot;logical&quot; ## [1] &quot;numeric&quot; ## [1] &quot;numeric&quot; ## [1] &quot;NULL&quot; Provjeru nedostajućih vrijednosti radimo slično provjeri tipova podataka - koristimo funkcije is.na, is.nan i is.null. Moramo voditi računa da je NaN zapravo podvrsta od NA te da je NULL zapravo potpuno zasebna klasa sa specifičnim ponašanjem - pokušaj aritmetičkih ili logičkih operacija nad NULL vrijednosti neće rezultirati “novom” nepostojećom vrijednosti već upozorenjima i “praznim” rezultatima. Ovo je posebno bitno napomenuti poznavateljima jezika SQL - ono što je NULL u SQL-u je NA u R-u i to je ono što u pravilu koristimo u praksi, dok NULL ima vrlo specifične primjene te ga puno rjeđe koristimo u programskom kodu. Primjer - nekoliko jednostavnih naredbi R programskog jezika # Što je od idućeg NA? NA, NaN, NULL, &quot;&quot;, 0 is.na(NA) is.na(NaN) is.na(NULL) is.na(&quot;&quot;) is.na(0) cat(&quot;-----------\\n&quot;) # Što je od idućeg NaN? NA, NaN, NULL is.nan(NA) is.nan(NaN) is.nan(NULL) cat(&quot;-----------\\n&quot;) # Što je od idućeg NULL? NA, NaN, NULL is.null(NA) is.null(NaN) is.null(NULL) ## [1] TRUE ## [1] TRUE ## logical(0) ## [1] FALSE ## [1] FALSE ## ----------- ## [1] FALSE ## [1] TRUE ## logical(0) ## ----------- ## [1] FALSE ## [1] FALSE ## [1] TRUE Objasnimo što znači izraz logical(0) - ovo je R-ov način izjave da je rezultat “prazan logički vektor”, a nastaje kada postavljamo logičko pitanje o elementu koji formalno ne postoji, tj. element kojeg smo referencirali, ali na posebni način koji označava da se radi o “nepostojećem elementu”. Moramo biti posebno oprezni kada postavljamo ovakva pitanja u sprezi sa if izjavom, budući da će korištenje iste na ovakav način uzrokovati grešku. Za kraj posvetimo se malo NA vrijednosti, budući da ćemo ju vrlo često susretati u praksi. Pojednostavljeno rečeno, ukoliko se pojavljuju NA vrijednosti, možemo očekivati sljedeće nuspojave: rezultati aritmetičkih izraza rezultiraju sa NA vrijednosti rezultati poziva nekih funkcija rezultiraju sa NA (osim ako ne navedemo kompenzacijske akcije, kao npr. parametar na.rm = T koji zapravo znači “ignoriraj NA”) rezultati logičkih izraza mogu ali ne moraju rezultirati sa NA vrijednosti ovisno o tom da li izraz ovisi o NA ili ne (npr. TRUE || NA ima rezultat TRUE, ali FALSE || NA ima rezultat NA) S ovim zadnjim moramo biti posebno oprezni, budući da NA u uvjetnom izrazu rezultira greškom: if (NA &lt; 2) print(&quot;Uspjeh!&quot;) # greška!! U ovoj lekciji upoznali smo se sa osnovnim elementima jezika R. U radu s R-om u pravilu radimo sa složenim tipovima podataka koje ćemo upoznati u nastavku - a to su vektori, matrice, podatkovni okviri i liste. Zadaci za vježbu Što je rezultat sljedećih naredbi? Razmislite o mogućem rezultatu prije izvršavanja. as.complex(2) as.integer(-3.25) as.logical(&quot;0&quot;) as.numeric(TRUE) as.character(11.5+2i) as.numeric(&quot;ABC&quot;) Kako u R-u izgledaju sljedeći opisni izrazi: “tri puta deset na devetu” “logaritam od 5” “cjelobrojno dijeljenje 10 sa 3” “ostatak cjelobrojnog dijeljenja 10 sa 3” “tangens od 75 stupnjeva” | Uz pomoć if izraza provjerite da li se rezultat dijeljenja nule s nulom smatra kao vrijednost NA, NaN ili NULL. Ubacite u varijablu x vrijednost 5. Ispišite sve varijable okoline. Potom u varijablu x ubacite NULL. Postoji li i dalje ova varijabla? Programirajmo u R-u by Damir Pintar is licensed under a Creative Commons Attribution-NonCommercial-NoDerivatives 4.0 International License.Based on a work at https://ratnip.github.io/FER_OPJR/ "],["vektori.html", "3 Vektori, matrice i liste 3.1 Vektori 3.2 Indeksni vektori 3.3 Matrice i polja 3.4 Liste Zadaci za vježbu", " 3 Vektori, matrice i liste 3.1 Vektori Vektor je jedan od “složenih” tipova podataka u jeziku R, u smislu da sadržava više vrijednosti istog tipa. On je kao takav sličan pojmu “polja” u jeziku C. No ovdje postoji jedna bitna razlika, koju je nužno usvojiti budući da se radi o jednoj od najvažnijih karakteristika jezika R - u R-u je (gotovo) svaki tip varijable zapravo vektor. Čak i varijable i konstante koje smo koristili u prethodnoj lekciji su zapravo bili jednoelementni vektori. Ovo ima dalekosežne posljedice o kojima ćemo detaljno raspravljati u nastavku, a za početak se prvo upoznajmo sa sintaksom stvaranja i upravljanja vektorima. 3.1.1 Stvaranje vektora Novi vektor (koji ima više od jednog elementa) stvaramo uz pomoć funkcije c (od engl. combine). # numerički vektor m &lt;- c(1, 2, 3, 4, 5) # logički vektor v &lt;- c(T, F, T) # znakovni vektor imena &lt;- c(&quot;Ivo&quot;, &quot;Pero&quot;, &quot;Ana&quot;) Dakle, jednostavno rečeno, vektor je uređeni skup elemenata istog tipa. Ovo konkretno znači da svi elementi vektora moraju biti istog tipa. Ako stvaramo novi vektor sa elementima različitih tipova podataka, R će sve elemente automatski pretvoriti u “najjači” tip, što će na kraju postati i tip samog vektora (termin “jači” tip u ovom kontekstu označavaju mogućnost tipa da pohrani svu informaciju “pohranjenu u slabiji” tip, a u općenitom slučaju pretvorba ide u smjeru logički -&gt; numerički -&gt; znakovni tip). Zadatak 3.1 - stvaranje vektora # stvorite novi vektor `x` sa četiri proizvoljna elementa sljedećih tipova: # logički, realni, znakovni i cjelobrojni # ispišite na zaslon sadržaj vektora i njegovu klasu # stvorite novi vektor `x` sa četiri proizvoljna elementa sljedećih tipova: # logički, realni, znakovni i cjelobrojni x &lt;- c(T, 1.25, &quot;Ivo&quot;, 10L) # ispišite na zaslon sadržaj vektora i njegovu klasu x class(x) ## [1] &quot;TRUE&quot; &quot;1.25&quot; &quot;Ivo&quot; &quot;10&quot; ## [1] &quot;character&quot; Vektor možemo eksplicitno pretvoriti u drugi tip uz pomoć već upoznatih funkcija as.&lt;naziv_tipa&gt;. Ukoliko je pretvorbu nemoguće provesti element će biti pretvoren u NA uz prikladno upozorenje. Zadatak 3.2 - eksplicitna pretvorba tipa vektora x &lt;- c(1, T, 2L) y &lt;- c(1L, 2L, 3L) z &lt;- c(1.25, TRUE, &quot;Ana&quot; ) # razmislite o mogućem rezultatu a potom pokušajte izvršiti sljedeće pretvorbe # vektor `x` u numerički tip # vektor `y` u znakovni tip # vektor `z` u cjelobrojni tip # razmislite o mogućem rezultatu a potom pokušajte izvršiti sljedeće pretvorbe # vektor `x` u numerički tip # vektor `y` u znakovni tip # vektor `z` u cjelobrojni tip as.numeric(x) as.character(y) as.integer(z) ## Warning: NAs introduced by coercion ## [1] 1 1 2 ## [1] &quot;1&quot; &quot;2&quot; &quot;3&quot; ## [1] 1 NA NA Možete li odgovoriti na pitanje - zašto u zadnjem primjeru vrijednost TRUE nije postala 1L već NA? Pokušajte ispisati vektor z i uočite rezultate implicitne pretvorbe koju ste možda zanemarili (a koja je logičku vrijednost TRUE pretvorila u niz znakova \"TRUE\" kojeg više nije moguće “vratiti” u numeričku vrijednost 1L). Funkcijom c možemo također i više vektora spojiti u jedan: a &lt;- c(1, 2, 3) b &lt;- c(4, 5) c &lt;- c(6, 7, 8) # varijablu smijemo nazvati &quot;c&quot; usprkos tome što postoji funkcija c() d &lt;- c(a, b, c) # d je sada c(1, 2, 3, 4, 5, 6, 7, 8) Pored funkcije c, R nudi i dodatne pogodne načine stvaranja novih vektora: : - operator “raspona” (engl. range), pri čemu dajemo raspon od gornje do donje granice, obje uključive seq - funkcija sekvence (engl. sequence), radi slično operatoru raspona, ali s dodatnim mogućnostima rep - funkcija repliciranja (engl. replicate), ponavlja zadane elemente zadani broj puta Zadatak 3.3 - pomoćne funkcije za stvaranje vektora # ispišite rezultate sljedećih naredbi # 1:5 # rep(c(1, 2, 3), times = 3) # rep(c(1, 2, 3), each = 3) # seq(1, 5, by = 0.5) # ispišite rezultate sljedećih naredbi 1:5 rep(c(1, 2, 3), times = 3) rep(c(1, 2, 3), each = 3) seq(1, 5, by = 0.5) ## [1] 1 2 3 4 5 ## [1] 1 2 3 1 2 3 1 2 3 ## [1] 1 1 1 2 2 2 3 3 3 ## [1] 1.0 1.5 2.0 2.5 3.0 3.5 4.0 4.5 5.0 Vektore možemo stvoriti i uz pomoć funkcija koje odgovaraju imenima tipova vektora (numeric, character i sl.) pri čemu kao parametar navodimo željenu duljinu vektora. Ovo često radimo kao “pripremu” vektora za naknadno punjenje stvarnim vrijednostima, tj. svojevrsnu rezervaciju mjesta u radnoj memoriji. Ono što je interesantno jest činjenica da možemo stvoriti i “prazan” vektor određenog tipa koji je i dalje vektor, samo sa duljinom nula (a kojem npr. uz pomoć funkcije c možemo naknadno dodavati elemente). x &lt;- numeric(2) # vektor se puni &quot;nultim&quot; elementima, u ovom slučaju (0, 0) y &lt;- character(5) z &lt;- integer(0) # &quot;prazan&quot; vektor! z &lt;- c(z, 1) # dodaj vektoru element 1 (zapravo &quot;spoji prazan vektor i element 1&quot;) Konačno, provjeru da li neki vektor sadrži određeni element možemo napraviti uz pomoć operatora %in%: 4 %in% seq(1, 10, 2) # vraća FALSE &quot;d&quot; %in% c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;) # vraća TRUE Pogledajmo sada kako pristupiti pojedinim elementima vektora 3.1.2 Operator [ Elementima vektora pristupamo preko indeksnog operatora [, uz pomoć kojeg možemo i mijenjati elemente vektora: a &lt;- c(2, 4, 6) a[1] # ispisuje vrijednost 2 a[2] &lt;- 5 # element na 2. mjestu postaje 5 a[5] &lt;- 7 # na 5. mjesto dodaje se 7, a &quot;rupa&quot; se popunjava sa NA a ## [1] 2 ## [1] 2 5 6 NA 7 Uočite jednu pomalo neuobičajenu činjenicu - prvi element vektora u R-u ima indeks 1, a ne 0! Ovo je bitna razlika u odnosu na referenciranje elemenata u drugim programskim jezicima. Razlog ove specifičnosti je jednostavan - R se primarno smatra jezikom za analizu podataka, poglavito u tabličnom obliku, a u praksi je puno lakše brojati retke ili stupce redoslijedom kako se pojavljuju u podatkovnom skupu nego raditi “posmak za 1”. Primjer gore zapravo prikazuje vrlo pojednostavljeni slučaj pristupanja elementima vektora i način njihove izmjene. Naime, jedna od specifičnosti jezika R je tzv. vektoriziranost, tj. princip da se u R-u vrlo često radi “više stvari odjednom” - ne toliko u smislu paralelnog izvršavanja, već u smislu zadavanja naredbi što želimo da se izvede. Konkretno, u slučaju referenciranja elemenata vektora vrlo rijetko dohvaćamo ili mijenjamo elemente jedan po jedan, već obuhvaćamo veći broj elemenata odjednom korištenjem principa vektorizacije i recikliranja. Razumijevanje ovih pojmova presudno je za svladavanje jezika R, tako da ćemo ih detaljno objasniti u nastavku. 3.1.3 Principi vektorizacije i recikliranja Pojam vektorizacije ili bolje rečeno vektoriziranih operacija i funkcija jednostavno znači da se operacije rade nad više elemenata odjednom. Ako zadamo R-u da radi neku operaciju ili funkciju nad nekim vektorom vrijednosti, R će funkciju ili operaciju izvesti nad svakim elementom posebno i vratiti rezultantni vektor kao rezultat. Isto tako, ako provodimo binarnu operaciju nad dva vektora, ona će se provesti nad “uparenim” ili “poravnatim” elementima obaju vektora (pretpostavimo za sada da su vektori jednake duljine). Zadatak 3.4 - princip vektorizacije x &lt;- seq(-5, 5, 1) a &lt;- 1:3 b &lt;- 4:6 # pozovite funkciju `abs` za računanje apsolutne vrijednosti # nad vektorom `x` i ispišite rezultat # zbrojite vektore `a` i `b` uz pomoć operatora `+` # i ispišite rezultat # pomnožite vektore `a` i `b` uz pomoć operatora `*` # i ispišite rezultat # pozovite funkciju `abs` za računanje apsolutne vrijednosti # nad vektorom `x` i ispišite rezultat abs(x) cat(&quot;-----------\\n&quot;) # zbrojite vektore `a` i `b` uz pomoć operatora `+` # i ispišite rezultat a + b cat(&quot;-----------\\n&quot;) # pomnožite vektore `a` i `b` uz pomoć operatora `*` # i ispišite rezultat a * b ## [1] 5 4 3 2 1 0 1 2 3 4 5 ## ----------- ## [1] 5 7 9 ## ----------- ## [1] 4 10 18 Pažljivo razmotrite rezultate prethodnog zadatka. Ukoliko je potrebno, skicirajte vektore a i b na papiru sa vertikalno poslaganim elementima i uočite kako radi paralelno “uparivanje” elemenata. Primijetite da ovdje ne pričamo o “vektorskim operacijama” u strogom matematičkom smislu, već o poravnavanju elemenata dvaju nizova i provođenja jednostavnih operacija nad svakim od tih parova. Ovo je pogotovo očito u zadnjem primjeru gdje nema nikakvog “množenja vektora” u nekoj od matematičkih interpretacija, već se provodi jednostavno množenje paralelnih elemenata dvaju vektora. Što ako vektori nisu jednake duljine? R u ovom slučaju koristi princip recikliranja. Princip recikliranja navodi da se kod nejednake duljine vektora kraći vektor “reciklira” onoliko puta koliko je potrebno da se dostigne duljina duljeg vektora. Najčešći scenarij korištenja ovog principa su operacije u kojima je s jedne strane vektor s više elemenata a s druge strane jednoelementni vektor koji se onda reciklira za svaki element “velikog” vektora. Ono što bismo trebali izbjegavati jest scenarij recikliranja gdje duljina “velikog” vektora nije višekratnik duljine “malog” - R će i dalje reciklirati kraći vektor, samo će ga na kraju morati “odrezati” što će rezultirati odgovarajućim upozorenjem. Zadatak 3.5 - princip recikliranja a &lt;- 1:4 b &lt;- c(1, 2) c &lt;- rep(5, 3) # udvostručite elemente vektora `a` i ispišite rezultat # podijelite vektor `a` vektorom `b` i ispišite rezultat # pomnožite vektore `a` i `c` i ispišite rezultat a &lt;- 1:4 b &lt;- c(1, 2) c &lt;- rep(5, 3) # udvostručite elemente vektora `a` i ispišite rezultat 2 * a # podijelite vektor `a` vektorom `b` i ispišite rezultat a / b # pomnožite vektore `a` i `c` i ispišite rezultat a * c ## Warning in a * c: longer object length is not a multiple of shorter object ## length ## [1] 2 4 6 8 ## [1] 1 1 3 2 ## [1] 5 10 15 20 Sada konačno možemo demistificirati razliku između “skalarnih” i “vektorskih” logičkih operatora (podsjetimo se, skalarni su || i &amp;&amp;, dok su vektorski | i &amp;). Skalarni logički operatori namijenjeni su korištenju sa jednoelementnim vektorima, vraćaju jedinstvenu vrijednosti TRUE ili FALSE te su pogodni za korištenje raznim u uvjetnim izrazima. Vektorski logički operatori koriste standardne R-ove principe vektorizacije i recikliranja, tj. namijenjeni su radu sa logičkim vektorima i kao rezultat daju logički vektor Zadatak 3.6 - skalarni i vektorski logički operatori a &lt;- c(T, F, F) b &lt;- c(T, T, F) # primjenite skalarnu i vektorsku inačicu logičkog operatora &quot;ili&quot; # nad vektorima `a` i `b` i ispišite rezultat # pokušajte primjeniti skalarnu i vektorsku inačicu logičkog operatora &quot;ili&quot; # nad vektorima `a` i `b` i objasnite rezultat a || b a | b Vidimo da skalarna inačica rezultira greškom jer pokušavamo tročlani vektor interpretirati kao jedistvenu logičku vrijednost. Sljedeći primjer sa usporednim operatorima će možda inicijalno izgledati trivijalan, no potrebno je obratiti posebnu pažnju na rezultate koje ćemo dobiti budući da će oni imati vrlo važnu primjenu u nastavku lekcije. Dakle, pogledajmo što se događa kod vektorizacije usporednih operatora. Zadatak 3.7 - vektorizacija usporednih operatora x &lt;- 1:5 y &lt;- seq(-10, 10, 5) #ispišite x i y #ispišite rezultat naredbe x &gt; y i objasnite rezultat #ispišite rezultat naredbe x &lt; 3 i objasnite rezultat #ispišite x i y x y cat(&quot;-----------\\n&quot;) #ispišite rezultat naredbe x &gt; y i objasnite rezultat x &gt; y cat(&quot;-----------\\n&quot;) #ispišite rezultat naredbe x &lt; 3 i objasnite rezultat x &lt; 3 ## [1] 1 2 3 4 5 ## [1] -10 -5 0 5 10 ## ----------- ## [1] TRUE TRUE TRUE FALSE FALSE ## ----------- ## [1] TRUE TRUE FALSE FALSE FALSE Dakle vektoriziranom primjenom usporednih operatora nad vektorima (ili kombinacijama vektora i “skalara”) kao rezultat dobivamo logičke vektore. Interpretacija ovih rezultata je ključna - ona zapravo odgovara na pitanje “na kojim indeksima je zadovoljen uvjet zadan ovim izrazom”? Drugim riječima, dobiveni rezultati zapravo predstavljaju predložak koji opisuje kako filtrirati elemente prema zadanom principu. Ovo je osnovni temelj tzv. logičkog referenciranja, što je jedna od metoda dohvaćanja elemenata vektora koje ćemo upoznati u nastavku. 3.2 Indeksni vektori Već smo naučili da elementu polja možemo pristupiti preko numeričkog indeksa (a nismo zaboravili ni činjenicu da prvi element ima indeks 1). Ovaj koncept možemo proširiti tako da iz vektora uzimamo više elemenata odjednom. što se često naziva “rezanjem” vektora (engl. slicing). Osnovni princip odabira više elemenata odjednom je jednostavan - samo moramo na određeni način navesti indekse elemenata koje želimo. R nudi tri osnovna načina referenciranja: lokacijsko referenciranje (engl. integer- or location-based referencing) uvjetno referenciranje (engl. conditional- or boolean-based referencing) imensko referenciranje (engl. label-based referencing) Koje referenciranje ćemo odabrati ovisi o tome želimo li elementima pristupati ovisno o njihovoj lokaciji, imenu ili prema zadanom uvjetu, a svaki tip referenciranja u suštini se svodi na korištenje vektora određenog tipa kao parametra za operator referenciranja. Ovakav vektor se zbog svoje uloge naziva “indeksnim vektorom”. Upoznajmo detaljno svaki od tipova referenciranja. 3.2.1 Lokacijsko referenciranje Lokacijsko referenciranje je poopćenje već upoznatog principa referenciranja gdje navodimo redni broj elementa koji nas zanima. Ako želimo više elemenata, jednostavno navedemo njihove indekse “zapakirane” u numerički vektor. Pokušajte riješiti sljedeći zadatak korištenjem odgovarajućih numeričkih vektora kao parametara indeksnog operatora. Zadatak 3.8 - lokacijsko referenciranje x &lt;- 1:10 # ispišite prvi element vektora x # ispišite prva tri elementa vektora x # ispišite prvi, peti i sedmi element vektora x # ispišite prvi element vektora x x[1] # ispišite prva tri elementa vektora x x[1:3] # ispišite prvi, peti i sedmi element vektora x x[c(1,5,7)] ## [1] 1 ## [1] 1 2 3 ## [1] 1 5 7 Dakle, lokacijski indeksni vektor nije ništa drugo nego običan numerički vektor kojeg koristimo zajedno sa indeksnim operatorom da bi odredili koje elemente nekog drugog vektora želimo “zadržati”. Pogledajmo još neke značajke lokacijskih indeksnih vektora: Zadatak 3.9 - lokacijsko referenciranje (2) x &lt;- 1:10 # odgovorite na sljedeća pitanja uz pomoć prikladnog primjera # što vraća indeks 0? # što vraća negativni indeks? # što vraća indeks izvan granica duljine vektora x &lt;- 1:10 # odgovorite na sljedeća pitanja uz pomoć prikladnog primjera # što vraća indeks 0? x[0] # što vraća negativni indeks? x[-1] # što vraća indeks izvan granica duljine vektora x[20] ## integer(0) ## [1] 2 3 4 5 6 7 8 9 10 ## [1] NA Indeksni operator se ne koristi samo za dohvaćanje elemenata. Kombinacijom indeksnog operatora i operatora pridruživanja možemo mijenjati elemente vektora (i to također po principu “više elemenata odjednom”: Zadatak 3.10 - lokacijsko referenciranje i pridruživanje a &lt;- 1:10 # postavite sve elemente vektora `a` od drugog do osmog mjesta na nulu # ispišite vektor `a` b &lt;- 1:20 b[2 * 1:5] &lt;- 0 # razmislite kako izgleda vektor `b` nakon gornje naredbe # ispišite vektor `b` i objasnite rezultat a &lt;- 1:10 # postavite sve elemente vektora `a` od drugog do osmog mjesta na nulu # ispišite vektor `a` a[2:8] &lt;- 0 a b &lt;- 1:20 b[2 * 1:5] &lt;- NA # razmislite kako izgleda vektor `b` nakon gornje naredbe # ispišite vektor `b` i objasnite rezultat b ## [1] 1 0 0 0 0 0 0 0 9 10 ## [1] 1 NA 3 NA 5 NA 7 NA 9 NA 11 12 13 14 15 16 17 18 19 20 3.2.2 Uvjetno referenciranje Ako smo pažljivo razmotrili rezultate dobivene kod primjera sa vektoriziranim usporednim operatorima onda smo mogli vrlo dobro naslutiti kako radi uvjetno referenciranje. Princip je jednostavan - za indeksni vektor postavljamo logički vektor iste duljine kao i vektor čije elemente želimo dohvatiti. Elementi logičkog vektora određuju koje elemente zadržavamo (pozicije gdje se nalazi vrijednost TRUE) a koje odbacujemo (pozicije gdje se nalazi vrijednost FALSE). Zadatak 3.11 - uvjetno referenciranje x &lt;- 1:10 # napravite logički vektor `y` duljine 10 sa proizvoljnom kombinacijom # vrijednosti TRUE i FALSE # indeksirajte vektor `x` vektorom `y`, ispišite i objasnite rezultat # ispišite sve elemente vektora `x` manje ili jednake 5 # kao logički indeksni vektor upotrijebite odgovarajući izraz # koji koristi usporedni operator x &lt;- 1:10 # napravite logički vektor `y` duljine 10 sa proizvoljnom kombinacijom # vrijednosti TRUE i FALSE y &lt;- c(T, T, F, T, F, F, F, T, F, T) # indeksirajte vektor `x` vektorom `y`, ispišite i objasnite rezultat x[y] # ispišite sve elemente vektora `x` manje ili jednake 5 # kao logički indeksni vektor upotrijebite odgovarajući izraz # koji koristi usporedni operator x[x &lt;= 5] ## [1] 1 2 4 8 10 ## [1] 1 2 3 4 5 Zadnja naredba, naoko jednostavna, predstavlja jedan od ključnih principa odabira elemenata u jeziku R. Kombinacija indeksnog operatora i uvjetnog izraza predstavlja sažet ali vrlo moćan mehanizam rezanja vektora prema odabranom kriteriju. Isprobajmo ovaj princip na još nekoliko primjera. Zadatak 3.12 - uvjetno referenciranje y &lt;- sample(1:100, 20) # nasumicni odabir 20 elemenata izmedju 1 i 100 studenti &lt;- c(&quot;Ivo&quot;, &quot;Petra&quot;, &quot;Marijana&quot;, &quot;Ana&quot;, &quot;Tomislav&quot;, &quot;Tin&quot;) # ispišite vektor koji sadrži sve parne, a potom sve neparne elemente vektora `y` # ispišite sve elemente vektora `studenti` koji predstavljaju imena od 3 slova # (napomena: za prebrojavanje slova znakovnog niza u R-u koristimo funkciju `nchar`) y &lt;- seq(1, 100, 7) studenti &lt;- c(&quot;Ivo&quot;, &quot;Petra&quot;, &quot;Marijana&quot;, &quot;Ana&quot;, &quot;Tomislav&quot;, &quot;Tin&quot;) # ispišite vektor koji sadrži sve parne, a potom sve neparne elemente vektora `y` c(y[y %% 2 == 0], y[y %% 2 != 0]) # ispišite sve elemente vektora `studenti` koji predstavljaju imena od 3 slova # (napomena: za prebrojavanje slova znakovnog niza u R-u koristimo funkciju `nchar`) studenti[nchar(studenti) == 3] ## [1] 8 22 36 50 64 78 92 1 15 29 43 57 71 85 99 ## [1] &quot;Ivo&quot; &quot;Ana&quot; &quot;Tin&quot; Ukoliko koncept uvjetnog referenciranja uz pomoć uvjetnih izraza i dalje nije jasan, jedna od stvari koje mogu pomoći jest skiciranje “međurezultata” - jednostavno na papir ispišite rezultat izraza unutar uglatih zagrada indeksnog operatora i potom razmislite kako taj rezultat utječe na konačno rješenje. Preostao nam je još samo zadnji tip referenciranja koji radi na principu dohvaćanja elemenata vektora ovisno o njihovom imenu. 3.2.3 Imensko referenciranje Imensko referenciranje radi na principu eksplicitnog imenovanja elemenata koje želimo “zadržati”. Da bi mogli koristiti ovakav tip referenciranja moramo zadovoljiti nužan preduvjet - elementi vektora moraju imati definirana “imena”. Vektori koje smo do sada koristili nisu imali imenovane elemente. Svaki element imao je svoju predefiniranu poziciju unutar vektora te svoju vrijednost, ali nije imao nikakav poseban dodatni identifikator. Programski jezik R dopušta pridavanje imena elementima vektora na vrlo jednostavan način - korištenjem funkcije names, operatora pridruživanja te znakovnog vektora sa odabranim imenima. Moramo voditi računa da vektor imena bude jednake duljine kao originalni vektor! Zadatak 3.13 - imensko referenciranje visine &lt;- c(165, 173, 185, 174, 190) names(visine) &lt;- c(&quot;Marica&quot;, &quot;Pero&quot;, &quot;Josip&quot;, &quot;Ivana&quot;, &quot;Stipe&quot;) # ispišite vektor `visine` # ispišite koliko su visoki Pero i Ivana visine &lt;- c(165, 173, 185, 174, 190) names(visine) &lt;- c(&quot;Marica&quot;, &quot;Pero&quot;, &quot;Josip&quot;, &quot;Ivana&quot;, &quot;Stipe&quot;) # ispišite vektor `visine` visine # ispišite koliko su visoki Pero i Ivana visine[c(&quot;Pero&quot;, &quot;Ivana&quot;)] ## Marica Pero Josip Ivana Stipe ## 165 173 185 174 190 ## Pero Ivana ## 173 174 Vidimo da se imensko referenciranje očekivano svodi na prosljeđivanje odgovarajućeg znakovnog vektora kao parametra referenciranja. (NAPOMENA: Pažljiviji čitatelj uočiti će jednu neobičnu činjenicu u gornjem programskom kodu - poziv funkcije se koristi kao lvalue! Odgovor na pitanje zašto je ovo moguće zahtijeva malo više znanja o internom funkcioniranju jezika R, a za sada je dovoljno reći da se ovdje zapravo radi o pozivu funkcije pravog imena names&lt;- koji se “skriva” iza puno intuitivnije i lako razumljive sintakse) Ukoliko iz nekog razloga poželimo obrisati imena elemenata vektora, jednostavno pozivu funkcije names proslijedimo NULL. names(visine) &lt;- NULL Ovime ćemo zaključiti priču o vektorima. Naučili smo različite načine stvaranja vektora te dohvaćanja i izmjene njegovih elemenata. Sada je vrijeme da pokušamo vektorima dodati dodatnu “dimenziju” - upoznajmo matrice i polja. 3.3 Matrice i polja Matrice i polja su, jednostavno rečeno, višedimenzionalni vektori. Matrica (engl. matrix) je tako vektor sa dvije dimenzije, tj. vektor koji elemente smiješta u “retke” i “stupce”. Polje (engl. array) je vektor sa tri ili više dimenzija. Dok se matrice relativno često koriste u praksi, polja su ipak nešto više ograničena na posebne scenarije. Zbog ove činjenice u ovom poglavlju uglavnom ćemo se baviti matricama, iako se prikazani koncepti vrlo lako poopćuju na polja. Ono što je zajedničko matricama i poljima, a što je poznata činjenica čitateljima sa programerskim iskustvom, jest da je njihova višedimenzionalnost zapravo prividna. I matrice i polja su zapravo jednodimenzionalni vektori kojima je dodan atribut dimenzionalnosti, a uz pomoć tog atributa jezik R mapira naše višedimenzionalno referenciranje u “stvarni” indeks elementa jednodimenzionalnog vektora. Ova činjenica nas ne ograničava - mi i dalje možemo u većini slučajeva tretirati matricu kao da je zaista dvodimenzionalna, a znanje o jednodimenzionalnoj prirodi nam može samo dati dodatnu fleksibilnost u radu s matricama. Postoji nekoliko načina stvaranja nove matrice: uz pomoć funkcije matrix kojoj prosljeđujemo jednodimenzionalni vektor i željeni broj redaka i stupaca kroz parametre nrow i ncol “ručnim” postavljanjem dimenzija jednodimenzionalnog vektora uz pomoć funkcije dim i pridruživanja dvoelementnog numeričkog vektora sa dimenzijama matrice “ljepljenjem” jednodimenzionalnih vektora koji predstavljaju retke ili stupce nove matrice uz pomoć funkcija rbind (engl. row bind) i cbind (engl. column bind) Demonstrirajmo ove načine u primjerima koji slijede. Zadatak 3.14 - funkcija matrix x &lt;- 1:12 # uz pomoć funkcije `matrix` i stvorite matricu sa 3 retka i 4 stupca # koja sadrži elemente vektora `x` # ispišite rezultat na zaslon # ponovite postupak ali pozivu funkcije dodajte parametar `byrow = T` # ispišite rezultat na zaslon i usporedite s prethodnim rezultatom # uz pomoć funkcije `matrix` stvorite matricu sa 3 retka i 4 stupca # koja sadrži elemente vektora `x` # ispišite rezultat na zaslon matrix(x, nrow = 3, ncol = 4) # ponovite postupak ali pozivu funkcije dodajte parametar `byrow = T` # ispišite rezultat na zaslon i usporedite s prethodnim rezultatom matrix(x, nrow = 3, ncol = 4, byrow = T) ## [,1] [,2] [,3] [,4] ## [1,] 1 4 7 10 ## [2,] 2 5 8 11 ## [3,] 3 6 9 12 ## [,1] [,2] [,3] [,4] ## [1,] 1 2 3 4 ## [2,] 5 6 7 8 ## [3,] 9 10 11 12 Uočite da ga ukoliko eksplicitno ne zamolimo drugačije, R matricu popunjava po stupcima. Ovo je napravljeno zbog sličnosti matrice sa tabličnim prikazom podataka koje najčešće analiziramo gledajući pojedine stupce. No budući da nam je često punjenje po retcima “prirodnije”, ne smijemo zaboraviti na vrlo korisni parametar byrow. Zadatak 3.15 - funkcija dim m &lt;- 1:10 # ispišite rezultat poziva funkcije `dim` nad vektorom `m` # pozivu funkcije `dim` nad vektorom `m` pridružite vektor c(2, 5) # ispišite `m` i komentirajte rezultat # ispišite rezultate poziva funkcija `nrow` i `ncol` nad matricom `m` m &lt;- 1:10 # ispišite rezultat poziva funkcije `dim` nad vektorom `m` dim(m) # pozivu funkcije `dim` nad vektorom `m` pridružite vektor c(2, 5) dim(m) &lt;- c(2, 5) # ispišite `m` i komentirajte rezultat m # ispišite rezultate poziva funkcija `nrow` i `ncol` nad matricom `m` nrow(m) ncol(m) ## NULL ## [,1] [,2] [,3] [,4] [,5] ## [1,] 1 3 5 7 9 ## [2,] 2 4 6 8 10 ## [1] 2 ## [1] 5 Vidimo da “običan” vektor zapravo nema dimenziju, što se očituje preko NULL vrijednosti koju smo dobili kao rezultat. Pozivom funkcije dim mi vektoru zapravo dodajemo atribut naziva dim čime on formalno postaje matrica (tj. polje u općenitom slučaju). Upravo dimenzije su te koje definiraju kako su elementi složeni po retcima i stupcima a postavljanjem dimenzija moramo biti oprezni da one odgovaraju trenutnom broju elemenata. Jednom kad matrica ima dodane dimenzije, možemo ih dohvatiti “zajedno” uz pomoć funkcije dim, ili samo broj redaka ili stupaca uz pomoć funkcija nrow i ncol. Rezultantna matrica je poput one iz prethodnog primjera popunjena po stupcima. Budući da ovdje nemamo priliku koristiti parametar byrow, jedan od načina da dobijemo matricu popunjenu po retcima jest da transponiramo dobiveni rezultat uz pomoć funkcije t. m &lt;- t(m) # transponiramo matricu i pohranjujemo natrag u varijablu `m` Konačno, matricu možemo stvoriti “ljepljenjem” redaka i stupaca uz pomoć funkcija rbind i cbind. Ovo je također zgodan način dodavanja novih redaka i stupaca postojećoj matrici. Zadatak 3.16 - funkcije rbind i cbind a &lt;- 1:4 b &lt;- 5:8 c &lt;- c(0,0) # stvorite matricu `m` u kojoj će vektori `a` i `b` biti retci # dodajte novi redak na vrh matrice `m` sa elementima vektora `c` # ispišite matricu `m` a &lt;- 1:4 b &lt;- 5:8 c &lt;- c(0,0) # stvorite matricu `m` u kojoj će vektori `a` i `b` biti stupci m &lt;- cbind(a,b) # dodajte novi redak na vrh matrice `m` sa elementima vektora `c` # ispišite matricu `m` m &lt;- rbind(c, m) m ## a b ## c 0 0 ## 1 5 ## 2 6 ## 3 7 ## 4 8 3.3.1 Rezanje matrica Sve naučene principe za “rezanje” vektora uz pomoć indeksnih vektora možemo direktno primijeniti nad matricama. Razlike su sljedeće: referenciramo svaku dimenziju zasebno prvo referenciramo retke, a potom stupce, a indeksne vektore odvajamo zarezom ako želimo “sve retke” ili “sve stupce” taj indeksni vektor jednostavno izostavimo (ali i dalje koristimo zarez) # pretpostavimo da je `m` matrica dimenzija 3 x 5, sa imenima stupaca od `a` do `e` m[1, 2:5] # prvi redak, svi stupci od drugog do petog m[c(F, T, T), c(&quot;a&quot;, &quot;b&quot;)] # drugi i treći redak, stupci `a` i `b` m[,] # svi retci i svi stupci (može i samo `m`) U praksi kod matrica najčešće koristimo lokacijsko i imensko referenciranje; uvjetno referenciranje nije previše praktično zbog dvodimenzionalne prirode matrice (iako je izvedivo, samo moramo voditi računa da logički indeksni vektori duljinom odgovaraju pripadajućoj dimenziji). Jedna od stvari na koju moramo voditi računa jest tendencija jezika R da nam “pomaže” pojednostavljujući rezultat. Tako će rezultat operacije rezanja matrice koja ostavlja samo jedan redak ili stupac automatski postati vektor, tj. izgubiti će atribut dimenzije. Ovo nam nekad ne odgovara, pogotovo ako radimo programske skripte koje u daljnjoj proceduri očekuju matricu, pa makar ona imala dimenziju redaka ili stupaca 1. U tom slučaju kod referenciranja moramo postaviti i dodatni parametar drop = F. Ovo često izgleda dosta nezgrapno, zbog čega danas postoje mnogi paketi proširenja jezika R koji ovo “popravljaju”, tj. koji se trude rezultat ostavljati u konzistentnom obliku. No parametar drop postavljen na FALSE treba imati u vidu, budući da će se pojavljivati i na drugim mjestima u sličnoj funkciji. Zadatak 3.17 - rezanje matrica m &lt;- matrix(1:30, 6, 5, T) colnames(m) &lt;- c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;) # ispišite sve elemente matrice m od drugog do četvrtog retka # te od trećeg do petog stupca # sve elemente u stupcu naziva &quot;c&quot; postavite na nulu # a potom ispišite prva dva retka matrice `m` # ispišite samo stupac &quot;d&quot; # ispišite opet stupac &quot;d&quot;, ali kod referenciranja dodajte parametar `drop = FALSE` # parametar odvojite zarezom (kao da se radi o &quot;trećoj&quot; dimenziji referenciranja) m &lt;- matrix(1:30, 6, 5, T) colnames(m) &lt;- c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;) # ispišite sve elemente matrice `m` od drugog do četvrtog retka # te od trećeg do petog stupca m[2:4, 3:5] # sve elemente u stupcu naziva &quot;c&quot; postavite na nulu # a potom ispišite prva dva retka matrice `m` m[, &quot;c&quot;] &lt;- 0 m[1:2,] # ispišite samo stupac &quot;d&quot; m[, &quot;d&quot;] # ispišite opet stupac &quot;d&quot;, ali kod referenciranja dodajte parametar `drop = FALSE` # parametar odvojite zarezom (kao da se radi o &quot;trećoj&quot; dimenziji referenciranja) m[, &quot;d&quot;, drop = F] ## c d e ## [1,] 8 9 10 ## [2,] 13 14 15 ## [3,] 18 19 20 ## a b c d e ## [1,] 1 2 0 4 5 ## [2,] 6 7 0 9 10 ## [1] 4 9 14 19 24 29 ## d ## [1,] 4 ## [2,] 9 ## [3,] 14 ## [4,] 19 ## [5,] 24 ## [6,] 29 Ovdje ćemo završiti priču o matricama. Ove strukture su vrlo korisne kod rješavanja matematičkih zadataka zasnovanih na matricama, pri čemu je često zgodno pogledati dokumentaciju jezika R kako bi vidjeli koje funkcije i operatori su nam dostupni za takav posao. Isto tako, neki prikazani principi upravljanja matricama biti će korisni kod upravljanja tzv. podatkovnim okvirima - vjerojatno najpopularnijem tipu objekta jezika R kojeg ćemo upoznati u jednom od nastupajućih poglavlja. Konačno, iako se nećemo detaljno baviti poljima, prikažimo radi potpunosti primjer programskog koda koji stvara trodimenzionalno polje te potom ispisuje jedan njegov dio standardnim principom rezanja kojeg smo upoznali kod vektora i matrica. polje &lt;- array(1:24, dim = c(2, 3, 4)) # polje dimenzija 2 x 3 x 4 polje[, 1:2, 3, drop = FALSE] # ispis svih redaka, prvog i drugog stupca # trećeg &quot;sloja&quot;, uz zadržavanje tipa polja 3.4 Liste Lista je element programskog jezika R koji se koristi kao “univerzalni spremnik” bilo kakvih podataka. Za razliku od vektora (tj. od pojma vektora kakvog smo ga inicijalno definirali), lista može sadržavati različite tipove podataka ili - češće - skupove različitih tipova podataka. Listu stvaramo uz pomoć funkcije list kojom dodajemo niz parova naziva elemenata i njihovih sadržaja. Ovi elementi mogu biti bilo što, pa čak i druge liste. mojaLista &lt;- list(a = 1, b = 2:100, c = list(x = 1, y = 2)) Probajmo stvoriti vlastitu listu u sljedećem primjeru. Zadatak 3.18 - stvaranje liste # stvorite novu listu naziva `svastara` koja će imati sljedeće elemente # element naziva `brojevi` sa cijelim brojevima od 1 do 3 # element naziva `slova` sa slovima &quot;A&quot; i &quot;B&quot; # bezimeni element sa logičkim vektorom `c(T,F)` # element naziva `imena` sa imenima &quot;Ivo&quot; i &quot;Ana&quot; # ispišite listu `svastara` svastara &lt;- list(brojevi = c(1,2,3), slova = c(&quot;A&quot;, &quot;B&quot;), c(T,F), imena = c(&quot;Ivo&quot;, &quot;Ana&quot;)) # ispišite listu `svastara` svastara ## $brojevi ## [1] 1 2 3 ## ## $slova ## [1] &quot;A&quot; &quot;B&quot; ## ## [[3]] ## [1] TRUE FALSE ## ## $imena ## [1] &quot;Ivo&quot; &quot;Ana&quot; Uočite da lista zadržava poredak elemenata - element bez imena prikazan je indeksom 3. Funkcija str (engl. structure) omogućuje nam uvid u svojstva i sadržaj liste bez ispisivanja cijele liste. Ovu funkciju analitičari često koriste, kako za pregled lista tako i za brzi uvid u već spomenute podatkovne okvire koje ćemo raditi u idućem poglavlju. Zadatak 3.19 - struktura liste # ispišite strukturu liste `svastara` # ispišite strukturu liste `svastara` str(svastara) ## List of 4 ## $ brojevi: num [1:3] 1 2 3 ## $ slova : chr [1:2] &quot;A&quot; &quot;B&quot; ## $ : logi [1:2] TRUE FALSE ## $ imena : chr [1:2] &quot;Ivo&quot; &quot;Ana&quot; Na početku ove lekcije smo rekli da u R-u vrijedi princip “sve je vektor” te da su vektori zapravo uređeni skupovi elemenata istog tipa. Iz ovog bi se moglo zaključiti da ta činjenica ne vrijedi za liste - oni očito sadržavaju elemente različitih tipova. No pravi odgovor je - i liste su zapravo vektori, a definicija zapravo nije narušena. Naime, svi elementi liste su zapravo male jednoelementne liste, tako da su formalno svi elementi istog tipa. Zadatak 3.20 - tip elemenata liste # ispišite prvi element liste svastara # provjerite njegov tip # ispišite prvi element liste svastara svastara[1] # provjerite njegov tip typeof(svastara[1]) ## $brojevi ## [1] 1 2 3 ## ## [1] &quot;list&quot; Dakle, dokazali smo da su elementi liste zapravo male liste, što se vidi iz ispisa samog elementa, kao i provjere njezinog tipa. Možda nam se čini da bi elementi gore stvorene liste trebali biti vektori, budući da smo listu i stvorili “slaganjem” različitih vektora, no u postupku stvaranja objekta R je “umotao” elemente u jednoelementne liste prije nego ih je uklopio u “veliku” listu. Često ne želimo raditi s elementom liste kao “malom listom”, nego ga trebao u njegovom “originalnom” obliku. Za ovo koristimo operator [[, tj. operator “dvostruke uglate zagrade”. Zadatak 3.21 - operator [[ # ispišite prvi element liste svastara korištenjem operatora `[[` # provjerite njegov tip # ispišite prvi element liste svastara svastara[[1]] # provjerite njegov tip typeof(svastara[[1]]) ## [1] 1 2 3 ## [1] &quot;double&quot; Navedeni operator najčešće koristimo kako bi dohvatili odabrani element liste kojeg definiramo brojem ili (ako ima ime) nazivom elementa. Kod ovakvog dohvata moramo koristiti kombinaciju simbola lista[[\"ime_elementa\"]] koja je ponešto nespretna za tipkanja. Zbog toga R nudi alternativni način pristupa elementima liste prema nazivu korištenjem operatora $, tj. lista$ime_elementa. Zadatak 3.22 - operator $ # ispišite element naziva &quot;slova&quot; liste svastara # korištenjem operatora `[[` # ispišite isti element korištenjem operatora `$` # ispišite element naziva &quot;slova&quot; liste svastara # korištenjem operatora `[[` svastara[[&quot;slova&quot;]] # ispišite isti element korištenjem operatora `$` svastara$slova ## [1] &quot;A&quot; &quot;B&quot; ## [1] &quot;A&quot; &quot;B&quot; Liste su iznimno popularni tip objekta u R-u budući da predstavljaju univerzalni predložak za kompleksnije podatkovne strukture, između ostalog i kompleksnije objekte u užem smislu (kao što ćemo vidjeti kasnije). Lista je također “temelj” za daleko najpopularniji i najčešće korišteni element jezika R - podatkovni okvir - kojeg ćemo upoznati u idućoj lekciji. Za kraj naučimo dodati element u listu. Ovo je najjednostavnije učiniti korištenjem već spomenutog operatora $ - kao npr. lista$noviElement &lt;- noviElement. Element brišemo tako da mu dodijelimo vrijednost NULL. Zadatak 3.23 - dodavanje elementa u listu # listi `svastara` dodajte element `parniBrojevi` koji sadrži # sve parne brojeve od 1 do 100 # obrišite treći element liste # ispišite listu `svastara` # listi `svastara` dodajte element `parniBrojevi` koji sadrži # sve parne brojeve od 1 do 100 svastara$parniBrojevi &lt;- seq(2, 100, 2) # obrišite treći element liste svastara[[3]] &lt;- NULL # ispišite listu `svastara` print(svastara) ## $brojevi ## [1] 1 2 3 ## ## $slova ## [1] &quot;A&quot; &quot;B&quot; ## ## $imena ## [1] &quot;Ivo&quot; &quot;Ana&quot; ## ## $parniBrojevi ## [1] 2 4 6 8 10 12 14 16 18 20 22 24 26 28 30 32 34 36 38 ## [20] 40 42 44 46 48 50 52 54 56 58 60 62 64 66 68 70 72 74 76 ## [39] 78 80 82 84 86 88 90 92 94 96 98 100 U sljedećoj lekciji konačno ćemo upoznati već više puta spominjane podatkovne okvire kao daleko najpopularniji i najčešće korištenu podatkovnu strukturu jezika R. Zadaci za vježbu Stvorite i ispišite na zaslon sljedeće vektore: (11, 12, 13,…, 99) (0, 0, 0, 0, … , 0) (100 nula) (0, 0.1, 0.2, …., 1.0) Kolika je suma svih brojeva od 101 do 1001, ako preskočimo sve brojeve djeljive sa 10? Koristite se funkcijom sum. Stvorite matricu 3 x 3 sa brojevima izvođenjem sljedećih naredbi (funkciju sample ćemo pobliže upoznati u jednoj od sljedećih lekcija): # stvaramo matricu 3x3 nasumično odabranih elemenata iz skupa od 1 do 100 set.seed(1234) m &lt;- matrix(c(sample(1:100, 9, T)), nrow = 3, ncol = 3, byrow = T) Izračunajte inverznu matricu uz pomoć funkcije solve. Provjerite da li umnožak originalne i inverzne matrice daje jediničnu matricu (za množenje matrica koristite se operatorom %*%). Inicijalizirajte ponovo listu svastara korištenu u lekciji. Napravite sljedeće: ispišite klasu drugog elementa liste ispišite element na trećem mjestu elementa liste naziva slova provjerite duljinu elementa naziva imena te na zadnje mjesto dodajte ime \"Pero\" provjerite da li se broj 4 nalazi u prvom elementu liste na zadnje mjesto liste dodajte novu listu sa tri vektora a, b i c koji svi sadrže elemente (1,2,3) Programirajmo u R-u by Damir Pintar is licensed under a Creative Commons Attribution-NonCommercial-NoDerivatives 4.0 International License.Based on a work at https://ratnip.github.io/FER_OPJR/ "],["okviri.html", "4 Podatkovni okviri i faktori 4.1 Podatkovni okviri 4.2 Odabir redaka i stupaca podatkovnih okvira 4.3 Dodavanje i brisanje redaka i stupaca 4.4 Faktori Zadaci za vježbu", " 4 Podatkovni okviri i faktori 4.1 Podatkovni okviri Kao što je već rečeno, podatkovni okvir je daleko najpopularniji element programskog jezika R. Jezik R predviđen je primarno analizi podataka, a podatkovni okvir zapravo predstavlja objektnu reprezentaciju podatkovnog skupa kojeg namjeravamo analizirati. Drugim riječima, podatkovni okvir je objekt slične funkcije kao tablica u Microsoft Excel-u ili relacijskoj bazi podataka. Gotovo svaka “sesija” u R-u svodi se na manipuliranje podatkovnim okvirima - no dok u Excel-u tablicom upravljamo uz pomoć grafičkog sučelja, a u bazi uz pomoć upitnog jezika SQL, u R-u podatkovnim okvirima upravljamo gotovo isključivo programski. Uzmimo za primjer sljedeću tablicu: pbr nazivMjesta prosjPlacaKn brojStanovnika prirez 10000 Zagreb 6359.00 790017 18 51000 Rijeka 5418.00 128384 15 21000 Split 5170.00 167121 10 31000 Osijek 4892.00 84104 13 20000 Dubrovnik 5348.00 28434 10 Ovdje se radi o podatkovnom skupu koji sadržava određene parametre vezane uz gradove u Republici Hrvatskoj (navedene vrijednosti ne odgovaraju nužno trenutnom stanju već ih koristimo samo za demonstraciju). Lako možemo zamisliti kako ove podatke zapisujemo u Excel ili stvaramo relacijsku tablicu naziva npr. MJESTO u koju onda pohranjujemo navedene podatke. Pokažimo sada kako bi sa istim podacima manipulirati u sklopu jezika R, tj. pokušajmo stvoriti podatkovni okvir koji će sadržavati ove podatke. U prošloj lekciji smo napomenuli da je lista kao složeni tip zapravo svojevrsni “predložak” uz pomoć kojeg možemo raditi nove objekte. Podatkovni okvir tako zapravo nije ništa drugo nego lista – tj. “spremnik” koji može sadržavati u sebi druge spremnike podataka različitog tipa. No dok je “lista“ zapravo univerzalni spremnik, tj. nemamo ograničenja što”trpamo” u nju, podatkovni okvir ima određene restrikcije. Najvažnije ograničenje koje podatkovni okvir nameće jest da svaki element unutar podatkovnog okvira mora imati isti broj elemenata. Zašto je tome tako? Zamislimo listu u kojoj svaki element ima isti broj podelemenata. Ako svaki element skiciramo vertikalno, sa podelementima napisanim jedan ispod drugog, onda će ti podelementi biti “poravnati” po retcima čime smo postigli klasičnu organizaciju podataka u stupce (elemente liste) i retke (poravnati podelementi). Dakle, ova restrikcija zapravo direktno nameće “tabličnu” ili “matričnu” strukturu liste sa jasno definiranim retcima i stupcima, što nam zapravo omogućuje da podatkovnim okvirom upravljamo i uz pomoć metoda vezanih uz liste, ali i uz pomoć metoda primarno namijenjenih matricama. Postoji više načina stvaranja podatkovnih okvira, a mi ćemo prikazati dva u praksi najčešće susretana scenarija: programsko stvaranje uz pomoć funkcije data.frame učitavanje podataka iz vanjskog izvora uz pomoć funkcije read.csv Prikažimo oba slučaja. Prvo ćemo stvoriti podatkovni okvir programski. Zadatak 4.1 - programsko stvaranje podatkovnog okvira mjesto &lt;- data.frame(pbr = c(10000, 51000, 21000, 31000, 2000), nazivMjesta = c(&quot;Zagreb&quot;, &quot;Rijeka&quot;, &quot;Split&quot;, &quot;Osijek&quot;, &quot;Dubrovnik&quot;), prosjPlacaKn = c(6359., 5418., 5170., 4892., 5348.), brojStanovnika = c(790017, 128384, 167121, 84104, 28434), prirez = c(18, 15, 10, 13, 10)) # ispišite podatkovni okvir `mjesto` mjesto &lt;- data.frame(pbr = c(10000, 51000, 21000, 31000, 2000), nazivMjesta = c(&quot;Zagreb&quot;, &quot;Rijeka&quot;, &quot;Split&quot;, &quot;Osijek&quot;, &quot;Dubrovnik&quot;), prosjPlacaKn = c(6359., 5418., 5170., 4892., 5348.), brojStanovnika = c(790017, 128384, 167121, 84104, 28434), prirez = c(18, 15, 10, 13, 10)) # ispišite podatkovni okvir `mjesto` mjesto ## pbr nazivMjesta prosjPlacaKn brojStanovnika prirez ## 1 10000 Zagreb 6359 790017 18 ## 2 51000 Rijeka 5418 128384 15 ## 3 21000 Split 5170 167121 10 ## 4 31000 Osijek 4892 84104 13 ## 5 2000 Dubrovnik 5348 28434 10 Ukoliko želite, pokušajte ponovo stvoriti gornji podatkovni okvir ali uz različite brojeve elemenata vektora koji čine stupce. Ova operacija rezultirati će greškom uz prikladnu poruku a podatkovni okvir neće biti stvoren - R se trudi da matrična priroda okvira uvijek bude očuvana. Mala napomena glede terminologije: u nastavku ćemo zbog jednostavnosti “podatkovni okvir” često zvati jednostavno “okvir” ili “tablica”. Isto tako, često ćemo za elemente podatkovnog okvira jednakopravno koristiti izraze “stupac”, “varijabla” ili “atribut”, dok ćemo paralelne podelemente elemenata okvira nazivati “retcima” ili “obzervacijama”. Ovi termini u skladu su sa standardnim načinom referenciranja elemenata tablice te statističkim terminima koji se odnose na tablične podatkovne skupove. Ukoliko iz konteksta postoji šansa za dvosmislenost, koristiti će se onaj termin koji jasno opisuje element koji se referencira. Pokušajmo sada učitati tablicu iz vanjskog izvora. Iako R dopušta različite oblike “vanjskih” podataka, mi ćemo pretpostaviti da podatke dobivamo u tzv. “CSV obliku” (engl. CSV - comma-separated values). Ovaj oblik jedan je od najpopularnijih načina pohrane podataka u čistom tekstualnom obliku koji ima prednosti da se lako izrađuje ručno, a većina alata za upravljanje podacima implementira i logiku za izvoz podataka u obliku CSV datoteke. U nastavku možemo vidjeti primjer CSV datoteke koja odgovara podatkovnom okviru izrađenom u prethodnom primjeru. Pretpostavimo da se datoteka zove mjesto.csv. Podaci su odvojeni zarezom (bez razmaknice!), svaka obzervacija u svojem retku, a opcionalni prvi redak predstavlja nazive stupaca. pbr,nazivMjesta,prosjPlacaKn,brojStanovnika,prirez 10000,Zagreb,6359.00,790017,18 51000,Rijeka,5418.00,128384,15 21000,Split,5170.00,167121,10 31000,Osijek,4892.00,84104,13 20000,Dubrovnik,5348.00,28434,10 Jedan od potencijalnih problema sa CSV datotekama jest taj što one koriste zarez kao razdvojnik (delimiter) elemenata zapisa, a na određenim govornim područjima kao standard se umjesto decimalne točke koristi upravo “decimalni zarez”. Zbog ove činjenice postoji i “alternativni” CSV standard koji kao razdvojnik koristi “točku-zarez”, tako da bi naša CSV datoteka u tom slučaju izgledala ovako (nazovimo ju mjestoAlt.csv): pbr;nazivMjesta;prosjPlacaKn;brojStanovnika;prirez 10000;Zagreb;6359,00;790017;18 51000;Rijeka;5418,00;128384;15 21000;Split;5170,00;167121;10 31000;Osijek;4892,00;84104;13 20000;Dubrovnik;5348,00;28434;10 Obzirom da je “decimalni zarez” propisani standard i na području Republike Hrvatske, u radu sa CSV datotekama moramo biti oprezni koji od dva standarda zapisa se koristi. Na sreću, jezik R nudi funkcije za podršku oba standarda, tako da ne moramo posebno prilagođavati ulazne datoteke, tek biti oprezni koju funkciju ćemo odabrati. Pretpostavimo da u radnoj mapi imamo ove dvije datoteke: mjesto.csv mjestoAlt.csv Ukoliko nemamo dostupne ove datoteke lako ih možemo samostalno napraviti uz pomoć običnog uređivača teksta (npr. Notepad ili gedit) i kopiranja gore navedenih redaka. Za stvaranje podatkovnih okvira iz CSV datoteka R nudi sljedeće funkcije: - read.csv - za “normalne” CSV datoteke sa zarezom kao razdvojnikom - read.csv2 - za alternativni CSV standard koji koristi točku-zarez Osnovni parametar ovih funkcija je staza do CSV datoteke koju učitavamo. Funkcije imaju i bogati niz dodatnih parametara koje omogućuju prilagodbu raznim scenarijima, a ukoliko smo dobili neki od “egzotičnijih” oblika CSV datoteke, isplati se pogledati i funkciju read.table koja je vrlo fleksibilna glede broja različitih parametara i postavki kod učitavanja podataka (read.csv i read.csv2 su zapravo izvedene iz funkcije read.table fiksiranjem određenih parametara na standardne CSV značajke). Iako ćemo “naprednije” funkcije iz kolekcije tidyverse učiti u jednoj od narednih lekcija, u ovom trenutku nije loše odmah predstaviti alternative prikazanim funkcijama iz paketa readr. Funkcije za čitanje iz tabularnih datoteka vrlo su slične funkcionalnosti osnovnim funkcijama, a po nazivu se uglavnom razlikuju u tome što koriste simbol “podcrte” _ umjesto “točke” ., pa za CSV datoteke imamo: read_csv - za “normalne” CSV datoteke sa zarezom kao razdvojnikom read_csv2 - za alternativni CSV standard koji koristi točku-zarez Postoji niz razloga zašto su ove funkcije preferirane, no ovu raspravu ćemo odgoditi za kasnije, dok ćemo se sada usredotočiti na način njihovog korištenja. Neke od parametara i pripadajućih vrijednosti funkcija read.csv (ili read.table) koje je korisno znati su: col_names = FALSE - za datoteke bez zaglavlja col_types = \"ccnlf\" - za eksplicitnu definiciju tipova; prikazana je skraćena sintaksa za primjer od pet stupaca koja označava character-character-numeric-logical-factor delim = \"#\" - za datoteke koje koriste “egzotični” razdvojnik, u ovom slučaju # na = \"NULL\" - naznaka koji standard podaci koriste za reprezentaciju nedostajućih vrijednosti a koji će u R-u postati NA n_max = 2000 - maksimalan broj redaka koji će se pročitati, u ovom slučaju 2000 Ostale parametre možemo lako pronaći traženjem pomoći za odabranu naredbu. Pokušajmo sada učitati podatke iz dostupnih CSV datoteka. Ovi podaci neće zahtijevati posebne parametre te će se moći učitati samo pružanjem staze do pripadnih datoteka (jedne koja koristi zarez i druge koja koristi točku-zarez kao razdvojnik). Zadatak 4.2 - čitanje podataka iz CSV datoteke # učitajte podatke iz datoteka `mjesto.csv` i `mjestoAlt.csv` # podatke spremite u okvire `mjesto2` i `mjesto3` # ispišite okvire `mjesto2` i `mjesto3` # učitajte podatke iz datoteka `mjesto.csv` i `mjestoAlt.csv` # podatke spremite u okvire `mjesto2` i `mjesto3` # library(readr) mjesto2 &lt;- read_csv(&quot;mjesto.csv&quot;) mjesto3 &lt;- read_csv2(&quot;mjestoAlt.csv&quot;) # ispišite okvire `mjesto2` i `mjesto3` mjesto2 cat(&quot;-----------\\n&quot;) mjesto3 ## Rows: 5 Columns: 5 ## ── Column specification ─────────────────────────────────────────── ## Delimiter: &quot;,&quot; ## chr (1): nazivMjesta ## dbl (4): pbr, prosjPlacaKn, brojStanovnika, prirez ## ## ℹ Use `spec()` to retrieve the full column specification for this data. ## ℹ Specify the column types or set `show_col_types = FALSE` to quiet this message. ## ℹ Using &quot;&#39;,&#39;&quot; as decimal and &quot;&#39;.&#39;&quot; as grouping mark. Use `read_delim()` for more control. ## ## Rows: 5 Columns: 5 ## ── Column specification ─────────────────────────────────────────── ## Delimiter: &quot;;&quot; ## chr (1): nazivMjesta ## dbl (4): pbr, prosjPlacaKn, brojStanovnika, prirez ## ## ℹ Use `spec()` to retrieve the full column specification for this data. ## ℹ Specify the column types or set `show_col_types = FALSE` to quiet this message. ## # A tibble: 5 × 5 ## pbr nazivMjesta prosjPlacaKn brojStanovnika prirez ## &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 10000 Zagreb 6359 790017 18 ## 2 51000 Rijeka 5418 128384 15 ## 3 21000 Split 5170 167121 10 ## 4 31000 Osijek 4892 84104 13 ## 5 20000 Dubrovnik 5348 28434 10 ## ----------- ## # A tibble: 5 × 5 ## pbr nazivMjesta prosjPlacaKn brojStanovnika prirez ## &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 10000 Zagreb 6359 790017 18 ## 2 51000 Rijeka 5418 128384 15 ## 3 21000 Split 5170 167121 10 ## 4 31000 Osijek 4892 84104 13 ## 5 20000 Dubrovnik 5348 28434 10 Uočimo da nam ove funkcije daju neke korisne informacije vezane uz pročitane datoteke. Ukoliko ove poruke ne želimo vidjeti, možemo funkciju omotati u poziv funkcije suppressMessages (u slučaju RMD datoteka možemo i u parametre kodnog odsječka staviti message = FALSE). Pogledajmo sada neke korisne funkcije za rad sa podatkovnim okvirima tj. tablicama. Dobar dio njih će nam već otprije biti poznat iz iskustva u radu sa listama i matricama: nrow - broj redaka ncol ili length - broj stupaca (budući da se okvir ponaša i kao matrica i kao lista) dim - dimenzije tablice names - imena stupaca head - ispis nekoliko redaka s početka tablice tail - ispis nekoliko redaka s kraja tablice str - ispis strukture tablice summary - sažete statističke informacije o stupcima tablice Isprobajmo neke od ovih funkcija: Zadatak 4.3 - funkcije za rad sa podatkovnim okvirima # ispišite dimenzije tablice `mjesto` # ispišite strukturu tablice `mjesto` # ispišite prvih nekoliko redaka tablice `mjesto` # ispišite sažete statističke informacije o stupcima tablice `mjesto` # ispišite dimenzije tablice `mjesto` dim(mjesto) cat(&quot;-----------\\n&quot;) # ispišite strukturu tablice `mjesto` str(mjesto) cat(&quot;-----------\\n&quot;) # ispišite prvih nekoliko redaka tablice `mjesto` head(mjesto) cat(&quot;-----------\\n&quot;) # ispišite sažete statističke informacije o stupcima tablice `mjesto` summary(mjesto) ## [1] 5 5 ## ----------- ## &#39;data.frame&#39;: 5 obs. of 5 variables: ## $ pbr : num 10000 51000 21000 31000 2000 ## $ nazivMjesta : chr &quot;Zagreb&quot; &quot;Rijeka&quot; &quot;Split&quot; &quot;Osijek&quot; ... ## $ prosjPlacaKn : num 6359 5418 5170 4892 5348 ## $ brojStanovnika: num 790017 128384 167121 84104 28434 ## $ prirez : num 18 15 10 13 10 ## ----------- ## pbr nazivMjesta prosjPlacaKn brojStanovnika prirez ## 1 10000 Zagreb 6359 790017 18 ## 2 51000 Rijeka 5418 128384 15 ## 3 21000 Split 5170 167121 10 ## 4 31000 Osijek 4892 84104 13 ## 5 2000 Dubrovnik 5348 28434 10 ## ----------- ## pbr nazivMjesta prosjPlacaKn brojStanovnika ## Min. : 2000 Length:5 Min. :4892 Min. : 28434 ## 1st Qu.:10000 Class :character 1st Qu.:5170 1st Qu.: 84104 ## Median :21000 Mode :character Median :5348 Median :128384 ## Mean :23000 Mean :5437 Mean :239612 ## 3rd Qu.:31000 3rd Qu.:5418 3rd Qu.:167121 ## Max. :51000 Max. :6359 Max. :790017 ## prirez ## Min. :10.0 ## 1st Qu.:10.0 ## Median :13.0 ## Mean :13.2 ## 3rd Qu.:15.0 ## Max. :18.0 4.2 Odabir redaka i stupaca podatkovnih okvira Već smo rekli da se podatkovni okviri ponašaju i kao matrice i kao liste, što je svojstvo kojim se posebno često služimo kod odabira redaka i stupaca podatkovnih okvira. Konkretno, za “rezanje” okvira najčešće koristimo: dvodimenzionalno referenciranje uz pomoć indeksnih vektora odabir pojedinog stupca uz pomoć operatora $ Ovdje smo zapravo dosta fleksibilni - možemo npr. prvo “izrezati” određene retke matrice uz pomoć lokacijskog referenciranja i potom izdvojiti samo jedan stupac uz pomoć operatora $. U praksi je jedna od najčešćih kombinacija uvjetni odabir redaka uz imenski odabir stupaca (poznavatelji SQL-a prepoznati će ovo kao standardnu kombinaciju WHERE uvjeta i SELECT liste). Pokušajmo primijeniti naše znanje o indeksnim vektorima, matricama i listama na rezanje podatkovnih okvira. Zadatak 4.4 - rezanje podatkovnih okvira # ispišite tablicu `mjesto` (za referencu) # ispišite prva tri retka, treći i peti stupac # ispišite stupac &quot;prirez&quot; # ispišite poštanske brojeve i nazive svih mjesta koja # imaju prirez veći od 12% i broj stanovnika veći od 100,000 #ispišite tablicu `mjesto` (za referencu) mjesto cat(&quot;-----------\\n&quot;) #ispišite prva tri retka, treći i peti stupac mjesto[1:3, c(3,5)] cat(&quot;-----------\\n&quot;) #ispišite stupac &quot;prirez&quot; mjesto$prirez cat(&quot;-----------\\n&quot;) #ispišite poštanske brojeve i nazive svih mjesta koji imaju # prirez veći od 12% i broj stanovnika veći od 100,000 mjesto[mjesto$prirez &gt; 12 &amp; mjesto$brojStanovnika &gt; 100000, c(&quot;pbr&quot;, &quot;nazivMjesta&quot;)] ## pbr nazivMjesta prosjPlacaKn brojStanovnika prirez ## 1 10000 Zagreb 6359 790017 18 ## 2 51000 Rijeka 5418 128384 15 ## 3 21000 Split 5170 167121 10 ## 4 31000 Osijek 4892 84104 13 ## 5 2000 Dubrovnik 5348 28434 10 ## ----------- ## prosjPlacaKn prirez ## 1 6359 18 ## 2 5418 15 ## 3 5170 10 ## ----------- ## [1] 18 15 10 13 10 ## ----------- ## pbr nazivMjesta ## 1 10000 Zagreb ## 2 51000 Rijeka Uočite sličnost između zadnjeg izraza i SQL upita: ` SELECT pbr, nazivMjesta FROM mjesto WHERE mjesto.prirez &gt; 12 AND mjesto.brojStanovnika &gt; 100000 Odabir stupaca i redaka nije težak ako dobro baratamo znanjem o indeksnim vektorima, no kao što se vidi u zadnjem primjeru sintaksa često nije previše čitljiva (u usporedbi sa npr. SQL-ovom sintaksom koja obavlja isti posao). Zbog toga postoje različita proširenja R-a koji ovaj posao uvelike olakšavaju, a koja ćemo detaljno obraditi u jednoj od budućih lekcija koja će se baviti upravljanjem podatkovnim skupovima. 4.3 Dodavanje i brisanje redaka i stupaca Za dodavanje i brisanje redaka i stupaca opet se dovoljno sjetiti da je podatkovni okvir svojevrsni hibrid matrice i liste tj. ako znamo dodavati retke i stupce u matricu ili nove elemente u listu onda ekvivalentnim načinom možemo podatke dodavati i u podatkovni okvir. U radu sa podatkovnim okvirima nešto češće dodajemo nove stupce (obično kao transformacije postojećih stupaca) nego retke tako da možemo primjere započeti sa dodavanjem stupaca. Kao što je rečeno, stupce u podatkovni okvir dodajemo na isti način kao što dodajemo elemente liste - uz pažnju da dodani stupac ima isti broj elemenata kao i ostali stupci. Novi stupci često su izvedenice postojećih stupaca koje predstavljaju binarne indikatore, rezultate aritmetičkih izraza podataka u drugim stupcima i sl. Zadatak 4.5 - dodavanje novih stupaca u tablicu # tablici `mjesto` dodajte logički stupac `visokPrirez` # koji će pokazivati da li je prirez veći od 12% # pretpostavimo sljedeći (fiktivni!) način izračuna prireza # - mjesta imaju oko 60% radne populacije # - svaki radnik plaća porez koji je otprilike jednak 10% neto plaće # - prirez kojeg radnik plaća računamo kao (stopa prireza)*(iznos poreza) # # dodajte stupac `mjesecniPrihod` koji će uz pomoć prosječne plaće, prireza # i broja stanovnika procijeniti koliki prihod pojedino mjesto dobija od prireza # (izraženo u milijunima Kn) # iznos zaokružite uz pomoć funkcije round ( primjer: round(100.12345, 2) ==&gt; 100.12 ) # ispišite tablicu mjesto # tablici `mjesto` dodajte logički stupac `visokPrirez` # koji će pokazivati da li je prirez veći od 12% mjesto$visokPrirez &lt;- mjesto$prirez &gt; 12 # pretpostavimo sljedeći (fiktivni!) način izračuna prireza # - mjesta imaju oko 60% radne populacije # - svaki radnik plaća porez koji je otprilike jednak 10% neto plaće # - prirez kojeg radnik plaća računati ćemo (stopa prireza)*(iznos poreza) # # dodajte stupac `mjesecniPrihod` koji će uz pomoć prosječne plaće, prireza # i broja stanovnika procijeniti koliki prihod pojedino mjesto dobija od prireza # (izraženo u milijunima Kn) # iznos zaokružite uz pomoć funkcije round ( primjer: round(100.12345, 2) ==&gt; 100.12 ) mjesto$mjesecniPrihod &lt;- round(0.6 * mjesto$brojStanovnika * 0.1 * mjesto$prosjPlacaKn * 0.01 * mjesto$prirez / 1e6 , 2) # ispišite tablicu mjesto mjesto ## pbr nazivMjesta prosjPlacaKn brojStanovnika prirez visokPrirez ## 1 10000 Zagreb 6359 790017 18 TRUE ## 2 51000 Rijeka 5418 128384 15 TRUE ## 3 21000 Split 5170 167121 10 FALSE ## 4 31000 Osijek 4892 84104 13 TRUE ## 5 2000 Dubrovnik 5348 28434 10 FALSE ## mjesecniPrihod ## 1 54.26 ## 2 6.26 ## 3 5.18 ## 4 3.21 ## 5 0.91 Retke i stupce smo također mogli dodati slično dodavanju redaka i stupaca u matricu - uz pomoć funkcija rbind i cbind. Kod funkcije rbind obično dodajemo novi podatkovni okvir sa retcima koji imaju odgovarajući redoslijed i vrstu elemenata, dok kod funkcije cbind možemo dodati i obični vektor no moramo paziti da broj elemenata odgovara broju redaka originalnog okvira. Isprobajmo ove funkcije na malim “umjetnim” podatkovnim okvirima kako bi lakše predočili njihovu funkcionalnost. Zadatak 4.6 - funkcije rbind/cbind i podatkovni okviri df1 &lt;- data.frame(a = c(1,2,3), b = c(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;), c = c(T, F, T)) df2 &lt;- data.frame(a = 1, b = &quot;A&quot;, c = 3) #spojite df1 i df2 u podatkovni okvir df12 uz pomoć funkcije `rbind` # okviru df12 dodajte stupac `imena` sa imenima Ivo, Ana, Pero i Stipe # koristite funkciju `cbind` # ispišite okvir df12 df1 &lt;- data.frame(a = c(1,2,3), b = c(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;), c = c(T, F, T)) df2 &lt;- data.frame(a = 1, b = &quot;A&quot;, c = 3) #spojite df1 i df2 u podatkovni okvir df12 uz pomoć funkcije `rbind` df12 &lt;- rbind(df1, df2) # okviru df12 dodajte stupac `imena` sa imenima Ivo, Ana, Pero i Stipe # koristite funkciju `cbind` df12 &lt;- cbind(df12, imena = c(&quot;Ivo&quot;, &quot;Ana&quot;, &quot;Pero&quot;, &quot;Stipe&quot;)) # ispišite okvir df12 df12 ## a b c imena ## 1 1 A 1 Ivo ## 2 2 B 0 Ana ## 3 3 C 1 Pero ## 4 1 A 3 Stipe Za brisanje redaka i stupaca također se možemo koristiti istim metodama za upravljanje matricama i listama. Konkretno: brisanje redaka i stupaca možemo obaviti dvodimenzionalnim referenciranjem redaka i stupaca koje želimo “zadržati” brisanje stupaca možemo obaviti pridjeljivanjem vrijednosti NULL odabranom stupcu Isprobajmo ovo na primjeru. Zadatak 4.7 - brisanje redaka i stupaca # obrišite prvi redak i drugi stupac iz df12 metodom 2d referenciranja # obrišite stupac `imena` uz pomoć pridjeljivanja `NULL` vrijednosti # ispišite df12 # obrišite prvi redak i drugi stupac iz df12 metodom 2d referenciranja df12 &lt;- df12[-1, -2] # obrišite stupac `imena` uz pomoć pridjeljivanja `NULL` vrijednosti df12$imena &lt;- NULL # ispišite df12 df12 ## a c ## 2 2 0 ## 3 3 1 ## 4 1 3 Podatkovnim okvirima ćemo se nastaviti baviti u poglavlju o upravljanju podatkovnim skupovima, gdje ćemo naučiti kako raditi sa okvirima sa daleko više podataka od primjera koje smo koristili u ovoj lekciji, te kako raditi sa dodatnim paketima koji značajno olakšavaju česte radnje nad podacima u podatkovnim okvirima. U nastavku ćemo se pozabaviti još jednim novim (i ponešto kontroverznim) tipom podatkovne strukture. 4.4 Faktori Faktor u R-u je zapravo tip podataka koji predstavlja ono onoga što se u statistici naziva nominalnom ili kategorijskom varijablom. Naime, atribut neke obzervacije često poprima neku vrijednost iz skupa otprije poznatih kategorija (npr. varijabla spola, dobne kategorije, obrazovanja, mjesta rođenja, stranačke preferencije i sl.). Kategorije se često identificiraju jedinstvenim nizom znakova, a u procesu analize uz pomoć njih često provodimo razna agregiranja i grupacije (npr. u nekoj utrci možemo gledati prosječno vrijeme ovisno o spolu ili dobnoj kategoriji) ili pak dijelimo skup podataka ovisno o kategorijskoj pripadnosti. Faktori u R-u su često i predmet rasprava budući da se radi o konstruktu koji može olakšati rad nad podacima, ali i uzrokovati brojne probleme, pogotovo ako nismo svjesni da u nekom trenutku radimo sa faktorom (ovaj scenarij se zapravo vrlo lako izbjegava, što ćemo objasniti na kraju ovog poglavlja). Za početak ćemo predočiti što su zapravo faktori uz pomoć jednostavnog primjera. Zamislimo da sljedeći znakovni vektor opisuje razinu krvnog tlaka kod deset pacijenata: tlak &lt;- c(&quot;nizak&quot;, &quot;visok&quot;, &quot;visok&quot;, &quot;normalan&quot;, &quot;normalan&quot;, &quot;nizak&quot;, &quot;visok&quot;, &quot;nizak&quot;, &quot;normalan&quot;, &quot;normalan&quot;) Ovo je očito “kategorijska” varijabla budući da može poprimiti jednu od tri diskretne vrijednosti - \"nizak\", \"normalan\" i \"visok\". Prema tome, ovaj vektor je tipičan kandidat za “faktoriziranje”, tj. za pretvorbu u objekt klase factor. Faktorizaciju znakovnog vektora provodimo uz pomoć funkcije factor kojoj prosljeđujemo (u pravilu) znakovni vektor kao parametar. Zadatak 4.8 - faktoriziranje znakovnog vektora tlak &lt;- c(&quot;nizak&quot;, &quot;visok&quot;, &quot;visok&quot;, &quot;normalan&quot;, &quot;normalan&quot;, &quot;nizak&quot;, &quot;visok&quot;, &quot;nizak&quot;, &quot;normalan&quot;, &quot;normalan&quot;) # ispišite varijablu `tlak` # ispišite klasu varijable `tlak` # stvorite varijablu `tlak.f` koja će biti faktorizirana # inačica varijable `tlak` # ispišite varijablu `tlak.f` # ispišite klasu varijable tlak.f tlak &lt;- c(&quot;nizak&quot;, &quot;visok&quot;, &quot;visok&quot;, &quot;normalan&quot;, &quot;normalan&quot;, &quot;nizak&quot;, &quot;visok&quot;, &quot;nizak&quot;, &quot;normalan&quot;, &quot;normalan&quot;) # ispišite varijablu `tlak` tlak # ispišite klasu varijable `tlak` class(tlak) # stvorite varijablu `tlak.f` koja će biti faktorizirana # inačica varijable `tlak` tlak.f &lt;- factor(tlak) cat(&quot;-----------\\n&quot;) # ispišite varijablu `tlak.f` tlak.f # ispišite klasu varijable tlak.f class(tlak.f) ## [1] &quot;nizak&quot; &quot;visok&quot; &quot;visok&quot; &quot;normalan&quot; &quot;normalan&quot; &quot;nizak&quot; ## [7] &quot;visok&quot; &quot;nizak&quot; &quot;normalan&quot; &quot;normalan&quot; ## [1] &quot;character&quot; ## ----------- ## [1] nizak visok visok normalan normalan nizak visok nizak ## [9] normalan normalan ## Levels: nizak normalan visok ## [1] &quot;factor&quot; Vidimo da je ispis faktora dobio dodatni atribut Levels. To znači da se sada ovdje radi o “pravoj” kategorijskoj varijabli sa točno definiranim kategorijama koje smije poprimiti. Ako pokušamo dodati novu vrijednost u faktor koja nije zastupljena u trenutnim kategorijama (npr. “prenizak”) dobiti ćemo upozorenje, a umjesto kategorije koju smo naveli nova stavka imati će vrijednost NA. Ovo ponekad nije scenarij kojeg priželjkujemo. Ukoliko unaprijed znamo da znakovni vektor kojeg kategoriziramo ne sadrži sve moguće kategorije koje se općenito mogu pojaviti, imamo opciju dodavanja parametra levels u kojem ćemo uz pomoć znakovnog vektora eksplicitno navesti niz “mogućih” kategorija. Zadatak 4.9 - nezastupljene kategorije i parametar levels # dodajte 11. element u vektor `tlak.f` sa sadržajem &quot;prenizak&quot; # ispišite `tlak.f` # napravite varijablu `tlak.f2` uz pomoć varijable `tlak` # kategorijske razine navedite eksplicitno tako da sadrže # i kategorije &quot;prenizak&quot; i &quot;previsok&quot; # dodajte 11. element u vektor `tlak.f2` sa sadržajem &quot;prenizak&quot; # ispišite `tlak.f2` # dodajte 11. element u vektor `tlak.f` sa sadržajem &quot;prenizak&quot; tlak.f[11] &lt;- &quot;prenizak&quot; ## Warning in `[&lt;-.factor`(`*tmp*`, 11, value = &quot;prenizak&quot;): invalid factor level, ## NA generated # ispišite `tlak.f` tlak.f cat(&quot;-----------\\n&quot;) # napravite varijablu `tlak.f2` uz pomoć varijable `tlak` # kategorijske razine navedite eksplicitno tako da sadrže # i kategorije &quot;prenizak&quot; i &quot;previsok&quot; tlak.f2 &lt;- factor(tlak, levels = c(&quot;prenizak&quot;, &quot;nizak&quot;, &quot;normalan&quot;, &quot;visok&quot;, &quot;previsok&quot;)) # dodajte 11. element u vektor `tlak.f2` sa sadržajem &quot;prenizak&quot; tlak.f2[11] &lt;- &quot;prenizak&quot; # ispišite `tlak.f2` tlak.f2 ## [1] nizak visok visok normalan normalan nizak visok nizak ## [9] normalan normalan &lt;NA&gt; ## Levels: nizak normalan visok ## ----------- ## [1] nizak visok visok normalan normalan nizak visok nizak ## [9] normalan normalan prenizak ## Levels: prenizak nizak normalan visok previsok Koja je prednost faktora? Zašto varijable ne bismo ostavili u originalnom, “znakovnom” obliku? Razlog potrebe za faktoriziranjem kategorijskih stupaca tj. varijabli je poglavito u tome što određene statističke i vizualizacijske funkcije “znaju” na ispravan način interpretirati i koristiti faktore te ih tretiraju drugačije od običnih “znakovnih” stupaca. Zbog toga je vrlo dobra dugoročna strategija već u početku učenja R-a naviknuti se da kod rada sa podatkovnim okvirima faktoriziramo stupce koji su zaista kategorijske varijable (ali također i pripazimo da nemamo faktorizirane stupce koji nisu kategorijske varijable, što se može događati ako nismo pažljivi). Jedno od pitanja koje se često pitamo vezano uz kategorijske varijable jest - kolika je zastupljenost pojedinih kategorija? Odgovor na ovo pitanje daje nam funkcija table kojoj prosljeđujemo odabrani faktor. Zadatak 4.10 - funkcija table # ispišite zastupljenost pojedinih kategorija u faktoru `tlak.f2` # ispišite zastupljenost pojedinih kategorija u faktoru `tlak.f2` table(tlak.f2) ## tlak.f2 ## prenizak nizak normalan visok previsok ## 1 3 4 3 0 Funkcija table ne zahtijeva nužno faktor i uredno će raditi čak i sa znakovnim vektorom. No u tom slučaju ne bismo dobili informaciju o kategorijama koje nisu uopće zastupljene. Kategorijska varijabla iz naših primjera zapravo ima prirodu tzv. ordinalne kategorijske varijable, što znači da kategorije imaju prirodni poredak (nizak tlak je “manji” od normalnog koji je “manji” od visokog). Ukoliko želimo, ovu činjenicu možemo “ugraditi” u faktor kod njegove inicijalizacije, jednostavnim dodavanjem parametra ordered postavljenog na TRUE. Prednost ordinalnog faktora jest ta što nam omogućuje usporedbu vrijednosti faktora uz pomoć usporednih operatora. Zadatak 4.11 - ordinalni faktor # napravite varijablu `tlak.f3` na isti način kao i `tlak.f2` # ali uz dodatni parametar `ordered = TRUE` # pripazite da poredak kategorija odgovara ordinalnom rasporedu # ispišite `tlak.f3` # provjerite radi li se uistinu o ordinalnom faktoru # uz pomoć funkcije `is.ordered` # provjerite da li je tlak prvog pacijenta # (okvirno) niži od tlaka trećeg pacijenta # napravite varijablu `tlak.f3` na isti način kao i `tlak.f2` # ali uz dodatni parametar `ordered = TRUE` # pripazite da poredak kategorija odgovara ordinalnom rasporedu tlak.f3 &lt;- factor(tlak, levels = c(&quot;prenizak&quot;, &quot;nizak&quot;, &quot;normalan&quot;, &quot;visok&quot;, &quot;previsok&quot;), ordered = TRUE) # ispišite `tlak.f3` tlak.f3 # provjerite radi li se uistinu o ordinalnom faktoru # uz pomoć funkcije `is.ordered` is.ordered(tlak.f3) # provjerite da li je tlak prvog pacijenta # (okvirno) niži od tlaka trećeg pacijenta tlak.f3[1] &lt; tlak.f3[3] ## [1] nizak visok visok normalan normalan nizak visok nizak ## [9] normalan normalan ## Levels: prenizak &lt; nizak &lt; normalan &lt; visok &lt; previsok ## [1] TRUE ## [1] TRUE Već smo uvidjeli da je u R-u zapravo “sve vektor” - brojevi su jednodimenzionalni numerički vektori, matrice su vektori sa dodanim parametrom dimenzionalnosti, liste su vektori malih listi, podatkovni okviri su liste za dodanom restrikcijom. Možemo se zapitati - što su zapravo faktori? Implementacijski, faktor je zapravo kodirani ili enumerirani skup vrijednosti inicijalno definiranih znakovnih nizova, uz pridruženu kodnu tablicu istih. Jednostavnije rečeno, faktorizacija znakovnog vektora uključuje: “popisivanje” svih uočenih kategorija (ili preuzimanje eksplicitnog popisa iz parametra levels) pridjeljivanje numeričkih vrijednosti redom svakoj kategoriji (npr: \"nizak\" -&gt; 1, \"normalan\" -&gt; 2 itd.) “pakiranje” novostvorenog numeričkog vektora i pripadajuće “kodne tablice” Iako ove korake R radi automatski, u internu strukturu faktora možemo se uvjeriti ako faktor probamo pretvoriti u čisti numerički, odnosno čisti znakovni tip. Zadatak 4.12 - interna struktura faktora # ispišite vrijednost varijable tlak.f3 pretvorene u znakovni tip # ispišite vrijednost varijable tlak.f3 pretvorene u numerički tip # ispišite vrijednost varijable tlak.f3 pretvorene u znakovni tip as.character(tlak.f3) # ispišite vrijednost varijable tlak.f3 pretvorene u numerički tip as.numeric(tlak.f3) ## [1] &quot;nizak&quot; &quot;visok&quot; &quot;visok&quot; &quot;normalan&quot; &quot;normalan&quot; &quot;nizak&quot; ## [7] &quot;visok&quot; &quot;nizak&quot; &quot;normalan&quot; &quot;normalan&quot; ## [1] 2 4 4 3 3 2 4 2 3 3 Pretvaranjem faktora u znakovni tip zapravo radimo operaciju inverzne faktorizacije, tj. možemo se vratiti na izvorni znakovni vektor. S druge strane, pretvaranjem faktora u numerički tip, dobit ćemo popis kodiranih brojeva kojima se interni faktor koristi za predstavljanje svake kategorije. Ukoliko želimo, možemo i promijeniti “referentnu” (osnovnu) razinu pomoću funkcije relevel. # A = 1, B = 2, C = 3 relevel(f, ref = &quot;C&quot;) # C = 1, A = 2, B = 3 U ovom trenutku ovakvo igranje s razinama nema previše svrhe, no kod naprednijih analitičkih metoda ponekad želimo eksplicitno definirati koja je razina referentna, budući da se sve ostale razine na određeni način uspoređuju s njom. Sada se može postaviti jedno pitanje - ima li ikakve koristi od pretvaranja faktora u njegovu znakovnu ili numeričku kopiju? Općeniti odgovor bio bi - “ne”. Varijable faktora automatski će se ponašati kao znakovi gdje god je to potrebno (na primjer ako želimo filtrirati sva imena s tri slova). S druge strane, interni numerički prikaz je besmislen bez dodatne informacije kojoj kategoriji dani broj zapravo pripada. Međutim, saznanje što se događa kada pretvaramo faktor u znakovni ili numerički vektor može nam pomoći da izbjegnemo posebno nezgodnu pogrešku do koje može doći ako analitičar pogrešno rukuje faktorskim varijablama. Dobra je vijest da je izlaskom inačice R 4.0 mogućnost ove pogreške znatno smanjena, ali još uvijek vrijedi znati što ona podrazumijeva i kako je izbjeći. Pogreška o kojoj je riječ događa se kada je numerički stupac pogrešno identificiran kao kategorički stupac, što je prije inačice R 4.0 bila relativno česta pojava kada je analitičar dopustio R-u da automatski zaključi vrste stupaca koji se učitavaju iz vanjskog izvora podataka. Obzirom da je nazivna vrijednost parametra stringsAsFactors bila TRUE, ukoliko se ovaj parametar nije naveo R-ov algoritam prepoznavanja tipa stupaca bi prvo razdvojio radi li se o numeričkim ili znakovnim stupcima, a potom bi se znakovni stupci automatski faktorizirali. Zašto bi ovo predstavljalo problem? Pogledajmo sljedeći primjer, gdje imamo ručno unesene “tablične” podatke gdje jedan unos ima pogrešku ( 7.07 je greškom umetnut kao 7.O7). Simulirajmo što se moglo dogoditi u starijim verzijama R-a. 4.4.1 Primjer 4.1 - problem automatske kategorizacije # simulirana &quot;pogreška ručnog unosa&quot; df &lt;- data.frame(id = 1:5, measures = c(&quot;1.45&quot;, &quot;5.77&quot;, &quot;1.12&quot;, &quot;7.O7&quot;, &quot;3.23&quot;), stringsAsFactors = TRUE) # imitiramo ponašanje starijih inačica R-a # analitičar računa prosjek mjera, uočava neobično ponašanje mean(df$measures) ## Warning in mean.default(df$measures): argument is not numeric or logical: ## returning NA # sumnjajući na problem s tipom podatka, analitičar radi # eksplicitnu konverziju stupca u numerički df$measures &lt;- as.numeric(df$measures) # mjere zamjenjuju se numeričkim identifikatorima &quot;kategorija&quot; # stvarni iznosi mjera se nepovratno gube # daljnji numerički izračuni sa ovim stupcem neće rezultirati greškom # ali će biti besmisleni df ## [1] NA ## id measures ## 1 1 2 ## 2 2 4 ## 3 3 1 ## 4 4 5 ## 5 5 3 Zadaci za vježbu U mapi zajedno sa ovom bilježnicom pronađite datoteku mjestoNOHEADER.csv koja predstavlja datoteku istovjetnu datoteci mjesto.csv osim sljedećih značajki: nedostaju imena stupaca korišten je razmak kao razdvojnik Pokušajte uz pomoć dokumentacije učitati podatke iz ove datoteke u varijablu mjestoNH koja će biti istovjetna varijabli mjesto korištenoj u lekciji. U mapi zajedno sa ovom bilježnicom pronađite datoteku racun.csv i učitajte ju u varijablu racun. Pripazite da nizovi znakova nisu automatski pretvoreni u faktore. Ispišite na zaslon: broj redaka ove tablice broj stupaca tablice imena stupaca tablice Za tablicu racun napravite sljedeće: faktorizirajte stupac katArtikl ispišite šifru, naziv i cijenu svih artikala kategorije “slatkisi i grickalice” jeftinijih od 12 Kn ispišite koliko proizvoda koje kategorije se nalazi u računu dodajte stupac ukupno koji će sadržavati ukupnu cijenu pojedine stavke uračunavajući i cijenu i količinu izračunajte ukupni iznos računa Programirajmo u R-u by Damir Pintar is licensed under a Creative Commons Attribution-NonCommercial-NoDerivatives 4.0 International License.Based on a work at https://ratnip.github.io/FER_OPJR/ "],["uvjet.html", "5 Uvjetne naredbe i petlje 5.1 Naredbe kontrole toka Zadaci za vježbu", " 5 Uvjetne naredbe i petlje 5.1 Naredbe kontrole toka Pod naredbama kontrole toka smatramo uglavnom konstrukte za uvjetno izvođenje naredbi i/ili tzv. “programske petlje” gdje se segment programa kontinuirano izvodi sve do (opcionalnog) ispunjavana određenih uvjeta koji će rezultirati “izlaskom” iz petlje i nastavljanjem programa. 5.1.1 Uvjetno izvođenje naredbi Uvjetno izvođenje naredbi već smo upoznali. Radi se o konstruktu if (uvjet) { blok } else { blok } pri čemu se vitičaste zagrade mogu izbaciti ako imamo samo jednu uvjetnu naredbu. Ovdje je možda zgodno napomenuti kako izbjeći jednu relativno čestu početničku grešku kod pisanja if naredbe. Pokušajte ju samostalno uočiti i ispraviti u sljedećem primjeru. Zadatak 5.1 - naredba if # izvršite sljedeću naredbu uvjetnog izvođenja if (2 &gt; 1) print(&quot;Uspjeh!&quot;) # pronađite grešku u sljedećoj `if-else` naredbi i ispravite ju if (1 &gt; 2) print(&quot;Uspjeh!&quot;) else print(&quot;Neuspjeh!&quot;) # izvršite sljedeću naredbu uvjetnog izvođenja if (2 &gt; 1) print(&quot;Uspjeh!&quot;) # pronađite grešku u sljedećoj `if-else` naredbi i ispravite ju if (1 &gt; 2) { print(&quot;Uspjeh!&quot;) } else print(&quot;Neuspjeh!&quot;) ## [1] &quot;Uspjeh!&quot; ## [1] &quot;Neuspjeh!&quot; Greška se javlja zbog toga što je R interpreterski jezik koji se u pravilu izvršava redak po redak, osim u slučajevima kada smo R-u proslijedili “nedovršenu” naredbu pri čemu će on čekati na “ostatak” prije no što krene sa izvršavanjem. U prethodnom primjeru druga naredba if je zapravo završena u prvom retku, tako da se R “iznenadi” kada idući redak počinje sa else. Kako bi spriječili ovaj scenarij, dovoljno je na nekim način objasniti R-u da naredba još nije dovršena, što je najlakše izvesti otvaranjem bloka u prvom retku i zatvaranjem u retku sa else. Čitateljima koji programiraju u jezicima C ili Java biti će poznat pojam tzv. “ternarnog operatora” koji zapravo predstavlja kompaktnu verziju if-else bloka: x = (a &lt; b) ? c : d # nije primjer iz jezika R! Ulogu ovog operatora u R-u obavlja funkcija ifelse. Zadatak 5.2 - funkcija ifelse a &lt;- 1:3 b &lt;- c(0, 2, 4) # kako izgleda vektor `x` nakon izvršavanja sljedeće naredbe? # razmislite o odgovoru a potom provjerite ispravnost rješenja x &lt;- ifelse(a &lt; b, 2, 5) x &lt;- ifelse(a &lt; b, 2, 5) x ## [1] 2 2 2 2 Uočite da je funkcija ifelse (očekivano) vektorizirana, zbog čega je posebno pogodna za stvaranje novih stupaca podatkovnih okvira koji su izvedeni iz određenih uvjeta vezanih uz postojeće stupce. 5.1.2 Programske petlje U programskom jeziku R imamo tri tipa petlji: repeat - beskonačna petlja while - petlja s provjerom uvjeta na početku for - iteratorska petlja (“petlja s poznatim brojem ponavljanja”) 5.1.3 Petlja repeat Petlja repeat je najjednostavnija petlja. Ona ima sljedeću sintaksu: repeat {blok} Ovdje se radi o “beskonačnoj” petlji gdje se nakon završetka bloka on ponovo izvršava i tako unedogled. Jedini način izlaska iz ovakve petlje jest korištenje naredbe break. Pored ove naredbe imamo i naredbu next koja će preskočiti ostatak bloka, ali neće izaći iz petlje već će nastaviti izvršavati blok. Pogledajmo kako radi ova petlja u sljedećoj vježbi. Zadatak 5.3 - Petlja repeat # prije izvršavanja sljedećeg bloka odgovorite na pitanja: # - hoće li se petlja izvršavati beskonačno? # - što će se ispisati na zaslonu? i &lt;- 1 repeat { i &lt;- i + 1 if (i %% 2 == 0) next print(i) if (i &gt; 10) break } ## [1] 3 ## [1] 5 ## [1] 7 ## [1] 9 ## [1] 11 Često unaprijed znamo uvjet izlaska iz petlje te bismo ga htjeli staviti na jasno vidljivo mjesto tako da nije “skriven” u tijelu petlje. Za to nam pomaže tzv. while petlja. 5.1.4 Petlja while Petlja while predstavlja “najčišći” oblik programske petlje čija sintaksa doslovno glasi “dok je uvjet ispunjen, ponavljaj navedeni kod”: while (uvjet) {blok} Zadatak 5.4 - Petlja while # dodajte uvjet petlje tako da se ona izvrši # točno 7 puta i &lt;- 1 while() { print(i) i &lt;- i+1 } # dodajte uvjet petlje tako da se ona izvrši # točno 7 puta i &lt;- 1 while(i &lt;= 7) { print(i) i &lt;- i+1 } ## [1] 1 ## [1] 2 ## [1] 3 ## [1] 4 ## [1] 5 ## [1] 6 ## [1] 7 Kod ove petlje moramo paziti da se u određenoj iteraciji moraju stvoriti uvjeti za izlaz, inače ona također postaje “beskonačna” petlja. Usprkos tome što imamo jasno definiran način izlaska iz petlje, mi i u ovoj petlji možemo slobodno koristiti ključne riječi next i break, koje imaju istu funkciju kao i kod petlje repeat. Zadatak 5.5 - Petlja while (2) n &lt;- 1234 nbin &lt;- numeric(0) # napunite vektor `nbin` znamenkama `n` pretvorenog u binarni oblik # primjer: ako je `n` bio 12, `nbin` bi trebao biti c(1,1,0,0) # koristite se petljom `while` # naputak: proučite kako radi funkcija `rev` koja se u ovom zadatku može pokazati korisnom # ispišite `nbin` na zaslon # (opcionalno) ispišite rezultat sljedeće naredbe na zaslon # paste(nbin, collapse = &quot;&quot;) n &lt;- 1234 nbin &lt;- numeric(0) while (n != 0) { nbin &lt;- c(nbin, n %% 2) n &lt;- n %/% 2 } nbin &lt;- rev(nbin) nbin paste(nbin, collapse = &quot;&quot;) ## [1] 1 0 0 1 1 0 1 0 0 1 0 ## [1] &quot;10011010010&quot; 5.1.5 Petlja for Petlja for ili “iteratorska petlja” služi za lako “šetanje” po nekoj programskoj strukturi (najčešće vektoru), uzimajući element po element i nešto radeći s njim. Ona koristi ključnu riječ for, ime nove (iteratorske) varijable, ključnu riječ in te vektor čije vrijednosti se uzimaju jedna po jedna i koriste unutar petlje (uočite da navedeni in nije isto što i operator %in% koji provjerava da li se neki element nalazi u nekom skupu!). Sintaksa ove petlje je sljedeća: “standardna” inačica: for (i in v) { # radi nešto sa i } “indeksna” inačica: for (i in 1:length(a)) { # radi nešto sa a[i] } “imenska” inačica (ako a ima definirana imena): for (i in names(a)) { # radi nešto sa a[i] } Zadatak 5.6 - Petlja for a &lt;- seq(-10, 10, 4) # ispišite elemente vektora `a` jedan po jedan # uz pomoć petlje `for` # pristupajte elementima direktno # ponovite isto ali iterirajte po indeksima a &lt;- seq(-10, 10, 4) # ispišite elemente vektora `a` jedan po jedan # uz pomoć petlje `for` # pristupajte elementima direktno for (i in a) print(i) # ponovite isto ali iterirajte po indeksima for (i in 1:length(a)) print(a[i]) ## [1] -10 ## [1] -6 ## [1] -2 ## [1] 2 ## [1] 6 ## [1] 10 ## [1] -10 ## [1] -6 ## [1] -2 ## [1] 2 ## [1] 6 ## [1] 10 Uočite da je drugi način bolji ako želite mijenjati elemente vektora ili imati informaciju na kojem mjestu unutar originalnog vektora se trenutno nalazite. Zadatak 5.7 - Petlja for (2) # pročitajte podatke iz datoteke &quot;people.csv&quot; u podatkovni okvir `people` # potom uz pomoć petlje `for` za svaki numerički stupac # ispišite njegov naziv i aritmetičku sredinu njegovih vrijednosti (funkcija `mean`) # pročitajte podatke iz datoteke &quot;people.csv&quot; u podatkovni okvir `people` # potom uz pomoć petlje `for` za svaki numerički stupac # ispišite njegov naziv i aritmetičku sredinu njegovih vrijednosti (funkcija `mean`) people &lt;- read.csv(&quot;people.csv&quot;) for (i in 1:length(people)) { if (is.numeric(people[[i]])) { print(names(people)[i]) print(mean(people[[i]])) } } ## [1] &quot;birthyear&quot; ## [1] 1978.404 ## [1] &quot;weight&quot; ## [1] 75.1223 ## [1] &quot;height&quot; ## [1] 160.5191 Sad kad smo naučili sintaksu petlji važno je naglasiti jednu činjenicu - u programskom jeziku R u pravilu se ne preporučuje korištenje programskih petlji . Iako ovo inicijalno možda djeluje neočekivano i pomalo šokantno, razlog je jednostavan - R je jezik dizajniran upravo da radi po principu “sve odjednom”. Već smo vidjeli da principu vektoriziranosti i recikliranja učinkovito obavljaju poslove koji bi u drugim programskim jezicima zahtijevali petlju, a u poglavljima koje slijede vidjet ćemo da R nudi i mnoge druge konstrukte koji izbjegavaju eksplicitno ponavljanje koda uz uvjet nauštrb deklarativne sintakse koja to obavlja automatski. Na primjer, sljedeći primjer je sintaksno potpuno ispravan: # primjer nepotrebnog korištenja petlje a &lt;- 1:5 b &lt;- 6:10 c &lt;- numeric() for (i in 1:length(a)) c[i] &lt;- a[i] + b[i] ali vjerojatno radi sporije i puno je nečitljiviji od: # R-ovska sintaksa a &lt;- 1:5 b &lt;- 6:10 c &lt;- a + b Sve navedeno naravno ne znači da petlje u R-u ne smijemo koristiti, samo da bi njihovo korištenje trebalo biti popraćeno dodatnim razmatranjem da li je na tom mjestu petlja zaista potrebna te da li postoji alternativna sintaksa koji isti posao obavlja deklarativno (i potencijalno brže, budući da su mnoge rutine R-a implementirane u jeziku C). Rano prihvaćanje “R-ovskog” načina razmišljanja rezultirati će dugoročnim benefitom koji će se očitovati kompaktnijim, čišćim i često učinkovitijim programskim kodom. Zadaci za vježbu Stvorite podatkovni okvir mjesto uz pomoć sljedeće naredbe: mjesto &lt;- data.frame( pbr = c(10000, 51000, 21000, 31000, 2000), nazivMjesta = c(&quot;Zagreb&quot;, &quot;Rijeka&quot;, &quot;Split&quot;, &quot;Osijek&quot;, &quot;Dubrovnik&quot;), prirez = c(18, 15, 10, 13, 10)) Dodajte ovom okviru stupac prirezOpis koji će biti ordinalna faktorska varijabla sa razinama \"mali\", \"srednji\" i \"visok\" ovisno o tome da li je postotak prireza strogo manji od 12, između 12 i 15 ili strogo veći od 15. Koristite se naredbom ifelse. Zamijenite petlje u sljedećem bloku ekvivalentnim vektoriziranim operacijama (za drugu petlju proučite dokumentaciju funkcije sum). a &lt;- numeric() i &lt;- 1 while (i &lt;= 100) { a &lt;- c(a, i) i &lt;- i + 1 } suma &lt;- 0 for (i in a) { if (i %% 2 == 0) suma &lt;- suma + i*i } print(suma) Programirajmo u R-u by Damir Pintar is licensed under a Creative Commons Attribution-NonCommercial-NoDerivatives 4.0 International License.Based on a work at https://ratnip.github.io/FER_OPJR/ "],["paketi.html", "6 Paketi, ugrađene funkcije i okoline 6.1 Rad s paketima 6.2 Ugrađene funkcije 6.3 Okoline Zadaci za vježbu", " 6 Paketi, ugrađene funkcije i okoline 6.1 Rad s paketima Kao što smo naveli u uvodu, standardna R distribucija dolazi sa dvije kolekcije paketa (nazvanih r-base i r-recommended) koje sadrže svojevrsnu “jezgru” jezika R - skup elemenata dostatnih za provođenje standardnih tipova podatkovnih analiza uz pomoć programskog jezika R. Također, podsjetimo se na činjenicu da se svi službeni dodatni paketi objavljuju u tzv. CRAN (Comprehensive R Archive Network) repozitorij, čija se ažurna inačica nalazi replicirani na nizu globalnih poslužitelja. Kod podizanja R okoline automatski se učitavaju određeni paketi u radnu memoriju čime njihovi elementi postaju dostupni za korištenje. Popis učitanih paketa možemo dobiti korištenjem funkcije search. Zadatak 6.1 - staza pretrage # pozovite funkciju `search` (bez parametara) i pogledajte koji paketi su učitani u okolinu # pozovite funkciju `search` (bez parametara) i pogledajte koji paketi su učitani u okolinu search() ## [1] &quot;.GlobalEnv&quot; &quot;package:sloop&quot; &quot;package:kernlab&quot; ## [4] &quot;package:ranger&quot; &quot;package:caret&quot; &quot;package:lattice&quot; ## [7] &quot;package:e1071&quot; &quot;package:corrplot&quot; &quot;package:broom&quot; ## [10] &quot;package:car&quot; &quot;package:carData&quot; &quot;package:Hmisc&quot; ## [13] &quot;package:sn&quot; &quot;package:stats4&quot; &quot;package:gridExtra&quot; ## [16] &quot;package:RSQLite&quot; &quot;package:hflights&quot; &quot;package:GGally&quot; ## [19] &quot;package:lubridate&quot; &quot;package:forcats&quot; &quot;package:stringr&quot; ## [22] &quot;package:dplyr&quot; &quot;package:purrr&quot; &quot;package:readr&quot; ## [25] &quot;package:tidyr&quot; &quot;package:tibble&quot; &quot;package:ggplot2&quot; ## [28] &quot;package:tidyverse&quot; &quot;package:MASS&quot; &quot;package:stats&quot; ## [31] &quot;package:graphics&quot; &quot;package:grDevices&quot; &quot;package:utils&quot; ## [34] &quot;package:datasets&quot; &quot;package:methods&quot; &quot;Autoloads&quot; ## [37] &quot;package:base&quot; Vidimo da većina paketa ima svoju stavku oblika \"package:ime_paketa\". Raspored paketa predstavlja i njihov “prioritet” glede pretrage imenskog područja, o čemu će više riječi biti kasnije. Kao što znamo, kad želimo učitati novi paket u našu okolinu, to možemo izvesti uz pomoć funkcije library kojoj dajemo ime paketa (bez navodnika). Zadatak 6.2 - učitavanje paketa u radnu okolinu # učitajte paket `dplyr` u R okolinu # učitajte paket `dplyr` u R okolinu library(dplyr) Naredba iz prethodnog primjera može imati dva ishoda: ukoliko paket postoji na lokalnom računalu (u mapi predodređenoj za dodatne pakete), on će biti učitan u radnu okolinu. Učitavanje paketa može biti popraćeno porukama o objektima koji su nakon učitavanja “maskirani”. To konkretno znači da je novi paket privremeno uskratio dostupnost pojedinim elementima iz ranije učitanih paketa iz razloga što im se podudaraju imena. Ovo često ne predstavlja nikakav problem, ali ukoliko korisnik ima potrebu za pristupom maskiranim elementima morati će koristiti njihovo “puno” ime tj. morati će navesti i ime paketa gdje se nalaze. Na primjer, ako je funkcija filter iz paketa stats maskirana nakon učitavanja novog paketa, ona je i dalje dostupna preko punog imena stats::filter ali ne direktno preko filter, budući da će to pozivati funkciju iz najnovije učitanog paketa. Više detalja o tome kako R razrješava nazive varijabli i funkcija biti će dano u nastavku ove lekcije. Zadatak 6.3 - instalacija paketa sa CRAN repozitorija # instalirajte paket `dplyr` sa CRAN repozitorija # (ovo možete učiniti čak i ako već imate navedeni paket) # učitajte ponovo paket u radnu okolinu # ispišite stazu pretrage # instalirajte paket `dplyr` sa CRAN repozitorija # (nije nužno ako već imate navedeni paket, ali obratite pažnju na sintaksu) install.packages(&quot;dplyr&quot;) # učitajte ponovo paket u radnu okolinu library(dplyr) # ispišite stazu pretrage search() ## [1] &quot;.GlobalEnv&quot; &quot;package:sloop&quot; &quot;package:kernlab&quot; ## [4] &quot;package:ranger&quot; &quot;package:caret&quot; &quot;package:lattice&quot; ## [7] &quot;package:e1071&quot; &quot;package:corrplot&quot; &quot;package:broom&quot; ## [10] &quot;package:car&quot; &quot;package:carData&quot; &quot;package:Hmisc&quot; ## [13] &quot;package:sn&quot; &quot;package:stats4&quot; &quot;package:gridExtra&quot; ## [16] &quot;package:RSQLite&quot; &quot;package:hflights&quot; &quot;package:GGally&quot; ## [19] &quot;package:lubridate&quot; &quot;package:forcats&quot; &quot;package:stringr&quot; ## [22] &quot;package:dplyr&quot; &quot;package:purrr&quot; &quot;package:readr&quot; ## [25] &quot;package:tidyr&quot; &quot;package:tibble&quot; &quot;package:ggplot2&quot; ## [28] &quot;package:tidyverse&quot; &quot;package:MASS&quot; &quot;package:stats&quot; ## [31] &quot;package:graphics&quot; &quot;package:grDevices&quot; &quot;package:utils&quot; ## [34] &quot;package:datasets&quot; &quot;package:methods&quot; &quot;Autoloads&quot; ## [37] &quot;package:base&quot; Napomena: u pravilu pakete instaliramo samo jednom i to preko konzole tako da nikad nema potrebe naredbe za instalaciju paketa ugrađivati u R Markdown dokumente; također, zbog lakše organizacije izvještaja, učitavanje svih potrebnih paketa se po konvenciji obavlja na početku dokumenta, u isječku koda nazvanom setup. Uočimo da će instalacija i učitavanje paketa automatski sa sobom povući i učitavanje svih paketa koji su preduvjeti za korištenje traženog paketa, što uvelike olakšava rad korisniku koji se ne mora brinuti o tome što “dodatno” treba instalirati kako bi mogao koristiti elemente paketa. Ako želimo saznati više informacija o nekom paketu, to također možemo izvesti uz pomoć funkcije library uz parametar help postavljen na ime paketa. library(help = dplyr) # preporuka: isprobati direktno u konzoli Još jedan prilično popularan način dokumentiranja paketa je uz pomoć tzv. “vinjeta” (engl. vignettes). Vinjete su zapravo “mini-tutorial” nekog paketa u HTML obliku koji služi za predstavljanje funkcionalnosti paketa na pristupačan, čitljiv način uz pomoć detaljnih objašnjenja i pripadajućeg programskog koda. Možemo pogledati koje vinjete su instalirane na sustav pozivom funkcije browseVignettes() bez parametara (ili opcionalno dodati kao parametar imena paketa ako nas zanimaju samo njegove vinjete). Ako paket ima samo jednu vinjetu (npr. paket stringr). Možemo također odmah otvoriti vinjetu uz pomoć funkcije vignette(ime_paketa). vignette(&quot;stringr&quot;) # preporuka: isprobati direktno u konzoli 6.2 Ugrađene funkcije U prethodnim poglavljima već smo upoznali neke od gotovih funkcija koje dobijamo zajedno sa našom R distribucijom. To su npr. numeričke funkcije (log, abs, sqrt, round i sl.), funkcije za stvaranje vektora (rep, seq i sl.), funkcije za rad s paketima (install.packages, library i sl.) i tako dalje. U R-u se rijetko govori o “ugrađenim” funkcijama budući da - kao što je već prikazano - R okolina automatski učitava neke često korištene pakete čiji su elementi odmah dostupni za korištenje, bez nužnog navođenja imena paketa u kojem se nalaze. Npr. paket stats sadrži bogati skup funkcija vezanih uz statističke obrade. Jedna od tih funkcija je i rnorm koja vraća numerički vektor željene duljine čiji su elementi nasumično odabrani iz normalne distribucije sa aritmetičkom sredinom 0 i standardnom devijacijom 1 (ove vrijednosti možemo i promijeniti uz pomoć parametara mean i sd). Ukoliko želimo, ovu funkciju možemo pozvati uz pomoć sintakse ime_paketa::ime_funkcije(parametri). Zadatak 6.4 - poziv funkcije iz definiranog paketa # stvorite vektor x koji će imati 10 slučajnih elemenata # izvučenih iz standardne normalne distribucije # koristite puni naziv funkcije `rnorm` iz paketa `stats` # zaokružite elemente vektora x na dvije decimale # koristite puni naziv funkcije `round` iz paketa `base` # ispišite vektor x # stvorite vektor x koji će imati 10 slučajnih elemenata # izvučenih iz standardne normalne distribucije # koristite puni naziv funkcije `rnorm` iz paketa `stats` x &lt;- stats::rnorm(10) # zaokružite elemente vektora x na dvije decimale # koristite puni naziv funkcije `round` iz paketa `base` x &lt;- base::round(x, 2) # ispišite vektor x x ## [1] 1.43 0.98 -0.62 -0.73 -0.52 -1.75 0.88 1.37 -1.69 -0.63 Iako je ovo sintaksno korektan način pozivanja funkcije, R nam omogućuje da izuzmemo nazive paketa i jednostavno navedemo samo naziv funkcije. Zadatak 6.5 - poziv funkcije bez imena paketa # stvorite vektor y po istom principu kao i vektor x # obavite sve u jednom retku # koristite nazive funkcija bez naziva paketa # ispišite y # stvorite vektor y po istom principu kao i vektor x # obavite sve u jednom retku # koristite nazive funkcija bez naziva paketa y &lt;- round(rnorm(10), 2) # ispišite y y ## [1] 0.02 0.71 -0.65 0.87 0.38 0.31 0.01 -0.04 0.72 -0.50 Možemo se zapitati - kako R zna gdje se nalazi funkcija koju želimo pozvati, ako nismo eksplicitno učitali niti naveli paket koji sadrži tu funkciju? Točan razlog objasniti ćemo u idućem poglavlju koje se bavi okolinama i već viđenom “stazom pretrage”. Popisivanje svih dostupnih funkcija, pa čak i onih češće korištenih, bilo bi redundantno budući da se R jezik najbolje uči uz konkretnu primjenu, pri čemu nakon određenog vremena korištenja korisnik polako oformi “vlastiti” skup funkcija koje predstavljaju njegov uobičajeni “alat” za analize. U svakom slučaju, svakako se preporučuje odabir nekog od javno dostupnih R podsjetnika (reference card ili cheat sheet) koji će onda uvijek biti pri ruci za vrijeme R programiranja. Pojedini R podsjetnici dostupni su i na samom CRAN-u (dovoljno je upisati CRAN reference card u tražilicu i pregledati rezultate), no ovdje ćemo iskoristiti priliku i preporučiti izvrsne “šalabahtere” na stranicama sučelja RStudio dostupne na sljedećoj poveznici: https://www.rstudio.com/resources/cheatsheets/ (alternativno, upišite RStudio cheat sheets u tražilicu). Ovi podsjetnici sadržajno pokrivaju većinu korisnih stvari vezanih uz općenite elemente jezika R (Base R, Advanced R) ali i konkretne pakete koje ćemo kasnije upoznati (dplyr, ggplot2) te predstavljaju vrlo vrijedne resurse kako za učenje R-a, tako i za dugoročno korištenje. Za lakše praćenje lekcija koje slijede, preporučujemo ispis navedenih podsjetnika i upoznavanje sa elementima koje sadržavaju, budući da se predstavlja o dugoročno korisnom pomagalu za programiranje u jeziku R. Za kraj, spomenimo da nam R omogućuje brzo dohvaćanje pomoći o funkciji jednostavnim pozivom ?ime_funkcije ili help(ime_funkcije) te da možemo dobiti primjere korištenja funkcije kroz example(ime_funkcije). Ove pozive bismo trebali vrlo često koristiti čak i ako smatramo da smo dobro upoznati sa funkcijom koju pozivamo - lako je moguće da postoji neki dodatni parametar (ili srodna funkcija koje se također često navode u dokumentaciji) a koji će nam dodatno pomoći u obavljanju zadatka zbog kojeg funkciju i koristimo. 6.3 Okoline Kao što je već rečeno, rad u R-u svodi se na upravljanje različitim objektima. Kako bismo uopće mogli upravljati tim objektima, potrebni su nam mehanizmi uz pomoć kojih referenciramo dotične objekte. U R-u se to zove “povezivanje” (engl. binding). Kada stvorimo varijablu x numeričkog tipa i njoj pridružimo broj 5, mi smo zapravo stvorili (jednoelementni) numerički vektor i “povezali” taj podatak sa nizom znakova \"x\" kojeg potom možemo koristiti za daljnje referenciranje tog podatka (ili tih podataka). Stoga, kada želimo pristupiti nekoj varijabli, R mora pretražiti svoj interni “zapisnik” koje varijable trenutno postoje, kojeg su tipa te kako im pristupiti. Kako bi R pronašao varijablu, on koristi mehanizam zvan “leksičko uokviravanje” (engl. lexical scoping) koji se temelji na konceptu zvanom okoline (engl. environments). “Okolina” se često naziva “vrećom za nazive” (engl. bag of names). Ona nam pomaže da logički grupiramo nazive objekata koje koristimo i da pomognemo R-u naći naziv u drugim okolinama ako isti ne postoji u trenutnoj okolini. Ovo potonje je omogućeno na način da (gotovo) svaka okolina ima poveznicu na svoju okolinu-roditelja (engl. parent environment). Ovakav sustav poveznica na okoline-roditelje stvara svojevrsnu “hijerarhiju okolina” koja se često naziva i “staza pretrage” (engl. search path); R, tražeći zadano ime varijable, pretražuje okoline “uzlazno” sve dok ne pronađe prvu pojavu traženog naziva ili naleti na krajnju okolinu bez roditelja (tzv. prazna okolina - engl. empty environment). Ono što je interesantno jest činjenica da je i sama okolina objekt - možemo stvoriti referencu na nju, slati ju u funkcije i sl. “Osnovna” okolina u kojoj radimo i u kojoj stvaramo nove varijable je tzv. globalna okolina, ili .GlobalEnv (paziti na točku!). Ona je na dnu hijerarhije okolina. Možemo dohvatiti referencu na nju preko istoimene varijable, ili se poslužiti funkcijom globalenv(). Zadatak 6.6 - globalna okolina # stvorite varijablu e i u nju pohranite referencu na globalnu okolinu # ispišite varijablu e # stvorite varijablu x i u nju ubacite broj 5 # izvršite funkciju `ls` bez parametara # izvršite funkciju `ls` sa varijablom `e` kao parametrom # ispišite x # ispišite e$x (uočite sintaksu liste!) # stvorite varijablu e i u nju pohranite referencu na globalnu okolinu e &lt;- .GlobalEnv # ili e &lt;- globalenv() # ispišite varijablu e e # stvorite varijablu x i u nju ubacite broj 5 x &lt;- 5 # izvršite funkciju `ls` bez parametara #ls() # probati na konzoli! # izvršite funkciju `ls` sa varijablom `e` kao parametrom #ls(e) # probati na konzoli! # ispišite x x # ispišite e$x (uočite sintaksu liste!) e$x ## &lt;environment: R_GlobalEnv&gt; ## [1] 5 ## [1] 5 Iz zadnjeg primjera možemo vidjeti da okolina bez problema može čuvati i referencu na samu sebe obliku varijable e, tako da je ovo zapravo potpuno ispravna (iako nepotrebno komplicirana) sintaksa za ispis varijable x: e$e$e$e$e$e$e$e$e$e$e$e$e$e$e$e$e$e$e$e$x Okoline su u izvjesnoj mjeri slične listama, koje su isto zapravo svojevrsni način “enkapsulacije” niza objekata u jedinstvenu strukturu. Najbitnije razlike između okoline i liste su: poredak elemenata u okolini je nebitan okolina (u pravilu) ima poveznicu na okolinu roditelja Pogledajmo tko je okolina-roditelj globalnoj okolini uz pomoć funkcije parent.env. Zadatak 6.7 - okoline roditelji # ispišite okolinu-roditelja globalne okoline i objasnite rezultat # ispišite okolinu-roditelja globalne okoline i objasnite rezultat parent.env(e) ## &lt;environment: package:sloop&gt; ## attr(,&quot;name&quot;) ## [1] &quot;package:sloop&quot; ## attr(,&quot;path&quot;) ## [1] &quot;C:/R/R-4.3.1/library/sloop&quot; Pomalo neočekivano, roditelj globalne okoline jest zadnje učitani paket! Ovo zapravo nije neobično - globalna okolina ima “prioritet” kod referenciranja varijable, ali prioritetno odmah “ispod” nje su oni objekti i funkcije koje smo zadnje učitali u okolinu (što nam odgovara budući da je pretpostavka da je “najsvježije” učitani paket onaj kojeg namjeravamo odmah koristiti). Drugim riječima, učitavanjem paketa novi paket se uvijek “namjesti” između globalne okoline i paketa koji je prije njega bio zadnji učitan. Kada smo pozivali funkciju search, zapravo smo dobili hijerarhiju okolina koje predstavljaju učitane pakete. Ova hijerarhija okolina ujedno predstavlja i već spominjanu “stazu pretrage”. Uz pomoć funkcije parent.env možemo sami odrediti koju okolinu će neka okolina smatrati roditeljem. Na ovaj način možemo napraviti vlastitu hijerarhiju okolina. Nadalje varijable koje stvaramo ne moraju koristiti reference iz globalne okoline (što je zapravo i osnovna funkcija operatora &lt;-), mi ih možemo pohraniti u bilo koju okolinu koju želimo, no za to se moramo koristiti funkcijama assign i get ili kombinacijom operatora $ i &lt;-. # primjer - stvaramo malu hijerarhiju okolina i pohranjujemo # te ispisujemo varijablu koristeći jednu od njih e2 &lt;- new.env() e3 &lt;- new.env() # hijerarhija `e3` --&gt; `e2` --&gt; `e` (globalna) parent.env(e2) &lt;- e parent.env(e3) &lt;- e2 # stvaramo varijablu `x` u okolini `e2` assign(&quot;x&quot;, 5, e2) # ili e2$x &lt;- 5 # provjera postoji li varijabla `x` u okolini `e2` exists(&quot;x&quot;, e2) # ispis varijable `x` iz okoline e2 get(&quot;x&quot;, e2) #ili e2$x ## [1] TRUE ## [1] 5 Zašto bi koristili okoline u praksi? Okolina predstavlja zgodan način “omatanja” skupa varijabli koje onda zajedno možemo slati u neku funkciju - što je pogotovo zgodno ako dotične varijable referenciraju neke velike skupove podataka. Kao što ćemo vidjeti u sljedećoj lekciji, R ne podržava tzv. call-by-reference princip već kod slanja objekata u funkciju R koristi tzv. copy-on-modify mehanizam. Ovo znači da će funkcija koristiti referencu na originalni objekt poslan u nju kao parametar sve do naredbe koja taj objekt odluči mijenjati; u tom trenutku stvara se kopija tog objekta i tek onda se provode izmjene. Ovo može dovesti do značajnih usporavanja programa kod programera koji nisu upoznati s ovom činjenicom a koji npr. programiraju funkciju koja transformira podatkovni okvir. Ako funkciji umjesto reference na podatkovni okvir pošaljemo referencu na okolinu u koju je “zamotan” okvir, onda neće doći do kopiranja varijable jer je okolina jedini objekt za kojeg copy-on-modify ne vrijedi. Uočimo da je specijalni slučaj ove metode “slanje” globalne okoline u funkciju, što se zapravo svodi na korištenje “globalne varijable” - nečega što se u drugim programskim jezicima često izbjegava, ali u R-u nije pretjerano rijetka pojava upravo zbog činjenice da nas znatno usporavanje programa puno više smeta od potencijalnih problema koje globalne varijable sa sobom donose. Za kraj demonstrirajmo rad funkcije attach koju analitičari često koriste kako bi ubrzali postupak analize ali koja može uzrokovati probleme ako nismo pažljivi sa njenim korištenjem. Ova funkcija ubaciti će podatkovni okvir direktno u stazu pretrage kako bi nam omogućila “lakši” pristup varijablama, ni uz potencijalne nezgodne nuspojave. Pogledajmo ovo na primjeru. Zadatak 6.8 - funkcija attach mjesto &lt;- data.frame( pbr = c(10000, 51000, 21000, 31000, 2000), nazivMjesta = c(&quot;Zagreb&quot;, &quot;Rijeka&quot;, &quot;Split&quot;, &quot;Osijek&quot;, &quot;Dubrovnik&quot;), prosjPlacaKn = c(6359., 5418., 5170., 4892., 5348.), brojStanovnika = c(790017, 128384, 167121, 84104, 28434), prirez = c(18, 15, 10, 13, 10)) # pozovite funkciju `attach` i proslijedite podatkovni okvir `mjesto` kao parametar # ovo napravite samo jednom kako ne bi okvir ubacili više puta u stazu pretrage # ispišite stazu pretrage i komentirajte rezultat # ispišite varijablu pbr (bez reference na `mjesto`!) # promjenite treći element varijable prirez na 12 # ispišite tablicu `mjesto` # ispišite varijable globalne okoline # uz pomoć funkcije `detach` uklonite tablicu `mjesto` iz staze pretrage # pozovite funkciju `attach` i proslijedite podatkovni okvir `mjesto` kao parametar # ovo napravite samo jednom kako ne bi okvir ubacili više puta u stazu pretrage attach(mjesto) # ispišite stazu pretrage i komentirajte rezultat search() cat(&quot;-------------------------\\n&quot;) # radi preglednijeg ispisa # ispišite varijablu pbr (bez reference na `mjesto`!) pbr cat(&quot;-------------------------\\n&quot;) # radi preglednijeg ispisa # promjenite treći element varijable prirez na 12 prirez[3] &lt;- 12 # ispišite tablicu `mjesto` mjesto cat(&quot;-------------------------\\n&quot;) # radi preglednijeg ispisa # ispišite varijable globalne okoline #ls() # probati na konzoli! # uz pomoć funkcije `detach` uklonite tablicu `mjesto` iz staze pretrage detach(mjesto) ## [1] &quot;.GlobalEnv&quot; &quot;mjesto&quot; &quot;package:sloop&quot; ## [4] &quot;package:kernlab&quot; &quot;package:ranger&quot; &quot;package:caret&quot; ## [7] &quot;package:lattice&quot; &quot;package:e1071&quot; &quot;package:corrplot&quot; ## [10] &quot;package:broom&quot; &quot;package:car&quot; &quot;package:carData&quot; ## [13] &quot;package:Hmisc&quot; &quot;package:sn&quot; &quot;package:stats4&quot; ## [16] &quot;package:gridExtra&quot; &quot;package:RSQLite&quot; &quot;package:hflights&quot; ## [19] &quot;package:GGally&quot; &quot;package:lubridate&quot; &quot;package:forcats&quot; ## [22] &quot;package:stringr&quot; &quot;package:dplyr&quot; &quot;package:purrr&quot; ## [25] &quot;package:readr&quot; &quot;package:tidyr&quot; &quot;package:tibble&quot; ## [28] &quot;package:ggplot2&quot; &quot;package:tidyverse&quot; &quot;package:MASS&quot; ## [31] &quot;package:stats&quot; &quot;package:graphics&quot; &quot;package:grDevices&quot; ## [34] &quot;package:utils&quot; &quot;package:datasets&quot; &quot;package:methods&quot; ## [37] &quot;Autoloads&quot; &quot;package:base&quot; ## ------------------------- ## [1] 10000 51000 21000 31000 2000 ## ------------------------- ## pbr nazivMjesta prosjPlacaKn brojStanovnika prirez ## 1 10000 Zagreb 6359 790017 18 ## 2 51000 Rijeka 5418 128384 15 ## 3 21000 Split 5170 167121 10 ## 4 31000 Osijek 4892 84104 13 ## 5 2000 Dubrovnik 5348 28434 10 ## ------------------------- Objasnimo što se dogodilo u gornjem primjeru. Uz pomoć funkcije attach podatkovni okvir mjesto postao je “mini-okolina”, tj. njegovi stupci postali su dostupni unutar staze pretrage. Očiti benefit ovoga jest to da ih možemo referencirati direktno, bez reference na originalni podatkovni okvir i operatora $. No ovaj naočigled praktičan trik ima skrivene zamke - prvo, ako se imena stupaca podudaraju sa postojećim varijablama globalne okoline, onda ti stupci neće biti vidljivi (o ovom ćemo biti obaviješteni adekvatnim upozorenjem). Drugo - i puno problematičnije - ako pokušamo mijenjati stupac okvira direktnim referenciranjem, R će to spriječiti i potiho će primijeniti copy-on-modify princip stvaranjem nove, globalne varijable koja će biti kopija referenciranog stupca. Neopreznom analitičaru tako može promaknuti činjenica da se promjene koje naizgled unosi uopće ne odražavaju na samom podatkovnom okviru, što može imati dalekosežne posljedice. Ovi potencijalni problemi su vrlo rašireni među početnicima u jeziku R tako da se u literaturi često može naći preporuka da se funkcija attach ne koristi ukoliko to iz nekog razloga nije nužno. Npr. Google-ov stilski vodič za R kaže “mogućnosti greške kod korištenja funkcije attach su brojne, zato ju izbjegavajte”. Još jedna mogućnost koju imamo jest korištenje funkcije with kojoj prvo dajemo referencu na okolinu, a potom izraz koji koristi varijable iz te okoline: with(mjesto, prosjPlacaKn[prirez &gt; 12]) no u većini slučajeva korištenje ove funkcije neće rezultirati čitljivom sintaksom već upravo naprotiv - programski kod se dodatno komplicira. Ukoliko želimo izbjeći stalno referenciranje podatkovnog okvira u izrazima, za to postoje novi paketi upravo namjenjenih lakom upravljanju podatkovnih okvirima uz pomoć čiste i pregledne sintakse, kao npr. dplyr ili tidyr. Ove pakete upoznati ćemo u jednoj od nastupajućih lekcija. Zadaci za vježbu Učitajte sljedeće pakete u radnu okolinu: magrittr, dplyr, tidyr, ggplot2. Ispišite stazu pretrage i provjerite gdje se nalaze učitani paketi. Sljedeća naredba stvoriti će vektor od 20 nasumično odabranih prirodnih brojeva od 1 do 100. Uz pomoć podsjetnika i/ili službene dokumentacije pronađite ugrađene funkcije koje izvršavaju zadane zadatke. # učitavamo 20 prirodnih brojeva od 1 do 100, sa ponavljanjem set.seed(1234) a &lt;- sample(1:100, 20, replace = T) ispišite: vektor a vrijednosti vektora a poredane obrnutim redoslijedom jedinstvene vrijednosti iz vektora a vrijednosti vektora a poredane uzlazno Spomenuli smo da su učitani paketi zapravo “okoline”. Ukoliko želimo dobiti direktnu referencu na njih, moramo se poslužiti funkcijom as.environment i imenom paketa. Pokušajte dobiti referencu na paket package:magrittr u obliku okoline te uz pomoć funkcije ls provjerite koje nazive ona sadrži u sebi. Programirajmo u R-u by Damir Pintar is licensed under a Creative Commons Attribution-NonCommercial-NoDerivatives 4.0 International License.Based on a work at https://ratnip.github.io/FER_OPJR/ "],["korisnik.html", "7 Korisnički definirane funkcije 7.1 Kako definirati funkciju 7.2 Generičke funkcije 7.3 Što su apply funkcije? Zadaci za vježbu", " 7 Korisnički definirane funkcije Programski jezik R, iako objektnog tipa, u svojoj je srži jezik za funkcijsko programiranje. Ova programska paradigma nije nova (datira još iz 50-tih godina prošlog stoljeća), no u posljednje vrijeme dobiva znatno na popularnosti kao svojevrsni komplement objektno-orijentiranom programiranju, za koje bi se moglo reći da je dominantna programska paradigma u zadnjih nekoliko desetljeća. Kako ne bi preduboko ulazili u značajke funkcijskog programiranja te provodili detaljnu usporednu analizu sa objektno-orijentiranim principima, navesti ćemo samo nekoliko okvirnih značajki i smjernica vezano uz te dvije paradigme. Objektno-orijentirano programiranje u principu program gleda kao sustav imenica gdje komponente realiziramo u obliku objekata koji enkapsuliraju atribute spomenute imenice te metoda koje izvršavaju određene zadatke vezane uz navedenu imenicu. Isto tako, objektno-orijentirani sustavi usredotočavaju se na kontroliranu izmjenu stanja komponenata informacijskog sustava kao rezultat razmjene poruka između njih. Funkcijsko programiranje program gleda kao sustav glagola gdje funkcije, tj zadaci koje želimo izvršavati imaju prioritet naspram komponenata nad kojima se ti zadaci izvršavaju. Funkcijsko programiranje modelira informacijski sustav kroz komponente koje u pravilu ne mijenjaju vlastito stanje, tako da rezultat programa strogo ovisi o ulazima što olakšava testiranje i održavanje. Ukratko, razlika između objektno-orijentiranog programiranja i funkcijskog programiranje se često navodi na sljedeći način: “Kod objektno-orijentiranog programiranja stvaramo podatke koji sadrže funkcije; kod funkcijskog stvaramo funkcije koje sadrže podatke”. Za učenje R-a ne moramo se previše zamarati sa karakteristikama funkcijskog programiranja niti biti primorani usvojiti potpuno novu programsku paradigmu. No za uspješno učenje R-a svladavanje nekih koncepata funkcijskog programiranja može se pokazati iznimno korisnim budući da će nam omogućiti pisanje čišćeg i učinkovitijeg programskog koda koji će biti u skladu sa načinom na koji je R kao jezik i dizajniran. U R-u vrijedi sljedeće: funkcije su “punokrvni” objekti, možemo ih referencirati varijablom iz birane okoline, slati u funkcije kao argumente, primati kao povratnu vrijednost funkcije ili pohranjivati u podatkovne strukture kao što je npr. lista. Funkcija u R-u je jednostavno objekt kojeg se može “izvršiti” tj. natjerati da obavi neki posao. Veliki broj funkcija - pogotovo onih koje zamjenjuju konstrukt programske petlje - radi na principu funkcijskih jezika gdje posao obavljamo na način da deklarativno navedemo koju funkciju želimo primijeniti na kojoj podatkovnoj strukturi te pustimo da programski jezik sam obavlja niskorazinske poslove kao što je iteriranje po strukturi i pripremanje rezultata. Primjere ovoga ćemo naučiti uskoro, a sada se prvo upoznajmo sa sintaksom definiranja funkcije u R-u. 7.1 Kako definirati funkciju U općenitom slučaju, definicija nove funkcije izgleda ovako: ime_funkcije &lt;- function(ulazni argumenti) { tijelo funkcije } Uočimo da kod definicije funkcije koristimo operator &lt;-. Ovo nije slučajno - definicija funkcije nije ništa drugo nego stvaranje objekta klase function kojeg onda pridružujemo određenoj varijabli; ime varijable zapravo je “naziv” funkcije. U R-u ne definiramo tipove ulaznih i izlaznih argumenata. Ulazni argumenti imaju ime i opcionalnu nazivnu vrijednost. Funkcija formalno vraća jednu vrijednost, što nije nužno restrikcija ukoliko želimo vratiti više vrijednosti - jednostavno ih enkapsuliramo u obliku vektora ili liste. Ključna riječ return je opcionalna - funkcija vraća rezultat zadnjeg izraza u funkciji pa je često dovoljno navesti samo varijablu koja predstavlja povratnu vrijednost kao zadnji red funkcije. Konačno, ukoliko želimo povećati robusnost funkcije na način da ćemo odbiti izvođenje logike unutar funkcije ako nisu zadovoljeni određeni uvjeti, za to možemo koristiti funkciju stopifnot(&lt;logički izraz&gt;). Ova funkcija izračunava zadani logički izraz i prekida funkciju ako navedeni uvjet nije istinit. Zadatak 7.1 - prva korisnički definirana funkcija # napišite funkciju `veci` koja prima dva numerička vektora iste duljine # i vraća vektor koji sadrži veći od dva elementa na istim mjestima # ukoliko jedan ili oba vektora nisu numerički ili nisu iste duljine, # funkcija mora izbaciti grešku # u funkciji nemojte koristiti petlje # pozovite funkciju `veci` nad kombinacijama vektora # c(T, F, T) i c(1, 2, 3) # c(1, 2, 3, 4) i c(5, 6, 7) # c(1, 2, 3) i c(0, 4, 2) # (preporuka - drugi dio zadatka isprobati direktno u konzoli!) # napišite funkciju `veci` koja prima dva numerička vektora iste duljine # i vraća vektor koji sadrži veći od dva elementa na istim mjestima # ukoliko jedan ili oba vektora nisu numerički ili nisu iste duljine, # funkcija mora izbaciti grešku # u funkciji nemojte koristiti petlje veci &lt;- function(a, b) { stopifnot(is.numeric(a) &amp;&amp; is.numeric(b) &amp;&amp; length(a) == length(b)); ifelse(a &gt; b, a, b) } Kod poziva funkcije možemo ali ne moramo navesti imena parametara, a R dozvoljava miješanje imenovanih i neimenovanih parametara (iako to nije nešto što bismo trebali često koristiti u praksi). Kada R bude povezivao poslane vrijednosti sa formalnim parametrima, imenovani parametri imati će prioritet te će se prvi razriješiti, a potom će se redom razrješavati neimenovani parametri. U ovo se možemo uvjeriti u sljedećem zadatku, u kojem ćemo usput iskoristiti priliku i pokazati rad jedne vrlo često korištene funkcije - paste. Ova funkcija konkatenira znakovne nizove uz dodavanje razmaka (za spajanje bez razmaka postoji alternativna funkcija paste0). Zadatak 7.2 - parametri funkcije ispisiABC &lt;- function(a, b, c) { print(paste(&quot;A:&quot;, a, &quot;B:&quot;, b, &quot;C:&quot;, c)) } # razmislite - što ispisuje sljedeći poziv funkcije? ispisiABC(1, a = 2, 3) ispisiABC &lt;- function(a, b, c) { print(paste(&quot;A:&quot;, a, &quot;B:&quot;, b, &quot;C:&quot;, c)) } ispisiABC(1, a = 2, 3) ## [1] &quot;A: 2 B: 1 C: 3&quot; U praksi bismo se trebali držati konvencije da prvo koristimo neimenovane parametre, a potom imenovane. Uobičajeno je da postavljamo samo one imenovane parametre čija nazivna vrijednost nam ne odgovara pri čemu strogi raspored nije bitan (iako će praćenje rasporeda zadanog potpisom funkcije povećati čitljivost našeg koda). Ako želimo napisati funkciju koja prima proizvoljan broj argumenata, koristimo se elementom ..., tj. trotočkom. Primjer ovakve funkcije jest gore prikazana ugrađena funkcija paste koja može primiti proizvoljan broj znakovnih nizova. Ako koristimo trotočku u našoj funkciji, u potpisu ju u pravilu stavljamo na kraj liste argumenata, a unutar same funkcije ju potom jednostavno pretvorimo u listu te potom pristupamo njenim parametrima na način koji nam odgovara. Zadatak 7.3 - funkcija sa proizvoljnim brojem parametara ispisiParametre &lt;- function(...) { parametri &lt;- list(...) for (p in parametri) print(p) } # pozovite gornju funkciju sa proizvoljnim parametrima ispisiParametre(c(1, 2, 3), 5, T, data.frame(x = 1:2, y = c(T, F))) ## [1] 1 2 3 ## [1] 5 ## [1] TRUE ## x y ## 1 1 TRUE ## 2 2 FALSE Za kraj, prisjetimo se priče o S3 objektima i činjenice da R nema formalni sustav stvaranja i korištenja objekata, ali da se preporučuje korištenje zasebne konstruktorske funkcije koja zamjenjuje “ručno” slaganje objekta i deklariranje njegove klase. Sada kada znamo stvoriti vlastitu funkciju možemo pogledati kako bi izgledao mogući konstruktor klase Osoba. # konstruktor klase osoba Osoba &lt;- function(oib, prezime, tezina) { stopifnot(is.character(oib)) stopifnot(is.character(prezime)) stopifnot(is.numeric(tezina) &amp;&amp; tezina &gt; 0) o &lt;- list(oib = oib, prezime = prezime, tezina = tezina) class(o) &lt;- &quot;Osoba&quot; o } Pokušajmo uz pomoć prikazanog konstruktora stvoriti novi objekt klase Osoba. Zadatak 7.4 - konstruktorska funkcija # stvorite varijablu `ivo` koja će biti klase `Osoba` a koja će imati sljedeće vrijednosti atributa: # OIB: 1357135713, prezime: Ivić, tezina: 76 # ispišite varijablu `ivo` ivo &lt;- Osoba(&quot;135135713&quot;, &quot;Ivić&quot;, 76) ivo ## $oib ## [1] &quot;135135713&quot; ## ## $prezime ## [1] &quot;Ivić&quot; ## ## $tezina ## [1] 76 ## ## attr(,&quot;class&quot;) ## [1] &quot;Osoba&quot; Prednost konstruktora je dodatna robustnost u vidu točno definiranih imena atributa ali i mogućnosti ugrađivanja i dodatnih kontrola (npr. OIB i prezime moraju biti znakovni nizovi dok tezina mora biti realni broj i sl.). Ukoliko stvaramo vlastite S3 objekte, preporuka je da za njih definiramo pripadajuće konstruktorske funkcije. 7.1.1 Princip “kopiranja kod izmjene” (copy-on-modify) Jedno od češćih pitanja koje se postavlja kod učenja novih programskih jezika jest da li funkcije rade na način “poziva preko vrijednosti” (engl. call-by-value) ili “poziva preko reference” (engl. call-by-reference). Razlika se svodi na sposobnost funkcije da mijenja vrijednosti varijabli koje su poslane na mjestu formalnih argumenata funkcije; kod call-by-value principa u funkciju se šalju samo “vrijednosti” parametara, tj. “kopije” originalnih argumenata. S druge strane, kod “call-by-reference” principa funkcija prima “reference” originalnih varijabli, tj. ponaša se kao da su originalne varijable proslijeđene funkciji i sve izmjene nad njima odraziti će se u pozivajućem programu. Jezik R koristi hibridni princip poznat po nazivom “kopiranje kod izmjene” (engl. copy-on-modify). Kod ovog principa u funkciju se prosljeđuju reference argumenata, što nam omogućuje da prenosimo i “velike” varijable bez straha da će doći do nepotrebnog kopiranja. No ovo vrijedi samo ukoliko funkcija ne mijenja vrijednost dobivenih varijabli - u trenutku kada funkcija pokuša provesti bilo kakvu izmjenu, provodi se kopiranje varijable i funkcija dalje nastavlja rad na kopiji. Zbog ovoga se kaže da R kao takav ne podržava call-by-reference (jedan razlog uvođenja objekata tipa “reference classes” tj. RC objekata u jezik R upravo je uvođenje ovog principa). Provjerimo gore navedene tvrdnje na konkretnom primjeru. # pokušaj izmjene varijable iz pozivajuće okoline f &lt;- function() { cat(&quot;x u funkciji:&quot;, x, &quot;\\n&quot;) x &lt;- x + 1 cat(&quot;x nakon izmjene:&quot;, x, &quot;\\n&quot;) } x &lt;- 5 f() cat(&quot;x nakon povratka:&quot;, x, &quot;\\n&quot;) ## x u funkciji: 5 ## x nakon izmjene: 6 ## x nakon povratka: 5 Funkcija pri izvođenju stvara privremenu vlastitu okolinu unutar koje se pohranjuju “lokalne” varijable. U gornjem primjeru unutar tijela funkcije f pojavljuje se varijabla x koja “maskira” vanjsku varijablu x tako da se sve izmjene više ne odražavaju na vrijednost vanjske varijable. Važno je uočiti da funkcija pristupa vanjskoj varijabli čak i bez njenog slanja u funkciju, budući da referenciranje varijable x koja ne postoji u lokalnoj okolini funkcije R pretragu nastavio u okolini roditelju što bi u ovom slučaju bila globalna okolina. Pokušaj izmjene ove varijable ipak ne uspijeva - R detektira pokušaj izmjene varijable i stvara lokalnu kopiju istog imena. Da li ovo znači da funkcija nikada ne može mijenjati varijable iz pozivajuće okoline? Naravno da ne - jedan od načina kako ovo izvesti jest taj da funkciji pošaljemo referencu na okolinu unutar kojeg se nalazi objekt kojeg mijenjamo (ili pustimo funkciju da sama dohvati referencu na globalnu okolinu ukoliko se varijabla tamo nalazi). Zadatak 7.5 - izmjena varijable globalne okoline # implementirajte funkciju f tako da dohvati referencu na globalnu okolinu # i poveća &quot;vanjski&quot; x za 1 x &lt;- 5 # pozovite f(x) i ispisite x f &lt;- function() { e &lt;- globalenv() e$x &lt;- e$x + 1 } x &lt;- 5 f() print(x) ## [1] 6 Jednostavniji način rješavanja gornjeg zadatka bio bi korištenjem operatora &lt;&lt;-. Ovo je tzv. “operator dodjele vanjskom opsegu” (engl. scoping assignment operator), a njegova funkcija jest da izmjeni varijablu zadanog imena koja se nalazi ’negdje” na stazi pretrage. R ide sekvencijalno po stazi pretrage i mijenja prvu pojavu navedene varijable. Ukoliko varijabla tog naziva ne postoji nigdje u stazi pretrage, R će stvoriti novu varijablu u prvoj okolini iznad okoline funkcije. # operator `&lt;&lt;-` f &lt;- function(x) { x &lt;&lt;- 7 x &lt;- 6 } x &lt;- 5 f() x ## [1] 7 Ovaj operator je potencijalno nepredvidiv tako da ćemo veću robusnost ipak postići korištenjem funkcije assign ili operatora $ uz referencu na okolinu gdje se nalazi varijabla koju želimo mijenjati. Za kraj spomenimo samo jedno svojstvo funkcija u R-u - tzv. “lijena evaluacija” (engl. lazy evaluation). Ovo jednostavno znači da R neće evaluirati primljeni parametar sve do trenutka kada ga eksplicitno koristimo. Do tog trenutka taj objekt je tzv. “obećanje” (engl. promise) - R “zna” kako evaluirati taj objekt ali to ne radi dok zaista ne treba a do tada imamo samo njegovo obećanje da će to učiniti :) . Na ovaj način povećava se učinkovitost jezika; ako se neki parametar koristi samo u nekoj uvjetnoj grani, onda se u scenarijima kada on nije potreban neće na njega trošiti memorija. No isto tako, moramo biti oprezni jer lijena evaluacija može dovesti do neočekivanih problema ako ne vodimo računa o njenom postojanju. 7.1.2 Funkcija kao objekt Već smo rekli da R ima kvalitetnu podršku za tzv. “funkcionalno programiranje” što predstavlja programsku paradigmu koja naglasak stavlja na dizajniranje funkcija bez oslanjanja na objekte sa izmjenjivim stanjima. Jedna od karakteristika ovakvih jezika su i tzv. “funkcije prve klase” (engl. first class functions), što zapravo znači da jezik podržava definiciju funkcija na način da su one ravnopravni objekti svim drugim tipovima objekata - mogu se pohraniti u varijablu, koristiti kao ulazni argument druge funkcije ili kao njezina povratna vrijednost, pohranjivati u druge podatkovne strukture i sl. Iako koncepti funkcionalnog programiranja izlaze iz okvira gradiva kojeg želimo prikazati, činjenicu da R tretira funkcije kao sve druge objekte je vrlo važno znati budući da se ova činjenica iznimno često koristi kod programiranja u jeziku R. Pokažimo ovo na trivijalnom primjeru. Znamo da R nudi funkciju sum unutar paketa base koja računa aritmetičku sumu elemenata vektora koje joj proslijedimo. No sum je zapravo ime varijable koja referencira kod koji implementira dotičnu funkciju. Ukoliko želimo, možemo vrlo lako pridružiti ovu funkciju nekoj drugoj varijabli čime smo joj efektivno “promijenili ime” ili bolje reći dodali alternativni način pozivanja iz potpuno druge okoline. zbroji &lt;- sum zbroji(1:10) # isto kao sum(1:10) Ovo je najlakše shvatiti na način da je funkcija jednostavno “varijabla koja se može pozvati”, pri čemu pod “pozivom” smatramo korištenje sintakse koja uključuje referencu na funkciju i ulazne argumente uokvirene u zagrade, a koja će nakon izvršavanja u R okolini vratiti nekakvu vrijednost. Funkcija može uredno vraćati i neku drugu funkciju. stvoriteljFje &lt;- function() { f &lt;- function(x) x + 1 return(f) } novaFja &lt;- stvoriteljFje() # dobili smo funkciju &quot;dodavanja jedinice&quot; novaFja(5) ## [1] 6 Funkcija je jednostavno stvorila novu funkciju i vratila ju pozivajućem programu kao što bi učinila sa bilo kojim drugim objektom. Povratnu vrijednost spremili smo u varijablu koja je sad “pozivljiva” - ako joj dodamo zagrade i parametre ona će se izvršiti na način na koji je definirana unutar funkcije koja ju je stvorila. Uočite da smo mogli iskoristiti činjenicu da funkcija vraća rezultat zadnjeg izraza i funkciju definirati i kraće: #kraća definicija stvoriteljFje &lt;- function() { function(x) x + 1 } Ovakve funkcije često se zovu i “tvornicama” ili “generatorima” funkcija, a za razliku od gornjeg primjera u praksi generatoru funkcija često šaljemo i neke parametre koji određuju kako će se vraćena funkcija ponašati. Pokušajte samostalno napraviti generator funkcija koji vraća funkcije za množenje sa unaprijed postavljenim parametrom. Zadatak 7.6 - generator funkcija # stvorite funkciju `tvornicaMnozenja` koja stvara funkcije množenja primljenog broja # sa nekom predefiniranom konstantom # uz pomoć gornje funkcije napravite funkciju `puta2` koja udvostručuje primljeni broj # pozovite funkciju `puta2` s parametrom 3 i ispišite rezultat # stvorite funkciju `tvornicaMnozenja` koja stvara funkcije množenja primljenog broja # sa nekom predefiniranom konstantom tvornicaMnozenja &lt;- function(x) { function(a) a*x } # uz pomoć gornje funkcije napravite funkciju `puta2` koja udvostručuje primljeni broj puta2 &lt;- tvornicaMnozenja(2) # pozovite funkciju `puta2` s parametrom 3 i ispišite rezultat puta2(3) ## [1] 6 Funkcija tvornicaMnozenja zapravo stvara “porodicu” funkcija koje sve pružaju mogućnost množenja sa odabranim brojem - tj. parametrom kojeg odabire sam programer. Ovakav način upravljanja funkcijama je možda inicijalno zbunjujući, no korištenjem istoga u praksi (što ćemo prikazati već u idućem poglavlju) lako se uočava dodatna fleksibilnost i učinkovitost ovakvog pristupa. Ako definiramo funkciju, a ne pridružimo ju nekoj varijabli, onda smo stvorili tzv. “anonimnu funkciju”. # anonimna funkcija function(x) x * x Uočimo da je svaka funkcija inicijalno “anonimna”. Ako se vratimo na sintaksu definicije funkcije, vidimo da je ona zapravo kombinacija stvaranja anonimne funkcije i pridjeljivanja iste nekoj varijabli uz operator pridruživanja. Naravno, ostavljanje funkcije anonimnom kao što smo izveli u gornjem primjeru nema previše smisla, isto kao što nema smisla definirati neki vektor ili listu bez pridjeljivanja reference na taj objekt - u tom slučaju stvoreni objekt nije ni na koji način iskoristiv jer nema nijedne poveznice prema njemu te će ga R vrlo brzo obrisati u sklopu rutine “čišćenja smeća”. Možemo se zapitati - kako onda izgleda scenarij gdje je korištenje anonimne funkcije smisleno i korisno? Eksplicitne anonimne funkcije koristimo kada nam dobro dođe “jednokratna” funkcija, recimo kao argument neke druge funkcije. Ako je funkciju koju želimo poslati kao argument lako definirati u jednom retku, a ne planiramo ju više koristiti u programu, onda nema smisla zasebno ju definirati i dodijeliti joj vlastitu referencu. Primjer ovoga vidjet ćemo u lekciji o apply porodici funkcija. Za kraj ovog dijela ponovimo najbitnije stvari - u R-u je funkcija objekt kao i svaki drugi, jedina specifičnost jest da se radi o objektu koji je “izvršiv”, tj. koji uz korištenje sintakse za poziv funkcije obavlja neki posao i vraća neku vrijednost. Čak i anonimnu funkciju možemo bez problema izvršiti (iako samo jednom, budući da nemamo referencu za njezino ponovno zvanje). # anonimna funkcija s pozivom (function(x) x + 1)(2) ## [1] 3 7.2 Generičke funkcije Generičke funkcije već smo spominjali u poglavlju o objektima no svejedno se kratko podsjetimo o čemu se zapravo radi. Programski jezik R svoje objektno orijentirane principe ne temelji na takozvanom “principu razmjene poruka” gdje bi npr. poziv za crtanje grafa mogao izgledati ovako: # uobičajeni OOP princip poziva metode objekta graf.crtaj() već ovako: # R-ovski princip poziva metode objekta crtaj(graf) U prvom slučaju graf je objekt koji implementira posebnu metodu za crtanje te koju moramo pozvati kako bi dobili traženu sliku grafa. U drugom postoji “vanjska” funkcija koja “zna” nacrtati graf. Ovu funkciju nazivamo generička funkcija. Općenita svojstva generičke funkcije su sljedeća: funkcija ima intuitivnu, jasno određenu svrhu očekivani način rada sličan je za više tipova objekata (npr. crtanje će rezultirati slikom) svaki tip objekta zahtjeva vlastitu implementaciju ovisno o karakteristikama objekta (npr. način crtanja kruga se razlikuje se od načina crtanja kvadrata) Način implementacije generičkih funkcija (za S3 objekte!) zapravo je iznimno jednostavan, što je vjerojatno i razlog njihove široke prihvaćenosti i velike popularnosti u R zajednici. Postupak se svodi na tri jednostavna koraka: izaberemo naziv generičke funkcije (npr. ispisi) i deklariramo da se radi o generičkoj funkciji alternativno, odaberemo neku od postojećih generičkih funkcija stvorimo objekt i deklariramo njegovu klasu (npr. Osoba) implementiramo funkciju naziva ime_gen_fje.ime_klase (npr. ispisi.Osoba) I to je sve! R ne zahtjeva nikakve dodatne korake, gore navedeno je sasvim dovoljno da R prepoznaje novu generičku funkciju i da ju primjenjuje na sve objekte za čiju klasu je implementirana ta generička funkcija u obliku ime_gen_fje.ime_klase (ili ime_gen_fje.default za sve klase za koje ne postoji posebna implementacija). Pokušajmo u sljedećem zadatku implementirati generičku metodu ispisi za objekt klase Osoba. Zadatak 7.7 - nova generička funkcija pero &lt;- Osoba(oib = &quot;12345678&quot;, prezime = &quot;Peric&quot;, tezina = 78) # stvaramo novu generičku funkciju `ispisi` uz pomoć funkcije `UseMethod` ispisi &lt;- function(x) UseMethod(&quot;ispisi&quot;) # implementirajte funkciju naziva `ispisi.Osoba` koja prima jedan parametar (očekivano klase `Osoba`) # te na zaslon ispisuje podatke o osobi na sljedeći način: # OIB: &lt;oib&gt;, Prezime: &lt;prezime&gt;, tezina: &lt;tezina&gt; # za slaganje ispisa koristite funkciju `paste` # a za sam ispis funkciju `cat` # implementirajte funkciju naziva ispisi.default koja prima jedan parametar # i ispisuje ga na zaslon uz pomoć funkcije `cat` # ispišite varijablu `pero` uz pomoć generičke funkcije `ispisi` # ispišite vektor c(1, 2, 3, 4, 5) uz pomoć generičke funkcije `ispisi` # implementirajte funkciju naziva `ispisi.Osoba` koja prima jedan parametar (očekivano klase `Osoba`) # te na zaslon ispisuje podatke o osobi na sljedeći način: # OIB: &lt;oib&gt;, Prezime: &lt;prezime&gt;, tezina: &lt;tezina&gt; # za slaganje ispisa koristite funkciju `paste` # a za sam ispis funkciju `cat` ispisi.Osoba &lt;- function(o) { rez &lt;- paste(&quot;OIB:&quot;, o$oib, &quot;, Prezime:&quot;, o$prezime, &quot;, tezina:&quot;, o$tezina, &quot;\\n&quot;) cat(rez) } # implementirajte funkciju naziva ispisi.default koja prima jedan parametar # i ispisuje ga na zaslon uz pomoć funkcije `cat` ispisi.default &lt;- function(x) cat(x) # ispišite varijablu `pero` uz pomoć generičke funkcije `ispisi` ispisi(pero) # ispišite vektor c(1, 2, 3, 4, 5) uz pomoć generičke funkcije `ispisi` ispisi(1:5) ## OIB: 12345678 , Prezime: Peric , tezina: 78 ## 1 2 3 4 5 Naravno, nismo morali nužno stvoriti vlastitu funkciju ispisi - vjerojatno bi bolji odabir bio korištenje već postojećih generičkih funkcija kao to su print ili cat. Zadatak 7.8 - korištenje postojećih generičkih funkcija # provjerite da li je print generička funkcija # (jednostavno ispišite njezin izvorni kod navođenjem samog imena funkcije) # omogućite ispis klase `Osoba` uz pomoć generičke funkcije `print` # (možete se poslužiti funkcijom iz prethodnog zadatka) # ispišite varijablu `Pero` uz pomoć generičke funkcije `print` # provjerite da li je print generička funkcija # (jednostavno ispišite njezin izvorni kod navođenjem samog imena funkcije) print # omogućite ispis klase `Osoba` uz pomoć generičke funkcije `print` # (možete se poslužiti funkcijom iz prethodnog zadatka) print.Osoba &lt;- ispisi.Osoba # ispišite varijablu `Pero` uz pomoć generičke funkcije `print` print(pero) ## function (x, ...) ## UseMethod(&quot;print&quot;) ## &lt;bytecode: 0x000001850e3b5848&gt; ## &lt;environment: namespace:base&gt; ## OIB: 12345678 , Prezime: Peric , tezina: 78 Za kraj, prikažimo mogućnost R-a da nam izlista sve trenutno poznate implementacije neke generičke metode. Za to se jednostavno koristimo funkcijom methods kojoj proslijedimo ime dotične metode. Istom funkcijom možemo i provjeriti koje sve implementacije generičkih funkcija postoje za određenu klasu. Za to koristimo parametar class kojem prosljeđujemo naziv klase za koju tražimo spomenute implementacije. Zadatak 7.9 - funkcija methods # prikažite sve do sad poznate implementacije generičke funkcije `summary` # provjerite koje sve implementacije generičkih funkcija postoje za klasu `factor` # prikažite sve do sad poznate implementacije generičke funkcije `summary` #methods(summary) # probati na konzoli cat(&quot;-----------------------\\n&quot;) # provjerite koje sve implementacije generičkih funkcija postoje za klasu `factor` methods(class = &quot;factor&quot;) ## ----------------------- ## [1] - / [ [[ [[&lt;- ## [6] [&lt;- + all.equal Arith as.character ## [11] as.data.frame as.Date as.duration as.interval as.list ## [16] as.logical as.period as.POSIXlt as.vector as_date ## [21] as_datetime as_factor brief c cbind2 ## [26] coerce Compare corresp droplevels fixed ## [31] format gausspr histogram initialize inlearn ## [36] is.na&lt;- kqr kronecker ksvm length&lt;- ## [41] levels&lt;- Logic lssvm Math Ops ## [46] output_column plot print rbind2 recode ## [51] relevel relist rep rvm scale_type ## [56] show slotsFromS3 summary Summary type_sum ## [61] xtfrm ## see &#39;?methods&#39; for accessing help and source code 7.3 Što su apply funkcije? Vrlo često se poznavanje osnova jezika R procjenjuje znanjem korištenja tzv. apply porodice funkcija dostupnih u paketu base. Ove funkcije specifično su dizajnirane za provođenje repetitivnih zadataka nad skupovima podataka i kao takve zamjenjuju programsku logiku koja bi se u nekom drugom jeziku realizirala programskom petljom. Dodatno, ove funkcije u pravilu primaju druge funkcije kao ulazne argumente i tako u izvjesnoj mjeri potiču paradigmu funkcionalnog programiranja. Naziv porodice potiče od činjenice da funkcije iz nje imaju sufiks “apply”. Neke funkcije iz ove porodice su: apply lapply sapply vapply tapply, mapply, rapply… Sve ove funkcije rade na sličan način - kao ulazne argumente primaju skup podataka, funkciju koju želimo primijeniti na elemente tog skupa te opcionalne dodatne parametre, a kao izlaz daju skup rezultata funkcije, najčešće “upakirane” u prigodni format. Razlika se uglavnom svodi na tipove ulaznih i izlaznih argumenata, te konkretne detalje oko provedbe same funkcije i/ili pripreme rezultata. Ovu porodicu funkcija najlakše je upoznati preko primjera. Započnimo sa “osnovnom” funkcijom - apply. 7.3.1 Funkcija apply Funkcija apply jedina je koja doslovno dijeli ime sa porodicom ovih funkcija. Namijenjena je radu s matricama (zapravo sa poljima, ali budući da se relativno rijetko radi sa strukturama koje imaju više od dvije dimenzije, ovdje ćemo se usredotočiti samo na matrice). Sintaksa naredbe je sljedeća: rezultat &lt;- apply( &lt;matrica&gt;, &lt;redovi (1) ili stupci (2)&gt;, &lt;funkcija&gt; ) Ili, opisano riječima, za provođenje funkcije apply: odaberemo matricu odlučimo se da li ju “režemo” po retcima ili stupcima primjenjujemo odabranu funkciju na svaki redak (ili stupac) Ovisno o tome što funkcija radi, kao rezultat dobivamo matricu ili (što je češći slučaj) vektor. Pokušajmo primijeniti ovu funkciju na konkretnom primjeru. Zadatak 7.10 - funkcija apply m &lt;- matrix(1:9, nrow = 3, ncol = 3, byrow = TRUE) # ispišite matricu `m` # uz pomoć funkcije `apply` izračunajte # i ispišite zbrojeve stupaca matrice `m` # uz pomoć funkcije `apply` izračunajte # i ispišite umnoške redaka matrice `m` m cat(&quot;------------\\n&quot;) # za pregledniji ispis apply(m, 2, sum) cat(&quot;------------\\n&quot;) apply(m, 1, prod) ## [,1] [,2] [,3] ## [1,] 1 2 3 ## [2,] 4 5 6 ## [3,] 7 8 9 ## ------------ ## [1] 12 15 18 ## ------------ ## [1] 6 120 504 Ukoliko želimo nad retcima / stupcima provesti neki specifičan zadatak, za to vrlo često koristimo anonimnu funkciju, npr: apply(m, 1, function(x) x[1]) # izvlačimo prvi element svakog retka Zadatak 7.11 - funkcija apply i anonimne funkcije # uz pomoć funkcije `apply` za svaki redak matrice `m` # izračunajte prirodni logaritam sume elemenata # zaokružen na 2 decimale (funkcija `round`!) apply(m, 1, function(x) round(log(sum(x)),2)) ## [1] 1.79 2.71 3.18 Ponovimo - funkcija apply (i srodne funkcije) implicitno “rastavljaju” ulaznu podatkovnu strukturu na elemente. U primjerima gore ti elementi - retci ili stupci - su zapravo numerički vektori. Argument x kojeg prima anonimna funkcija je upravo taj vektor, ili bolje reći svaki od tih vektora koji joj se prosljeđuju jedan po jedan. Rezultati funkcije se “pamte” i “pakiraju” u konačni rezultat. Pokušajmo isprogramirati zadnji primjer bez korištenja funkcije apply. Zadatak 7.12 - petlja kao alternativa funkciji apply # uz pomoć programske petlje za svaki redak matrice `m` # izračunajte prirodni logaritam sume elemenata # zaokružen na 2 decimale (funkcija `round`!) rez &lt;- numeric(nrow(m)) for (i in 1:nrow(m)) rez[i] &lt;- round(log(sum(m[i,])), 2) rez ## [1] 1.79 2.71 3.18 Ako usporedimo sintakse primjera sa i bez korištenja funkcije apply, možemo se uvjeriti koliko je sintaksa koja koristi apply zapravo “čišća” i jasnija. Ako koristimo petlje moramo eksplicitno navesti logiku prolaženja strukturom i čuvanja međurezultata, što odvlači pažnju od opisa posla kojeg zapravo želimo obaviti. Što ako apply funkciji želimo proslijediti više parametara? Npr. recimo da umjesto gornje funkcije koja izvlači prvi element retka želimo funkciju sa dva parametra - prvi je vektor a drugi cijeli broj koji označava koji broj treba izvući. Odgovor je jednostavan - dodatne parametre jednostavno navedemo na kraju poziva funkcije. # apply funkcija i ulazna funkcija sa više parametara apply(m, 1, function(x,y) x[y], 2) # izvlačimo drugi element svakog retka Konačno, treba napomenuti da za sličnu obradu podataka u matričnom obliku ne moramo nužno koristiti apply - dosta popularnih operacija kao što su zbrajanje elemenata redaka ili stupaca, računanje prosjeka elemenata redaka i stupaca i sl. već je implementirano kroz funkcije kao što su rowSums, colSums, rowMeans, colMeans i sl. One su jednostavnije za uporabu, no specijalizirane - za dodatnu fleksibilnost najčešće je apply najpogodnija opcija. 7.3.2 Funkcije lapply, sapply i vapply Ime funkcije lapply dolazi od “list apply” - tj. apply funkcija koja radi sa listama. Jednostavno - radi se o funkciji koja će kao ulazni argument primiti listu i neku funkciju, primijeniti funkciju na svaki pojedini element liste i vratiti opet rezultat u obliku liste. Zadatak 7.13 - funkcija lapply l &lt;- list(a = 1:3, b = rep(c(T, F), 10), c = LETTERS) # pomoću funkcije `lapply` izračunajte duljinu (broj elemenata) # svakog elementa liste `l` lapply(l, length) ## $a ## [1] 3 ## ## $b ## [1] 20 ## ## $c ## [1] 26 Isto kao kod funkcije apply, kod funkcije lapply često kao parametar koristimo anonimne funkcije. Sljedeći zadatak nema posebnu praktičnu uporabu, ali će nam pomoći da shvatimo funkcioniranje funkcije lapply te usvojimo činjenicu kako anonimne funkcije ne moraju nužno biti kratke i jednostavne. Zadatak 7.14 - funkcija lapply i anonimne funkcije # obradite elemente liste `l` na sljedeći način: # - izračunajte srednju vrijednost ako se radi o numeričkom vektoru # - prebrojite vrijednosti TRUE ako se radi o logičkom vektoru # - ispišite duljinu vektora za sve ostale slučajeve # koristite funkciju `lapply` i anonimnu funkciju # ne zaboravite da i anonimna funkcija može koristiti blokove! # obradite elemente liste `l` na sljedeći način: # - izračunajte srednju vrijednost ako se radi o numeričkom vektoru # - prebrojite vrijednosti TRUE ako se radi o logičkom vektoru # - ispišite duljinu vektora za sve ostale slučajeve # koristite funkciju `lapply` i anonimnu funkciju # ne zaboravite da i anonimna funkcija može koristiti blokove! lapply(l, function(x) { if (is.numeric(x)) { mean(x) } else if (is.logical(x)) { sum(x) } else length(x) }) ## $a ## [1] 2 ## ## $b ## [1] 10 ## ## $c ## [1] 26 Funkcija lapply je u suštini dosta jednostavna za korištenje i baš zbog te činjenice vrlo popularna. No nakon što ju koristimo jedno vrijeme može nas zasmetati činjenica da ona uvijek kao rezultat vraća listu, iako bi nam nekad više odgovarala neka druga podatkovna struktura, kao npr. vektor, pogotovo ako rezultantna lista ima kao elemente jednostavne brojeve. Upravo iz ovog razloga R nudi funkciju unlist za “pojednostavljivanje” liste u vektor ako ona sadrži jednostavne elemente. Zadatak 7.15 - funkcija unlist l &lt;- list(a = 1:10, b = 10:20, c = 100:200) # izračunajte srednje vrijednosti elemenata liste `l` # rezultate ispišite kao numerički vektor # koristite lapply i unlist unlist(lapply(l, mean)) ## a b c ## 5.5 15.0 150.0 Prikazana kombinacija lapply i unlist će nam kao rezultat dati jednodimenzionalni vektor, što nam u velikom broju slučajeva odgovara. No ponekad bi nam više odgovarala neka druga podatkovna struktura - npr. matrica. U ovom slučaju potreban nam je i dodatni korak preoblikovanja jednodimenzionalnog vektora u matricu uz pomoć funkcije matrix, pri čemu moramo eksplicitno zadati broj redaka i stupaca. Može se postaviti pitanje - zašto funkcija lapply ne bi mogla “pogledati” rezultat kojeg je dobila i sama odrediti optimalnu podatkovnu strukturu za oblikovanje rezultata (vektor, matrica ili lista)? Upravo je to ideja iza funkcije sapply, ili “simplified list apply”. Ova funkcija prvo interno obavlja lapply, a potom se rezultat pojednostavljuje na vektor, matricu ili polje, ovisno o karakteristikama dobivenih rezultata. Zadatak 7.16 - funkcija sapply l &lt;- list(a = 1:10, b = 10:20, c = 100:200) # izračunajte medijane elemenata liste `l` # i rezultate ispišite kao numerički vektor # koristite funkciju `sapply` # izvucite prvi i zadnji element svakog od elemenata liste `l` # koristite `sapply` i anonimnu funkciju sapply(l, median) cat(&quot;------------\\n&quot;) # za pregledniji ispis sapply(l, function(x) c(x[1], x[length(x)])) ## a b c ## 5.5 15.0 150.0 ## ------------ ## a b c ## [1,] 1 10 100 ## [2,] 10 20 200 Uočite da smo kao rezultat zadnjeg primjera dobili matricu, ali da ju je R oblikovao “po stupcima”. Ukoliko bismo htjeli matricu sa elementima poredanim po retcima, za to nažalost ne možemo koristiti sapply jer se matrica formira interno, bez mogućnosti prosljeđivanja parametra byrow = T. Za dobivanje takve matrice jedna opcija nam je već spomenuta kombinacija funkcija lapply, unlist i matrix ili - što je jednostavnije - transponiranje rezultata sapply uz pomoć funkcije t (od engl. transpose). Funkcija sapply je prilično omiljena zbog svoje jednostavnosti i učinkovitosti tako da se relativno često koristi u interaktivnoj analizi. S druge strane, korištenje ove funkcije u programskim skriptama se ne preporučuje budući da je rezultat u općenitom slučaju nepredvidiv - npr. skripta može u nastavku programskog koda očekivati matricu, a funkcija sapply je zbog specifičnosti ulaznih podataka vratila vektor, što može uzrokovati nepredviđene rezultate u nastavku skripte a što nije lako naknadno uočiti te dijagnosticirati gdje je nastala greška. Ukoliko razvijamo vlastite programe u R-u i želimo koristiti sapply, onda će nam bolji izbor predstavljati funkcija vapply (od engl. “verified sapply”) koja radi identično funkciji sapply, ali koristi dodatni parametar nazvan FUN.VALUE pomoću kojeg eksplicitno definiramo kakvo “pojednostavljenje” očekujemo. Npr. numeric(3) znači da bi rezultat primjene funkcije na svaki element originalne liste trebao biti numerički vektor od tri elementa. Ukoliko se rezultat za bilo koji element liste razlikuje od očekivanog, funkcija će izbaciti grešku. Zadatak 7.17 - funkcija vapply podaci &lt;- list(brojevi &lt;- c(1:5), imena &lt;- c(&quot;Ivo&quot;, &quot;Pero&quot;, &quot;Ana&quot;), abeceda &lt;- LETTERS) # razmislite koji će od sljedećih poziva biti uspješan, # a koji će izbaciti grešku # rezultate provjerite na konzoli vapply(podaci, length, FUN.VALUE = numeric(1)) vapply(podaci, function(x) as.character(c(x[1], x[2])), FUN.VALUE = character(2)) vapply(podaci, function(x) as.logical(x), FUN.VALUE = character(1)) Konačno, vratimo se nakratko funkciji lapply i razmotrimo jednu bitnu činjenicu - ona je namijenjena uporabi nad listama, a podatkovni okviri su zapravo liste. Drugim riječima, funkcija lapply je vrlo zgodna za obradu tabličnih podataka kada želimo određenu funkciju primijeniti na stupce podatkovnog okvira. Jedna od češćih operacija koje se provode kod analize podataka jest tzv. “normalizacija” numeričkih stupaca podatkovnog okvira - tj. svođenje svih numeričkih vrijednosti na “normalnu” distribuciju aritmetičke sredine 0 i standardne devijacije 1. Ovo možemo uraditi tako da svaku pojedinu vrijednost umanjimo za aritmetičku sredinu stupca (funkcija mean) te podijelimo sa standardnom devijacijom stupca (funkcija sd). Ovo je odličan scenarij za demonstraciju korištenja funkcije lapply. Zadatak 7.18 - funkcija lapply i podatkovni okviri df &lt;- data.frame( a = 1:10, b = seq(100, 550, 50), c = LETTERS[1:10], d = rep(c(T,F), 5), e = -10:-1) # normalizirajte numeričke stupce uz pomoć funkcije `lapply` # ostale stupce nemojte mijenjati # normalizirane vrijednosti zaokružite na tri decimale # rezultat pohranite u varijablu df # ispišite df df &lt;- lapply(df, function(x) { if (is.numeric(x)) { round((x - mean(x))/sd(x), 3) } else x }) df ## $a ## [1] -1.486 -1.156 -0.826 -0.495 -0.165 0.165 0.495 0.826 1.156 1.486 ## ## $b ## [1] -1.486 -1.156 -0.826 -0.495 -0.165 0.165 0.495 0.826 1.156 1.486 ## ## $c ## [1] &quot;A&quot; &quot;B&quot; &quot;C&quot; &quot;D&quot; &quot;E&quot; &quot;F&quot; &quot;G&quot; &quot;H&quot; &quot;I&quot; &quot;J&quot; ## ## $d ## [1] TRUE FALSE TRUE FALSE TRUE FALSE TRUE FALSE TRUE FALSE ## ## $e ## [1] -1.486 -1.156 -0.826 -0.495 -0.165 0.165 0.495 0.826 1.156 1.486 Vidimo da smo nakon korištenja lapply dobili listu te da ukoliko želimo rezultat u obliku podatkovnog okvira moramo dodati još jedan korak korištenja funkcije as.data.frame. Ukoliko tražimo jednostavniji način koji odmah daje podatkovni okvir kao rezultat, postoji jedan zgodan “trik” kojeg ćemo objasniti u nastavku. Pogledajmo rješenje prethodnog zadatka, konkretno red gdje rezultat poziva funkcije lapply pohranjujemo u varijablu df koji se sastoji u tome da umjesto pridruživanja rezultata samoj varijabli (df &lt;-) rezultat pridružimo varijabli sa “praznim” operatorom indeksiranja (df[] &lt;-): df[] &lt;- lapply(...) Na ovaj način R neće napraviti “novu” varijablu imena df, već će rezultat funkcije lapply upisati u “sve retke i stupce okvira df”. Time smo postigli da smo umjesto liste rezultat dobili u obliku podatkovnog okvira, što smo zapravo i htjeli. Upravo zbog ovoga vrlo često ćemo u R skriptama vidjeti sličnu sintaksu (df[] &lt;- lapply...). Pokušajte preinačiti gornji primjer na navedeni način i uvjerite se da će rezultat biti podatkovni okvir. Još jedan često korišteni trik u radu sa podatkovnim okvirima i funkcijama iz porodice apply jest sljedeća naredba: sapply(df, class) Ova naredba nam zapravo daje odgovor na pitanje - kojeg su tipa stupci navedenog podatkovnog okvira? Iako postoje i drugi načini da dođemo do ove informacije, ovaj način popularan je kako zbog kompaktnosti rezultata, tako i neovisnosti o dodatnim paketima. 7.3.3 Ostale funkcije iz porodice apply i dostupne alternative U prethodnim poglavljima naveli smo vjerojatno najpopularnije članove porodice apply. Ova porodica broji još članova, uključujući i neke koji nemaju sufiks -apply: mapply, koja primjenjuje funkcije paralelno nad više podatkovnih struktura rapply, koja rekurzivno primjenjuje funkcije unutar strukture tapply, koja primjenjuje funkcije nad podskupovima unutar strukture definirane faktorima Map, inačica mapply koja ne pojednostavljuje rezultat by, inačica tapply predviđena za podatkovne okvire itd. Razlog zašto ove funkcije nećemo detaljno obrađivati jest dvojak: prvo, kao što je već rečeno, ove funkcije se u praksi primjenjuju puno rjeđe od funkcija koje smo prikazali u prethodnim poglavljima. Drugo, porastom popularnosti jezika R pojavio se i veliki broj paketa orijentiranih upravo poboljšanju postojećih funkcija jezika R u smislu lakšeg i učinkovitijeg programiranja, poglavito u radu s podatkovnim okvirima. Ukoliko tražimo zgodne alternative funkcijama iz porodice apply, preporučuje se pogledati neke od sljedećih paketa plyr - iznimno popularan paket koji između ostalog nudi niz funkcija vrlo srodnih apply¸funkcijama, ali izvedenih na način da imaju konzistentan potpis te eksplicitno definirane ulazne i izlazne oblike koji se lako čitaju iz samog imena funkcije (konkretno, prvih slova); tako funkcija llply kao ulaz prima te kao izlaz daje listu, dok funkcija mdply kao ulaz prima matricu a kao izlaz daje podatkovni okvir purrr - paket koji zamjenjuje funkcije porodice apply sa funkcijama koje odgovaraju sličnim funkcijama iz drugih programskih jezika za funkcijsko programiranje; budući da se primjena iste funkcije na niz elemenata neke podatkovne strukture u funkcijskim jezicima često zove “mapiranje”, niz funkcija ovog paketa nosi prefiks map_ a imena funkcija često odgovaraju očekivanim rezultatima (npr. map2_lgl znači da kao rezultat očekujemo logički vektor, a map2_df podatkovni okvir) dplyr - relativno novi paket koji u izvjesnom smislu predstavlja “nasljednika” paketa plyr za rad sa podatkovnim okvirima; funkcije ovog paketa nisu toliko orijentirane zamjeni funkcijama porodice apply koliko pružanju svojevrsne platforme za rad sa podatkovnim okvirima na način sličan jezicima domenski orijentiranim upravo za tu svrhu, kao što je npr. jezik SQL U lekciji o upravljanju podatkovnim skupovima upoznati ćemo se upravo sa paketom dplyr, upravo zbog činjenice da ovaj paket uvelike olakšava i ubrzava proces analize podataka te je iznimno dobro prihvaćen u R zajednici. Zadaci za vježbu R ima funkciju which koja pretvara logički vektor u numerički sa rednim brojevima elemenata koji su TRUE (tako c(T, F, F, F, F, T, F, T) postaje c(1, 6, 8)). Implementirajte vlastitu inačicu ove funkcije. Uzmimo numerički vektor x duljine n. U statistici standardiziranim momentom k-tog reda zovemo vrijednost: \\[\\frac{1}{n}\\sum_{i=1}^n{(x_i - \\bar{x})}^{k+1}\\] Stvorite generator funkcija moment(k) koji će stvarati funkcije za računanje standardiziranog centralnog momenta k-tog reda. Stvorite funkcije nulti_moment(x) i prvi_moment(x) sa vrijednosti parametra k redom 0 i 1. Testirajte funkcije na vektoru 1:1000. Usporedite rezultate koje daje funkcija sd (standardna devijacija) nad vektorom 1:1000 i korijen rezultata funkcije prvi_moment nad istim vektorom. Uzmimo matricu m stvorenu sljedećom naredbom: m &lt;- rbind(1:5, seq(2, 10, 2), rep(3, 5), 3:7, seq(100, 500, 100)) Uz pomoć funkcije apply i nove anonimne funkcije stvorite vektor koji će sadržavati prvi parni element svakog retka, ili nulu ako pripadajući redak nema parnih elemenata. Sljedeće naredbe stvoriti će listu od 100 elemenata gdje će svaki element biti numerički vektor nasumične duljine od 1 do 10. #set.seed(JMBAG) # otkomentirati i zamijeniti svojim JMBAG-om lista &lt;- replicate(100, sample(1:10, sample(1:10, 1))) Uz pomoć funkcija lapply / sapply (i dodatnih naredbi ako je potrebno) stvorite: numerički vektor v sa duljinama elemenata liste listu l sa normaliziranim numeričkim vektorima originalne liste numerički vektor ind sa indeksima svih elemenata liste koji sadrže broj 4 podatkovni okvir df5 koji kao stupce sadrži sve elemente liste duljine 5 Programirajmo u R-u by Damir Pintar is licensed under a Creative Commons Attribution-NonCommercial-NoDerivatives 4.0 International License.Based on a work at https://ratnip.github.io/FER_OPJR/ "],["objekti.html", "8 Objektni modeli 8.1 Objektni modeli u jeziku R 8.2 Pomoćni paket sloop 8.3 Pregled objektnog modela S3 8.4 Implementacija generičke funkcije 8.5 Kratki pregled S4 objekata Zadaci za vježbu", " 8 Objektni modeli 8.1 Objektni modeli u jeziku R Kako bismo objasnili što su zapravo generičke funkcije, moramo se vratiti na priču o programskim paradigmama i činjenici da je R dizajniran kao objektno orijentirani jezik, zajedno sa mehanizmima koje objektno orijentirana paradigma nalaže - enkapsulacija (združivanje različitih varijabli u zajedničku cjelinu), polimorfizam (korištenje iste funkcije nad različitim objektima rezultira različitim operacijama ovisno o prirodi objekta) i nasljeđivanje (izvođenje novih objekata iz postojećih na način da ih proširujemo dodatnim elementima). R je svoj inicijalni način modeliranja objekata preuzeo iz jezika S te su stoga takvi objekti poznati kao “S3 objekti” (prema inačici jezika S iz koje su originalno preuzeti). Ovaj način, kojeg ćemo upoznati u nastavku, zapravo je vrlo nekonvencionalan i jednostavan no kao takav i prilično podoban za korištenje R-a kao primarno domenski orijentiranog jezika. Uplivom sve većeg broja programera u R zajednicu rastao je i pritisak da se u R uvede podrška za objekte koja će biti sličnija načinu kako njima upravljaju drugi programski jezici, a koja bi povećala robustnost kod dizajna i upravljanja objektima. Sve je to dovelo do toga da danas formalno imamo čak četiri tipa objekata u programskom jeziku R: osnovni objekti (base classes) - osnovni, “bazični” elementi jezika R (funkcije, vektori, podatkovni okviri) S3 objekti - princip dizajna objekata preuzet iz jezika S (inačica 3) S4 objekti - formalniji i rigorozniji način stvaranja objekata koji se približava standardnim objektno-orijentiranim mehanizmima iz drugih jezika RC objekti (reference classes) - najnoviji način stvaranja objekata (uveden u inačici R 2.12) koji u potpunosti replicira “klasične” objektno-orijentirane principe utemeljene na razmjeni poruka Postojanje tri različita modela definiranja objekata (možemo zanemariti osnovni budući da njega formalno ne možemo “proširivati” novim objektima) može djelovati demotivirajuće - da li je potrebeno naučiti sva tri modela? Kako ih razlikovati? Koji odabrati? No usprkos činjenici da se priča o objektnoj prirodi jezika R tijekom njegova razvoja (nepotrebno) zakomplicirala, dobra vijest je ta da je za većinu potreba sasvim dovoljno naučiti kako radi S3 model, koji je ujedno i najjednostavniji. Veliki broj popularnih R paketa koristi isključivo S3 klase i moguće je raditi dugo vremena u jeziku R bez potrebe za učenjem S4 ili RC modela. Zbog ove činjenice ćemo u nastavku se usredotočiti isključivo na S3 klase (čitatelji koji žele više informacija o ostalim modelima mogu pogledati vrlo dobru knjigu “Advanced R”, autora Hadley-a Wickhama, koja se između ostalog detaljnije bavi objektnim modelima u R-u i njihovom usporedbom). 8.2 Pomoćni paket sloop Prije nastavka upoznati ćemo se sa paketom sloop, čija je glavna svrha pružanje osnovnih informacija o objektima jezika R te koji je od velike pomoći kod snalaženja u “šumi” objektnih modela. Sličnu funkcionalnost možemo pronaći i u osnovnom R-u, no paket sloop ovaj proces čini dosta jednostavnijim tako da ćemo se sporadično oslanjati na njegove funkcije tijekom ostatka ovog poglavlja. Za početak, isprobajmo funkciju otype (“object type”) nad nekoliko do sada upoznatih objekata i provjerimo da s kojim objektnim modelima smo već imali prilike raditi. Zadatak 8.1 - funkcija otype #library(sloop) a &lt;- rep(c(T, F), 10) b &lt;- factor(c(&quot;up&quot;, &quot;up&quot;, &quot;down&quot;, &quot;up&quot;, &quot;down&quot;, &quot;down&quot;, &quot;down&quot;)) c &lt;- data.frame(x = 1:10, y = seq(-5, 5, length = 10)) # isprobajte funkciju `otype` nad ovim varijablama a &lt;- rep(c(T, F), 10) b &lt;- factor(c(&quot;up&quot;, &quot;up&quot;, &quot;down&quot;, &quot;up&quot;, &quot;down&quot;, &quot;down&quot;, &quot;down&quot;)) c &lt;- data.frame(x = 1:10, y = seq(-5, 5, length = 10)) # isprobajte funkciju `otype` nad ovim varijablama otype(a) otype(b) otype(c) ## [1] &quot;base&quot; ## [1] &quot;S3&quot; ## [1] &quot;S3&quot; 8.3 Pregled objektnog modela S3 Kao što je već rečeno, S3 objekti zapravo su preneseni iz programskog jezika S i predstavljaju relativno primitivno poimanje koncepta “objekta”, barem što se tiče očekivanja glede standardnih metoda stvaranja objekata i pripadajućih metoda. S3 objekt je zapravo obična lista kojoj smo definirali class atribut. # stvaramo novi objekt klase `Person` pero &lt;- list(id = &quot;12345678&quot;, surname = &quot;Peric&quot;, weight = 78) class(pero) &lt;- &quot;Person&quot; 8.3.1 Konstruktorska funkcija Uočite da nemamo formalno definiranog “predloška” klase kojeg onda instanciramo u objekt kao što je ustaljena praksa u drugim programskim jezicima. Kod S3 objekata jednostavno stvaramo listu i onda deklariramo da je ta lista objekt određene klase, iako je struktura te klase zapravo samo implicirana izgledom objekta (i ne mora uopće odgovarati strukturi nekog drugog objekta koji se deklarirao da pripada istoj klasi). Naravno, ovako ležeran način konstrukcije objekata ipak nije preporučljiv te se zbog toga preporučuje da klase ne deklariramo “ručno” već da to radimo uz pomoć posebne konstruktorske funkcije čiji će parametri zapravo definirati izgled objekta. Zadatak 8.2 - konstruktorska funkcija # stvorite funkciju naziva `Person` # ulazni parametri: id, surname, weight # povratna vrijednosti: objekt klase &quot;Person&quot; # prije stvaranja objekta funkcija mora provjeriti da je: # - `id` jednoelementni znakovni vektor od točno 8 znakova # - `surname` jednoelementni znakovni vektor # - `weight` jednoelementni pozitivni numerički vektor # stvorite varijablu `john`, objekt klase `Person` sa sljedećim karakteristikama: # id: 13571313, surname: Watson, weight: 76 # ispišite varijablu `john` # stvorite funkciju naziva `Person` # ulazni parametri: id, surname, weight # povratna vrijednosti: objekt klase &quot;Person&quot; # prije stvaranja objekta funkcija mora provjeriti da je: # - `id` jednoelementni znakovni vektor od točno 8 znakova # - `surname` jednoelementni znakovni vektor # - `weight` jednoelementni pozitivni numerički vektor Person &lt;- function(id, surname, weight) { stopifnot(is.character(id) &amp;&amp; nchar(id) == 8) stopifnot(is.character(surname)) stopifnot(is.numeric(weight) &amp;&amp; weight &gt; 0) p &lt;- list(id = id, surname = surname, weight = weight) class(p) &lt;- &quot;Person&quot; p } # stvorite varijablu `john`, objekt klase `Person` sa sljedećim karakteristikama: # id: 13571313, surname: Watson, weight: 76 john &lt;- Person(&quot;13571313&quot;, &quot;Watson&quot;, 76) # ispišite varijablu `john` john ## $id ## [1] &quot;13571313&quot; ## ## $surname ## [1] &quot;Watson&quot; ## ## $weight ## [1] 76 ## ## attr(,&quot;class&quot;) ## [1] &quot;Person&quot; Što je s nasljeđivanjem, gdje klasa-dijete nasljeđuje tj. proširuje svojstva klase-roditelja? R omogućuje nasljeđivanje, ali također na vrlo neformalan i relativno trivijalan način. Umjesto da navedemo samo jedan “naziv” klase uz pomoć atributa class, mi stvorimo znakovni vektor gdje će prvi element biti naziv klase, a ostali elementi će biti klase roditelji, poredani prema “važnosti”. Na primjer, ako smo stvorili novi objekt mate klase Zaposlenik nad kojim bi htjeli koristiti iste implementacije određenih generičkih metoda razvijenih za potrebe objekata klase Osoba, onda je dovoljno izvesti sljedeće: mate &lt;- list(oib = &quot;12345678&quot;, prezime = &quot;Peric&quot;, tezina = 78, godZaposlenja = 2001) class(mate) &lt;- c(&quot;Zaposlenik&quot;, &quot;Osoba&quot;) Primijetimo da sav posao oko nasljeđivanja atributa moramo obaviti “ručno”, tj. moramo se sami pobrinuti da mate ima atribute klase Osoba koje će generička funkcija koju pozivamo koristiti. 8.3.2 Generičke funkcije Gledajući gore definirani način dizajna objekta opravdano je postaviti i dodatno pitanje - a gdje su metode? Kao što znamo, standardni objektno-orijentirani principi pretpostavljaju enkapsulaciju atributa ali i metoda u okvir objekta. Upravo tu leži osnovna razlika između S3 objekta i “standardnih” objekata iz drugih programskih jezika - kod S3 objekata metode se definiraju izvan objekta u obliku tzv. generičkih funkcija. Zašto je tome tako? Ideja jest sljedeća - u radu sa objektima korisnik (programer, analitičar) često poziva iste funkcije (npr. “ispis”, “crtanje”, “sažeti opis”) nad objektima različitog tipa. Funkcija istog imena ali različite implementacije ovisno o objektu nad kojim radi zove se generička funkcija. Tako recimo funkcija print uvijek rezultira nekakvim ispisom, ali kako će ispis izgledati zapravo ovisi o objektu kojeg ispisujemo. Ovaj način dizajna objekata može djelovati iznimno nekonvencionalno, no činjenica jest da on pozive funkcija čini puno intuitivnijim, pogotovo korisnicima koji nemaju veliko iskustvo sa programiranjem. Konkretno, usporedimo naredbu: pokreni(auto, brzina = 20) s naredbom: auto.pokreni(brzina = 20) Čitajući prvu naredbu auto doživljavamo kao “objekt” (u smislu službe riječi u rečenicu), tj. nešto radimo “nad” tim objektom. Druga naredba auto postavlja kao subjekt, što je uobičajena praksa u objektno-orijentiranim jezicima ali nije u skladu sa općenitim poimanjem obavljanja radnji nad nekim objektima. U radu s programskim jezikom R često radimo “slične” poslove nad različitim objektima - ispisujemo njihov sadržaj, crtamo ih na grafu, tražimo neke sažete detalje o njima i sl. Upravo zbog toga, a i činjenice da u R-u često radimo interaktivno, R je dizajniran na način da razmišljamo što želimo učiniti umjesto da se pitamo gdje se nalazi funkcija koju želimo pozvati. Ako želimo ispisati neki objekt, logično je da ga samo proslijedimo funkciji print, ako ga želimo nacrtati funkciji plot, a ako želimo sažetak funkciji summary. Kako pojedina funkcija “zna” što učinit sa objektom? Odgovor je jednostavan - generička funkcija je samo “sučelje” prema “pravoj” funkciji koju pozivamo, a logika kako pronaći pravu funkciju je vrlo trivijalna - ako je ime generičke funkcije genFun a naziv klase objekta koju joj prosljeđujemo nazKlase, funkcija koja se zapravo poziva jest genFun.nazKlase. Ako takve funkcije nema, poziva se funkcija genFun.default. U ovo se lako možemo uvjeriti samostalno u sklopu sljedeće vježbe. Zadatak 8.3 - Generičke funkcije # ispišite funkciju `summary` (samo naziv funkcije!) # ispišite funkciju koja se zapravo poziva kad pozovete # funkciju `summary` nad objektom klase `factor` # ispišite funkciju `summary` summary # ispišite funkciju koja se zapravo poziva kad pozovete # funkciju `summary` nad objektom klase `factor` summary.factor ## standardGeneric for &quot;summary&quot; defined from package &quot;base&quot; ## ## function (object, ...) ## standardGeneric(&quot;summary&quot;) ## &lt;environment: 0x00000185114ec8b0&gt; ## Methods may be defined for arguments: object ## Use showMethods(summary) for currently available ones. ## function (object, maxsum = 100L, ...) ## { ## nas &lt;- is.na(object) ## ll &lt;- levels(object) ## if (ana &lt;- any(nas)) ## maxsum &lt;- maxsum - 1L ## tbl &lt;- table(object) ## tt &lt;- c(tbl) ## names(tt) &lt;- dimnames(tbl)[[1L]] ## if (length(ll) &gt; maxsum) { ## drop &lt;- maxsum:length(ll) ## o &lt;- sort.list(tt, decreasing = TRUE) ## tt &lt;- c(tt[o[-drop]], `(Other)` = sum(tt[o[drop]])) ## } ## if (ana) ## c(tt, `NA&#39;s` = sum(nas)) ## else tt ## } ## &lt;bytecode: 0x0000018523419698&gt; ## &lt;environment: namespace:base&gt; Razumijevanjem principa rada generičkih funkcija upotpunili smo sliku o S3 objektima. Najvažnija stvar koju moramo usvojiti jest da kod ovog modela funkcije nisu dio samog objekta, već se definiraju zasebno, a poveznica između objekta i “njegove” metode jest samo u nazivu funkcije pomoću kojeg će R “povezati” generičku funkciju i taj objekt. Iako je ovaj princip primitivan i podložan greškama u rukama nepažljivog programera, on je neumitno jednostavan za uporabu i vrlo učinkovit. Konačno, uočimo da ovaj pristup nije u potpunosti svojstven isključivo jeziku R - slične principe nalazimo i u drugim programskim jezicima (npr. Python povezuje print funkciju i objekt preko posebne metode objekta __str__). R je samo specifičan po tome što taj princip koristi otvoreno i gotovo isključivo. Objekte i generičke funkcije ćemo ponovo posjetiti kada naučimo stvarati vlastite funkcije, što će nam omogućiti da stvorimo kako konstruktore naših objekata, tako i njihove generičke funkcije. 8.4 Implementacija generičke funkcije Način implementacije generičkih funkcija (za S3 objekte!) zapravo je iznimno jednostavan, što je vjerojatno i razlog njihove široke prihvaćenosti i velike popularnosti u R zajednici. Postupak se svodi na tri jednostavna koraka: odaberemo postojeću generičku funkciju (npr. print) alternativno, deklariramo novu generičku funkciju uz pomoć funkcije UseMethod npr. infoAbout &lt;- function(x) UseMethod(\"infoAbout\") stvorimo objekt i deklariramo njegovu klasu (npr. Osoba) implementiramo funkciju naziva ime_gen_fje.ime_klase (npr. print.Osoba) I to je sve! R ne zahtjeva nikakve dodatne korake, gore navedeno je sasvim dovoljno da R prepoznaje novu generičku funkciju i da ju primjenjuje na sve objekte za čiju klasu je implementirana ta generička funkcija u obliku ime_gen_fje.ime_klase (ili ime_gen_fje.default za sve klase za koje ne postoji posebna implementacija). Pokušajmo u sljedećem zadatku implementirati generičku funkciju print za objekt klase Person. Zadatak 8.4 - implementacija nove generičke funkcije peter &lt;- Person(id = &quot;12345678&quot;, surname = &quot;Parker&quot;, weight = 78) # implementirajte funkciju koja će omogućiti korištenje # generičke funkcije `print` nad objektom klase `Person` # pri čemu će se na zaslon ispisati # ID: &lt;id&gt;, surname: &lt;surname&gt;, weight: &lt;weight&gt; # koristite se funkcijom `paste` za konkatenaciju znakovnih nizova # i funkcijom `cat` za ispisivanje na zaslon # ispišite varijablu `peter` # implementirajte funkciju koja će omogućiti korištenje # generičke funkcije `print` nad objektom klase `Person` # pri čemu će se na zaslon ispisati # ID: &lt;id&gt;, surname: &lt;surname&gt;, weight: &lt;weight&gt; # koristite se funkcijom `paste` za konkatenaciju znakovnih nizova # i funkcijom `cat` za ispisivanje na zaslon print.Person &lt;- function(p) { rez &lt;- paste0(&quot;ID:&quot;, p$id, &quot;, surname:&quot;, p$surname, &quot;, weight:&quot;, p$weight, &quot;\\n&quot;) cat(rez) } # ispišite varijablu `peter` peter ## ID:12345678, surname:Parker, weight:78 8.4.1 Funkcija methods Za kraj, prikažimo mogućnost R-a da nam izlista sve trenutno poznate implementacije neke generičke metode. Za to se jednostavno koristimo funkcijom methods kojoj proslijedimo ime dotične metode. Istom funkcijom možemo i provjeriti koje sve implementacije generičkih funkcija postoje za određenu klasu. Za to koristimo parametar class kojem prosljeđujemo naziv klase za koju tražimo spomenute implementacije. Zadatak 8.5 - funkcija methods # prikažite sve do sad poznate implementacije generičke funkcije `summary` # provjerite koje sve implementacije generičkih funkcija postoje za klasu `factor` # list all implementations of the `summary` function methods(summary) ## [1] summary,ANY-method summary,DBIObject-method ## [3] summary,diagonalMatrix-method summary,mle-method ## [5] summary,mselm-method summary,SECdistrMv-method ## [7] summary,SECdistrUv-method summary,selm-method ## [9] summary,sparseMatrix-method summary,SUNdistr-method ## [11] summary.aareg* summary.agnes* ## [13] summary.Anova.mlm* summary.aov ## [15] summary.aovlist* summary.areg.boot* ## [17] summary.aspell* summary.bag* ## [19] summary.bagEarth summary.bagFDA* ## [21] summary.bcnPowerTransform* summary.bcnPowerTransformlmer* ## [23] summary.bit* summary.bitwhich* ## [25] summary.booltype* summary.boot* ## [27] summary.cch* summary.check_packages_in_dir* ## [29] summary.clara* summary.classbagg* ## [31] summary.col_spec* summary.connection ## [33] summary.corAR1* summary.corARMA* ## [35] summary.corCAR1* summary.corCompSymm* ## [37] summary.corExp* summary.corGaus* ## [39] summary.corIdent* summary.corLin* ## [41] summary.corNatural* summary.corRatio* ## [43] summary.corSpher* summary.corStruct* ## [45] summary.corSymm* summary.coxph* ## [47] summary.coxph.penal* summary.data.frame ## [49] summary.Date summary.default ## [51] summary.diana* summary.diff.resamples* ## [53] summary.dissimilarity* summary.Duration* ## [55] summary.ecdf* summary.effects* ## [57] summary.estimate* summary.factor ## [59] summary.fanny* summary.find.matches* ## [61] summary.fitdistr.grouped* summary.formula* ## [63] summary.FutureJournal* summary.ggplot* ## [65] summary.glm summary.gls* ## [67] summary.hcl_palettes* summary.Hist* ## [69] summary.impute* summary.inbagg* ## [71] summary.inclass* summary.infl* ## [73] summary.integer64* summary.Interval* ## [75] summary.lca* summary.lm ## [77] summary.lme* summary.lmList* ## [79] summary.loess* summary.loglm* ## [81] summary.lvm* summary.lvm.mixture* ## [83] summary.lvmfit* summary.manova ## [85] summary.matrix summary.mChoice* ## [87] summary.mlm* summary.modelStruct* ## [89] summary.mona* summary.multigroup* ## [91] summary.multigroupfit* summary.multinom* ## [93] summary.negbin* summary.nls* ## [95] summary.nlsList* summary.nnet* ## [97] summary.ordreg* summary.packageStatus* ## [99] summary.pam* summary.pdBlocked* ## [101] summary.pdCompSymm* summary.pdDiag* ## [103] summary.pdIdent* summary.pdLogChol* ## [105] summary.pdMat* summary.pdNatural* ## [107] summary.pdSymm* summary.Period* ## [109] summary.polr* summary.POSIXct ## [111] summary.POSIXlt summary.powerTransform* ## [113] summary.ppr* summary.pr_DB* ## [115] summary.prcomp* summary.princomp* ## [117] summary.proc_time summary.prodlim* ## [119] summary.proxy_registry* summary.pyears* ## [121] summary.ratetable* summary.recipe* ## [123] summary.resamples* summary.reStruct* ## [125] summary.ri* summary.RichSOCKcluster* ## [127] summary.RichSOCKnode* summary.rlang:::list_of_conditions* ## [129] summary.rlang_error* summary.rlang_message* ## [131] summary.rlang_trace* summary.rlang_warning* ## [133] summary.rlm* summary.rpart* ## [135] summary.shingle* summary.silhouette* ## [137] summary.sim* summary.srcfile ## [139] summary.srcref summary.stepfun ## [141] summary.stl* summary.survbagg* ## [143] summary.survexp* summary.survfit* ## [145] summary.survfitms* summary.survreg* ## [147] summary.svm* summary.table ## [149] summary.timeDate* summary.tmerge* ## [151] summary.train* summary.transcan* ## [153] summary.trellis* summary.tukeysmooth* ## [155] summary.tune* summary.twostageCV* ## [157] summary.varComb* summary.varConstPower* ## [159] summary.varConstProp* summary.varExp* ## [161] summary.varFixed* summary.varFunc* ## [163] summary.varIdent* summary.varPower* ## [165] summary.vctrs_sclr* summary.vctrs_vctr* ## [167] summary.warnings summary.which* ## [169] summary.zibreg* ## see &#39;?methods&#39; for accessing help and source code # provjerite koje sve implementacije generičkih funkcija postoje za klasu `factor` methods(class = &quot;factor&quot;) ## [1] - / [ [[ [[&lt;- ## [6] [&lt;- + all.equal Arith as.character ## [11] as.data.frame as.Date as.duration as.interval as.list ## [16] as.logical as.period as.POSIXlt as.vector as_date ## [21] as_datetime as_factor brief c cbind2 ## [26] coerce Compare corresp droplevels fixed ## [31] format gausspr histogram initialize inlearn ## [36] is.na&lt;- kqr kronecker ksvm length&lt;- ## [41] levels&lt;- Logic lssvm Math Ops ## [46] output_column plot print rbind2 recode ## [51] relevel relist rep rvm scale_type ## [56] show slotsFromS3 summary Summary type_sum ## [61] xtfrm ## see &#39;?methods&#39; for accessing help and source code 8.4.2 Zaključci o S3 objektima Ukratko, zaključci o S3 objektima mogu biti sljedeći: S3 objekti funkcioniraju na jednostavan, neformalan način - to su jednostavno liste sa postavljenom proizvoljnom vrijednosti class atributa puno toga ostavljeno je na odgovornosti programera metode S3 objekata ne enakpsuliraju se unutar objekata, već se dizajniraju “izvan” objekata u obliku generičkih funkcija S3 objekti jednostavni su za uporabu ako su i objektni modeli koje dizajniramo nisu jednostavni, ali nisu pogodni za kompleksnije objektne modele zbog teškog održavanja modela i velike mogućnosti pogrešaka 8.5 Kratki pregled S4 objekata Nećemo se detaljno baviti S4 objektima, već ćemo dati vrlo kratak pregled kako izgledaju i koje su neke od najznačajnijih promjena u odnosu na S3 model. S4 objekti nude blagu “nadogradnju” na S3 objekte u smislu da diktiraju više strogosti i formalnosti pri definiranju i korištenju klasa, dok još uvijek zadržavaju većinu jednostavnosti S3 modela. Najznačajnija (i vjerojatno dobrodošla) promjena je dopuštanje formalne definicije predloška klase. S4 klasa ima tri glavna svojstva: naziv, koji ga identificira prikaz, koji opisuje njegove atribute (tzv. “slot”-ovi) (opcionalno) vektor roditeljskih klasa (klase koje ova klasa “sadrži”) S4 ekvivalent naše klase S3 Person bi stoga izgledao ovako: # definicija predloška setClass(&quot;Person&quot;, representation(id = &quot;character&quot;, surname = &quot;character&quot;, weight = &quot;numeric&quot;)) # instanciranje klase pero &lt;- new(&quot;Person&quot;, id = &quot;12345678&quot;, surname = &quot;peric&quot;, weight = 76) Jedna bitna razlika jest što umjesto operatora $ koristimo operator @ za pristup atributima (“slot”-ovima) klase. Isto tako, funkcija getSlots nam vraća sve atribute odabrane klase. # ispiši atribute klase `Person` getSlots(&quot;Person&quot;) # dohvati vrijednosti atributa varijable `pero` paste0(pero@id, &quot;: &quot;, pero@surname) ## id surname weight ## &quot;character&quot; &quot;character&quot; &quot;numeric&quot; ## [1] &quot;12345678: peric&quot; S4 također koristi generičke funkcije, ali uz određene promjene u sintaksi. Ovdje nećemo previše ulaziti u detalje, već ćemo samo prikazati kratki primjer pridjeljivanja postojeće generičke funkcije S4 objektu uz pomoć funkcije setMethod. setMethod(&quot;print&quot;, signature(x = &quot;Person&quot;), function(x) { rez &lt;- paste0(&quot;ID:&quot;, x@id, &quot;, surname:&quot;, x@surname, &quot;, weight:&quot;, x@weight, &quot;\\n&quot;) cat(rez) }) print(pero) ## ID:12345678, surname:peric, weight:76 Zadaci za vježbu Stvorite objekt klase Kvadar sa atributima visina, sirina i dubina jednakim 10, 20 i 30. Programirajmo u R-u by Damir Pintar is licensed under a Creative Commons Attribution-NonCommercial-NoDerivatives 4.0 International License.Based on a work at https://ratnip.github.io/FER_OPJR/ "],["cijev.html", "9 Koncept urednih podataka 9.1 Operator cjevovoda 9.2 Uredni podaci Zadaci za vježbu", " 9 Koncept urednih podataka 9.1 Operator cjevovoda Pogledajmo sljedeći primjer: zamislimo da u jeziku R želimo stvoriti 100 nasumičnih realnih varijabli u rasponu [0,100], zaokružiti ih na dvije decimale, iz ovog skupa odabrati uzorak od 10 varijabli, izračunati aritmetičku sredinu uzorka i ispisati ga na zaslon. Jedno od mogućih programskih rješenja moglo bi biti sljedeće: set.seed(1234) # (zbog ponovljivosti) # rješenje gornjeg primjera rez &lt;- runif(100, 0, 100) # 100 nasumičnih varijabli iz uniformne razdiobe od 0 do 100 rez &lt;- round(rez,2) rez &lt;- sample(rez, 10) rez &lt;- mean(rez) rez ## [1] 46.651 Ovakav kod ima dosta nepotrebnog ponavljanja - u svakom retku koristimo varijablu rez koja čuva međurezultate i operator pridruživanja pomoću kojeg pridružujemo nove rezultate varijabli rez. Alternativno, mogli smo sve obaviti u jednom retku. Zadatak 9.1 - učahurene funkcije set.seed(1234) # ponovite gornji primjer, ali uz pomoć samo jednog retka programskog koda mean(sample(round(runif(100, 0, 100), 2), 10)) ## [1] 46.651 Ovdje vidimo jedan tipičan primjer “kodnog sendviča” koji nije problem samo u R-u, već se pojavljuje u većini programskih jezika - rezultat jedne funkcije postaje ulaz u drugu te ukoliko želimo sve obaviti bez eksplicitnog čuvanja međurezultata kao rezultat ćemo dobiti programski kod koji je podložan greškama kod pisanja te je vrlo teško čitljiv. Prirodan način interpretacije ovakvog primjera bio bi “slijeva na desno”; kad obavimo jedan posao, rezultat postaje ulaz u drugi posao i tako sve do završetka procesa. Ako bi postojao način kada bi mogli ovakvu intuitivnu interpretaciju predočiti programskim kodom, pojednostavili bismo si ne samo pisanje koda, već bi takav kod postao daleko čitljiviji i lakši za održavanje i eventualnu naknadnu prilagodbu. Upravo ovo bila je motivacija za razvoj tzv. “pipeline” operatora kojeg nudi paket magrittr (Bache and Wickham 2014). Paket čudnog imena zapravo je inspiriran imenom apstraktnog slikara Renea Magrittea, točnije njegovom slavnom slikom “La trahison des images” koja prikazuje lulu ispod koje su riječi “Ceci n’est pas une pipe”. Na isti način paket magrittr donosi “pipeline” ili “pipe” operator %&gt;% koji “nije lula”. Štogod mislili o navedenom slikarskom djelu ili igri riječi koja je inspirirala ovaj paket, ono što je neporecivo jest činjenica da “pipeline” operator programski kod čini daleko čitljivijim te da je postao izrazito omiljen u R zajednici, pogotovo kod procedura koje uključuju intenzivno “ulančavanje” funkcija. Kako radi %&gt;% operator? Vrlo jednostavno - postavimo ga nakon poziva neke funkcije i iza njega navedemo poziv druge funkcije u kojem mjesto rezultata prve naznačimo točkom. Ovo možemo raditi koliko god puta želimo, tj. ovisno koliko poziva “ulančavamo”. h(g(f(x), y), z, w) # kod bez %&gt;% operatora f(x) %&gt;% g(., y) %&gt;% h(., z, w) # kod sa %&gt;% operatorom Ako je rezultat prethodne funkcije na prvom mjestu sljedeće funkcije, onda se točka (štoviše, cijeli taj argument) može izbaciti, tako da je sintaksa još kraća: f(x) %&gt;% g(y) %&gt;% h(z,w) # kod sa %&gt;% bez korištenja točke Ukoliko ne želimo koristiti točku, moramo samo voditi računa da su pozivi funkcija u lancu zapravo formalno nepravilni, jer imaju “nevidljivi” prvi argument. Usprkos tome, mnogi R programeri vole ovakvu sintaksu jer zahtijeva manje tipkanja i nešto je preglednija, a spomenuta nepravilnost ne smeta dok god je programer upoznat sa postojanjem “nevidljivog” argumenta. Probajmo sada preoblikovati naš prvi primjer uz pomoć %&gt;% operatora. Zadatak 9.2 - operator %&gt;% set.seed(1234) # ponovo rješite prvi primjer uz pomoć %&gt;% operatora set.seed(1234) runif(100, 0, 100) %&gt;% round(2) %&gt;% sample(10) %&gt;% mean() %&gt;% print() ## [1] 46.651 Uočite kako čitanjem gornjeg programskog koda vrlo lagano interpretiramo smisao te linije programskog koda, pogotovo u usporedbi sa istom naredbom napisanom u obliku “sendviča”. Krajnji rezultat našeg “lanca” funkcija možemo pohraniti uobičajenim načinom: suma &lt;- 1:10 %&gt;% sum # rezultat se pohranjuje u varijablu &#39;suma&#39; ali je možda vizualno konzistentnije koristiti “obrnuti” operator pridruživanja: -&gt;. 1:10 %&gt;% sum -&gt; suma # radi istovjetno gornjem primjeru Uočite da u situacijama kada je rezultat prethodne funkcije jedini parametar sljedeće možemo izbaciti zagrade u potpunosti (dakle u gornjim primjerima sum, sum() ili sum(.) bi svi radili jednako). Pokušajmo sada kombinirati %&gt;% operator i lapply na primjeru već viđenom u poglavlju o funkcijama iz porodice apply. Zadatak 9.3 - funkcija lapply i operator %&gt;% l &lt;- list(a = 1:10, b = 10:20, c = 100:200) # stvorite matricu koja će sadržavati prvi i zadnji element svakog elementa liste # elementi moraju biti poredani po retcima # koristite funkcije lapply, unlist i matrix te %&gt;% operator # rezultat spremite u varijablu `rez` # ispišite `rez` l &lt;- list(a = 1:10, b = 10:20, c = 100:200) l %&gt;% lapply(function(x) c(x[1], x[length(x)])) %&gt;% unlist %&gt;% matrix(ncol = 2, byrow = T) -&gt; rez rez ## [,1] [,2] ## [1,] 1 10 ## [2,] 10 20 ## [3,] 100 200 Operator cjevovoda vrlo je pogodan u sprezi s “klasičnim” funkcijama, no možemo naići na problem kada ga želimo kombinirati s drugim operatorima. Uzrok problema jest sintaksa - operator cjevovoda svoju učinkovitost postiže upravo nametanjem nove, “slijedne” sintakse, koja nije kompatibilna sa sintaksom koju nameću drugi operatori, kao npr. +, %% ili [. Ukoliko nam je zaista bitno da u našem programskom kodu imamo “neprekinuti” lanac poziva funkcija koji će sadržavati ne samo funkcije, nego i druge operatore, onda je jedno od rješenja koristiti operatore kao “obične” funkcije. Naime, svaki operator je zapravo funkcija koja dijeli ime s operatorom (uz korištenje backtick navodnika kako bi se mogli koristiti simbolima), tako da su sljedeći parovi izraza zapravo ekvivalentni: Primjer - operatori kao funkcije # svaki par naredbi jest ekvivalentan 2 + 3 `+`(2, 3) 1 : 5 `:`(1, 5) x &lt;- c(1, 2, 3) `&lt;-`(&quot;x&quot;, c(1,2,3)) x[1] `[`(x, 1) ## [1] 5 ## [1] 5 ## [1] 1 2 3 4 5 ## [1] 1 2 3 4 5 ## [1] 1 ## [1] 1 Pokušajmo ovaj princip iskoristiti u sljedećoj vježbi. Zadatak 9.4 - složenija uporaba operatora cjevovoda set.seed(1234) # &quot;uredite&quot; sljedeću naredbu uz pomoć operatora cjevovoda matrix(table(sample(round(sqrt(sample(1:10000, 10000, replace = T))), 100))[1:9], 3, 3) ## [,1] [,2] [,3] ## [1,] 2 2 2 ## [2,] 1 1 1 ## [3,] 2 2 2 set.seed(1234) # &quot;uredite&quot; sljedeću naredbu uz pomoć operatora cjevovoda 1:10000 %&gt;% sample(10000, replace = T) %&gt;% sqrt %&gt;% round %&gt;% sample(100) %&gt;% table %&gt;% `[`(1:9) %&gt;% matrix(3, 3) ## [,1] [,2] [,3] ## [1,] 2 2 2 ## [2,] 1 1 1 ## [3,] 2 2 2 %&gt;% operator je posebno pogodan za upravljanje podatkovnim skupovima, pogotovo u scenarijima kada imamo definiranu proceduru transformacije podataka (npr. filtriramo neke retke, potom odaberemo stupce, zatim grupiramo podatke ovisno o nekoj kategorijskoj varijabli). Uz pomoć ovog operatora dobivamo preglednu reprezentaciju našeg procesa prilagodbe podataka koju kasnije lako prilagođavamo i po potrebi proširujemo. Primjeri u nastavku će često prema potrebi koristiti ovaj operator, te preporučujemo njegovo svladavanje prije nastavka sa lekcijama koje slijede. 9.2 Uredni podaci U literaturi možemo naći činjenicu kako je u procesu analize priprema podataka često vremenski najzahtjevniji segment procesa - u knjizi “Exploratory Data Mining and Data Cleaning” spominje se da se na pripremu često troši od 50% do 80% ukupnog vremena. Isto tako, kako navodi Hadley Wickham u svojem članku “Tidy Data”, priprema podataka često nije samo prvi korak već je proces koji se ponavlja kako se otkrivaju nova saznanja ili prikupljaju novi podaci. Hadley Wickham je uveo termin “urednih podataka” koji se odnosi na organizaciju podatkovnog skupa na način da u što većoj mjeri olakša njihovu daljnju obradu i analizu. Činjenica je da ulazni podaci često nisu originalno namijenjeni za potrebe analize te kao takvi nisu organizirani na način koji bi omogućio njihovo lako korištenje u analitičkom procesu. “Uredni podaci” zapravo predstavljaju princip kako - prema potrebi - “presložiti” podatke tako da njihova struktura odgovara standardnom, očekivanom metapredlošku. Principi urednih podataka imaju sličnosti sa relacijskim modelom podataka no definirani su na način koji više odgovara statističarima i programerima. Ugrubo te principe možemo popisati na sljedeći način: podaci su organizirani u tablicu svaki redak predstavlja obzervaciju svaki stupac predstavlja svojstvo ili varijablu te obzervacije Budući da ovo možda zvuči previše trivijalno, pogledajmo koja svojstva Hadley navodi kao tipična za “neuredne” podatke: imena stupaca nisu nazivi varijabli, već njihove vrijednosti više različitih varijabli spremljeno je u isti stupac varijable su spremljene u retke više tipova različitih obzervacija spremljeno je u istu tablicu jedan tip obzervacije spremljen je u više tablica U nastavku ćemo dati nekoliko primjera tablica koje ne odgovaraju u potpunosti definiciji urednih podataka te prikazati kako ih na jednostavan način preoblikovati, tj. “urediti”. Za taj posao koristiti ćemo metode paketa tidyr. NAPOMENA: u primjerima i zadacima koji slijede zamijeniti ćemo funkciju str alternativnom funkcijom iz paketa dplyr naziva glimpse. Razlog je čisto tehničke prirode - budući da naredba read_csv formalno vraća objekt klase tibble (svojevrsna nadogradnja podatkovnog okvira), funkcija str nam vraća “previše” informacija, konkretno daje nam i informacije o atributima koji nam nisu interesantni za brzi uvid u okvir. Funkcija glimpse radi gotovo identično funkciji str, ali bez ispisa tih atributa (ali i boljim iskorištavanjem prostora za ispis), tako da predstavlja bolju alternativu. 9.2.1 Funkcije pivot_longer i pivot_wider U radnoj mapi trebala bi se nalaziti datoteka studenti.csv. Učitajmo ju u radnu okolinu. Budući da je datoteka pohranjena uz pomoć UTF-8 kodiranja (budući da sadrži hrvatska slova), naredbi read_csv možete dodati i parametar fileEncoding = \"UTF-8\" kako bi dobili korektni ispis posebnih znakova. Zadatak 9.5 - podatkovni skup studenti # učitajte podatke iz datoteke `studenti.csv` u varijablu `studenti` # upoznajte se sa podacima uz pomoć standardnih funkcija za tu svrhu # (names, sapply - class, str, head, summary ...) # u daljnim primjerima za ovaj postupak koristiti ćemo se izrazom &quot;proučite okvir..&quot; #library(dplyr) # ako je potrebno studenti &lt;- read_csv(&quot;studenti.csv&quot;) glimpse(studenti) head(studenti) ## Rows: 27 Columns: 10 ## ── Column specification ─────────────────────────────────────────── ## Delimiter: &quot;,&quot; ## chr (9): Prezime, Ime, Matematika 1, Fizika 1, Programiranje, Osnove elektro... ## dbl (1): JMBAG ## ## ℹ Use `spec()` to retrieve the full column specification for this data. ## ℹ Specify the column types or set `show_col_types = FALSE` to quiet this message. ## Rows: 27 ## Columns: 10 ## $ JMBAG &lt;dbl&gt; 1341, 1342, 1343, 1344, 1345, 1346, 1347, 1348… ## $ Prezime &lt;chr&gt; &quot;Anić&quot;, &quot;Babić&quot;, &quot;Crnoja&quot;, &quot;Črnjac&quot;, &quot;Dizla&quot;, … ## $ Ime &lt;chr&gt; &quot;Iva&quot;, &quot;Josip&quot;, &quot;Petra&quot;, &quot;Lucija&quot;, &quot;Stipe&quot;, &quot;I… ## $ `Matematika 1` &lt;chr&gt; &quot;2&quot;, &quot;5&quot;, &quot;4&quot;, &quot;2&quot;, &quot;NULL&quot;, &quot;NULL&quot;, &quot;NULL&quot;, &quot;3… ## $ `Fizika 1` &lt;chr&gt; &quot;2&quot;, &quot;3&quot;, &quot;3&quot;, &quot;5&quot;, &quot;4&quot;, &quot;3&quot;, &quot;3&quot;, &quot;4&quot;, &quot;2&quot;, &quot;… ## $ Programiranje &lt;chr&gt; &quot;NULL&quot;, &quot;4&quot;, &quot;4&quot;, &quot;2&quot;, &quot;3&quot;, &quot;NULL&quot;, &quot;3&quot;, &quot;3&quot;, … ## $ `Osnove elektrotehnike` &lt;chr&gt; &quot;NULL&quot;, &quot;3&quot;, &quot;2&quot;, &quot;2&quot;, &quot;5&quot;, &quot;5&quot;, &quot;3&quot;, &quot;4&quot;, &quot;2&quot;… ## $ `Digitalna logika` &lt;chr&gt; &quot;4&quot;, &quot;NULL&quot;, &quot;3&quot;, &quot;3&quot;, &quot;2&quot;, &quot;5&quot;, &quot;2&quot;, &quot;4&quot;, &quot;3&quot;… ## $ `Matematika 2` &lt;chr&gt; &quot;2&quot;, &quot;5&quot;, &quot;4&quot;, &quot;3&quot;, &quot;2&quot;, &quot;5&quot;, &quot;2&quot;, &quot;5&quot;, &quot;NULL&quot;… ## $ `Algoritmi 1` &lt;chr&gt; &quot;2&quot;, &quot;5&quot;, &quot;3&quot;, &quot;4&quot;, &quot;2&quot;, &quot;5&quot;, &quot;5&quot;, &quot;4&quot;, &quot;3&quot;, &quot;… ## # A tibble: 6 × 10 ## JMBAG Prezime Ime `Matematika 1` `Fizika 1` Programiranje ## &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 1341 Anić Iva 2 2 NULL ## 2 1342 Babić Josip 5 3 4 ## 3 1343 Crnoja Petra 4 3 4 ## 4 1344 Črnjac Lucija 2 5 2 ## 5 1345 Dizla Stipe NULL 4 3 ## 6 1346 Ermić Igor NULL 3 NULL ## # ℹ 4 more variables: `Osnove elektrotehnike` &lt;chr&gt;, `Digitalna logika` &lt;chr&gt;, ## # `Matematika 2` &lt;chr&gt;, `Algoritmi 1` &lt;chr&gt; Uočite da ovaj podatkovni skup ima dosta nedostajućih vrijednosti koje su zapisane kao NULL. Budući da R ne prepoznaje ovo kao nedostajuću vrijednost on je podatke učitao kao znakovne nizove. Budući da su stupci koji se odnose na ocjene očito numerički, možemo ih lako pretvoriti u takve uz pomoć naredbe as.numeric(). No, postoji jednostavniji način - ako znamo na koji način je nedostajuća vrijednost reprezentirana u podatkovnom skupu, možemo to direktno ugraditi u naredbu read_csv uz pomoć parametra na. Zadatak 9.6 - prilagodba parametara učitavanja podatkovnog skupa # ponovo učitajte podatke iz datoteke `studenti.csv` u varijablu `studenti` # naredbi `read_csv` dodajte parametre `na` sa znakovnim nizom koji predstavlja NA # i `col_types` sa znakovnim nizom koji opisuje tipove stupaca # (npr. `&quot;clf&quot;` predstavlja &quot;character - logical - factor&quot;) # proučite okvir `studenti` studenti &lt;- read_csv(&quot;studenti.csv&quot;, na = &quot;NULL&quot;, col_types = &quot;ncciiiii&quot;) glimpse(studenti) head(studenti) ## Rows: 27 ## Columns: 10 ## $ JMBAG &lt;dbl&gt; 1341, 1342, 1343, 1344, 1345, 1346, 1347, 1348… ## $ Prezime &lt;chr&gt; &quot;Anić&quot;, &quot;Babić&quot;, &quot;Crnoja&quot;, &quot;Črnjac&quot;, &quot;Dizla&quot;, … ## $ Ime &lt;chr&gt; &quot;Iva&quot;, &quot;Josip&quot;, &quot;Petra&quot;, &quot;Lucija&quot;, &quot;Stipe&quot;, &quot;I… ## $ `Matematika 1` &lt;int&gt; 2, 5, 4, 2, NA, NA, NA, 3, 3, 4, 2, 4, 5, 3, 4… ## $ `Fizika 1` &lt;int&gt; 2, 3, 3, 5, 4, 3, 3, 4, 2, 2, NA, 2, 4, NA, 5,… ## $ Programiranje &lt;int&gt; NA, 4, 4, 2, 3, NA, 3, 3, 3, 4, 3, 5, 2, 4, 4,… ## $ `Osnove elektrotehnike` &lt;int&gt; NA, 3, 2, 2, 5, 5, 3, 4, 2, 2, 3, 2, 4, 5, 2, … ## $ `Digitalna logika` &lt;int&gt; 4, NA, 3, 3, 2, 5, 2, 4, 3, 5, 2, 4, 3, NA, 5,… ## $ `Matematika 2` &lt;int&gt; 2, 5, 4, 3, 2, 5, 2, 5, NA, 4, 2, 5, 2, 3, 4, … ## $ `Algoritmi 1` &lt;int&gt; 2, 5, 3, 4, 2, 5, 5, 4, 3, 2, 4, 2, 3, NA, 3, … ## # A tibble: 6 × 10 ## JMBAG Prezime Ime `Matematika 1` `Fizika 1` Programiranje ## &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; ## 1 1341 Anić Iva 2 2 NA ## 2 1342 Babić Josip 5 3 4 ## 3 1343 Crnoja Petra 4 3 4 ## 4 1344 Črnjac Lucija 2 5 2 ## 5 1345 Dizla Stipe NA 4 3 ## 6 1346 Ermić Igor NA 3 NA ## # ℹ 4 more variables: `Osnove elektrotehnike` &lt;int&gt;, `Digitalna logika` &lt;int&gt;, ## # `Matematika 2` &lt;int&gt;, `Algoritmi 1` &lt;int&gt; Vidimo da podaci sada imaju odgovarajući tip - no očito ne odgovaraju u potpunosti definiciji “urednih podataka”. Imena stupaca su zapravo kategorije varijable Predmet a “obzervacija” u ovoj tablici reprezentirana je studentom. Dodavanje nove ocjene iz nekog predmeta moguće je jedino dodavanjem novog stupca, pri čemu bismo morali voditi računa da se na taj način dodaju ocjene za sve student, tj. da bi tablica morala imati puno NA vrijednosti za sve kombinacije studenata i predmeta koje su neprimjenjive jer ocjene trenutno nema (i možda je neće ni biti ukoliko student niti ne sluša taj predmet). Budući da su podaci u tablici zapravo skup ocjena, bilo bi pogodno preoblikovati tablicu tako da svaki redak upravo bude “ocjena koju je dobio neki student na nekom predmetu”. Razmislite koje korake bi trebalo poduzeti da stvorimo takvu tablicu. Trebamo: stvoriti kategorijsku varijablu Predmet koja bi kao razine imala nazive predmeta koji su trenutno stupci stvoriti sve pripadne kombinacije student-predmet popuniti kombinacije pripadajućom vrijednosti ocjene Ovaj postupak nije nemoguć ali zahtjeva dosta truda oko preoblikovanja podatkovnog okvira. Kako bi se ovaj postupak pojednostavio, možemo koristiti funkciju pivot_longer iz paketa tidyr koja obavlja upravo gore opisani postupak: ona “prikuplja” stupce u jedinstvenu varijablu i onda popunjava vrijednosti te varijable uz pomoć postojećih kombinacija naziv stupca / redak. Potpis funkcije izgleda ovako: pivot_longer(data, cols, names_to, values_to, values_drop_na) Detaljni opis funkcije možete dobiti pozivom naredbe ?pivot_longer, a ovdje ćemo samo ukratko objasniti parametre: data je naš podatkovni okvir cols stupci koje “pivotiramo” - navodimo nazive stupaca (bez navodnika), sintaksu stupac_od:stupad_do ili stupce koje NE želimo sa prefiksom - names_to reprezentira ime novog stupca kojeg stvaramo (u našem slučaju stupac \"Predmet\") values_drop_na omogućuje odabir ispuštanja opservacija sa NA vrijednostima Obavimo ovu funkciju nad našim podatkovnim okvirom. NAPOMENA: Jedna od specifičnosti paketa tidyverse jest ta što u pozivima funkcija često kod referenciranja stupaca možemo koristiti njihove nazive bez navodnika. No ovdje moramo biti oprezni ako radimo sa stupcima čiji nazivi krše pravila imenovanja varijabli. Naš podatkovni okvir primjer je podatkovnog skupa sa takvim stupcima - primjerice, stupac naziva “Matematika 1” sadrži razmak, što predstavlja problem kod njegovog direktnog referenciranja. Ovu situaciju lako razrješavamo na isti način kao i u općenitom slučaju varijabli koje krše pravila imenovanja - uz pomoć backticks navodnika (npr. \\Varijabla sa razmakom``). Alternativno (a i preporučljivo) jest preimenovati imena stupaca tako da koriste nazive koji su lakši za korištenje unutar programskog koda. Ovo nećemo napraviti u nastavku kako bi primjer zornije prikazao općenitiji pristup, ali u stvarnim projektima preimenovanje stupaca često predstavlja bolje i praktičnije rješenje. Zadatak 9.7 - funkcija pivot_longer # stvorite podatkovni okvir `ocjene` uz pomoć funkcije `pivot_longer` i okvira `studenti` # proučite okvir `ocjene` ocjene &lt;- pivot_longer(studenti, cols = `Matematika 1`:`Algoritmi 1`, names_to = &quot;Predmet&quot;, values_to = &quot;Ocjena&quot;, values_drop_na = T) glimpse(ocjene) head(ocjene) ## Rows: 168 ## Columns: 5 ## $ JMBAG &lt;dbl&gt; 1341, 1341, 1341, 1341, 1341, 1342, 1342, 1342, 1342, 1342, 13… ## $ Prezime &lt;chr&gt; &quot;Anić&quot;, &quot;Anić&quot;, &quot;Anić&quot;, &quot;Anić&quot;, &quot;Anić&quot;, &quot;Babić&quot;, &quot;Babić&quot;, &quot;Bab… ## $ Ime &lt;chr&gt; &quot;Iva&quot;, &quot;Iva&quot;, &quot;Iva&quot;, &quot;Iva&quot;, &quot;Iva&quot;, &quot;Josip&quot;, &quot;Josip&quot;, &quot;Josip&quot;, … ## $ Predmet &lt;chr&gt; &quot;Matematika 1&quot;, &quot;Fizika 1&quot;, &quot;Digitalna logika&quot;, &quot;Matematika 2&quot;… ## $ Ocjena &lt;int&gt; 2, 2, 4, 2, 2, 5, 3, 4, 3, 5, 5, 4, 3, 4, 2, 3, 4, 3, 2, 5, 2,… ## # A tibble: 6 × 5 ## JMBAG Prezime Ime Predmet Ocjena ## &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; ## 1 1341 Anić Iva Matematika 1 2 ## 2 1341 Anić Iva Fizika 1 2 ## 3 1341 Anić Iva Digitalna logika 4 ## 4 1341 Anić Iva Matematika 2 2 ## 5 1341 Anić Iva Algoritmi 1 2 ## 6 1342 Babić Josip Matematika 1 5 Funkcija koja radi inverzan posao od pivot_longer jest funkcija pivot_wider. Ona će podatke iz kombinacije kategorijskog stupca i vrijednosti “raširiti” tako da kategorije postaju nazivi stupaca a vrijednosti se “raspršuju” po odgovarajućim stupcima. Potpis funkcije izgleda ovako: pivot_wider(data, names_from, names_prefix = &quot;&quot;, values_from, values_fill = NULL) Dokumentaciju ove funkcije lako dohvaćamo naredbom ?pivot_wider a neke elemente već možemo lako prepoznati korištenjem znanja kako radi funkcija pivot_longer. Parametri koje možda treba dodatno pojasniti su: data podatkovni okvir names_from ime stupaca čije vrijednosti “pivotiramo” u široki oblik names_prefix opcionalni prefiks (bez navodnika) kojeg možemo staviti novim stupcima, korisno ako su novi nazivi stupaca brojevi values_from ime stupca u kojem se nalaze vrijednosti koje raspršujemo po novoj tablici values_fill opcionalna vrijednost za nedostajuće vrijednosti; ako parametar stavimo na NULL vrijednosti će biti NA Zadatak 9.8 - funkcija pivot_wider # &quot;raširite&quot; podatkovni okvir `ocjene` uz pomoć naredbe `pivot_wider` # rezultat pohranite u okvir `studenti2` # proučite okvire `studenti` i `studenti2` studenti2 &lt;- pivot_wider(ocjene, names_from = Predmet, values_from = Ocjena) head(studenti) head(studenti2) glimpse(studenti) glimpse(studenti2) ## # A tibble: 6 × 10 ## JMBAG Prezime Ime `Matematika 1` `Fizika 1` Programiranje ## &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; ## 1 1341 Anić Iva 2 2 NA ## 2 1342 Babić Josip 5 3 4 ## 3 1343 Crnoja Petra 4 3 4 ## 4 1344 Črnjac Lucija 2 5 2 ## 5 1345 Dizla Stipe NA 4 3 ## 6 1346 Ermić Igor NA 3 NA ## # ℹ 4 more variables: `Osnove elektrotehnike` &lt;int&gt;, `Digitalna logika` &lt;int&gt;, ## # `Matematika 2` &lt;int&gt;, `Algoritmi 1` &lt;int&gt; ## # A tibble: 6 × 10 ## JMBAG Prezime Ime `Matematika 1` `Fizika 1` `Digitalna logika` ## &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; ## 1 1341 Anić Iva 2 2 4 ## 2 1342 Babić Josip 5 3 NA ## 3 1343 Crnoja Petra 4 3 3 ## 4 1344 Črnjac Lucija 2 5 3 ## 5 1345 Dizla Stipe NA 4 2 ## 6 1346 Ermić Igor NA 3 5 ## # ℹ 4 more variables: `Matematika 2` &lt;int&gt;, `Algoritmi 1` &lt;int&gt;, ## # Programiranje &lt;int&gt;, `Osnove elektrotehnike` &lt;int&gt; ## Rows: 27 ## Columns: 10 ## $ JMBAG &lt;dbl&gt; 1341, 1342, 1343, 1344, 1345, 1346, 1347, 1348… ## $ Prezime &lt;chr&gt; &quot;Anić&quot;, &quot;Babić&quot;, &quot;Crnoja&quot;, &quot;Črnjac&quot;, &quot;Dizla&quot;, … ## $ Ime &lt;chr&gt; &quot;Iva&quot;, &quot;Josip&quot;, &quot;Petra&quot;, &quot;Lucija&quot;, &quot;Stipe&quot;, &quot;I… ## $ `Matematika 1` &lt;int&gt; 2, 5, 4, 2, NA, NA, NA, 3, 3, 4, 2, 4, 5, 3, 4… ## $ `Fizika 1` &lt;int&gt; 2, 3, 3, 5, 4, 3, 3, 4, 2, 2, NA, 2, 4, NA, 5,… ## $ Programiranje &lt;int&gt; NA, 4, 4, 2, 3, NA, 3, 3, 3, 4, 3, 5, 2, 4, 4,… ## $ `Osnove elektrotehnike` &lt;int&gt; NA, 3, 2, 2, 5, 5, 3, 4, 2, 2, 3, 2, 4, 5, 2, … ## $ `Digitalna logika` &lt;int&gt; 4, NA, 3, 3, 2, 5, 2, 4, 3, 5, 2, 4, 3, NA, 5,… ## $ `Matematika 2` &lt;int&gt; 2, 5, 4, 3, 2, 5, 2, 5, NA, 4, 2, 5, 2, 3, 4, … ## $ `Algoritmi 1` &lt;int&gt; 2, 5, 3, 4, 2, 5, 5, 4, 3, 2, 4, 2, 3, NA, 3, … ## Rows: 27 ## Columns: 10 ## $ JMBAG &lt;dbl&gt; 1341, 1342, 1343, 1344, 1345, 1346, 1347, 1348… ## $ Prezime &lt;chr&gt; &quot;Anić&quot;, &quot;Babić&quot;, &quot;Crnoja&quot;, &quot;Črnjac&quot;, &quot;Dizla&quot;, … ## $ Ime &lt;chr&gt; &quot;Iva&quot;, &quot;Josip&quot;, &quot;Petra&quot;, &quot;Lucija&quot;, &quot;Stipe&quot;, &quot;I… ## $ `Matematika 1` &lt;int&gt; 2, 5, 4, 2, NA, NA, NA, 3, 3, 4, 2, 4, 5, 3, 4… ## $ `Fizika 1` &lt;int&gt; 2, 3, 3, 5, 4, 3, 3, 4, 2, 2, NA, 2, 4, NA, 5,… ## $ `Digitalna logika` &lt;int&gt; 4, NA, 3, 3, 2, 5, 2, 4, 3, 5, 2, 4, 3, NA, 5,… ## $ `Matematika 2` &lt;int&gt; 2, 5, 4, 3, 2, 5, 2, 5, NA, 4, 2, 5, 2, 3, 4, … ## $ `Algoritmi 1` &lt;int&gt; 2, 5, 3, 4, 2, 5, 5, 4, 3, 2, 4, 2, 3, NA, 3, … ## $ Programiranje &lt;int&gt; NA, 4, 4, 2, 3, NA, 3, 3, 3, 4, 3, 5, 2, 4, 4,… ## $ `Osnove elektrotehnike` &lt;int&gt; NA, 3, 2, 2, 5, 5, 3, 4, 2, 2, 3, 2, 4, 5, 2, … U prethodnom primjeru demonstrirali smo inverznu funkcionalnost funkcija pivot_longer i pivot_wider ali narednom pivot_wider nismo postigli uredne podatke, samo smo se vratili na originalni okvir. Pogledajmo sada primjer gdje upravo naredbom pivot_wider “sređujemo” podatke. Učitajmo podatke iz datoteke auti.csv koja pohranjuje tehničke karakteristike određenih automobila. Zadatak 9.9 - podatkovni skup auti # učitajte datoteku `auti.csv` u podatkovni okvir naziva `auti` # proučite okvir `auti` auti &lt;- read_csv(&quot;auti.csv&quot;, col_types = &quot;ccn&quot;) glimpse(auti) head(auti) ## Rows: 18 ## Columns: 3 ## $ `Model auta` &lt;chr&gt; &quot;Opel Astra&quot;, &quot;Opel Astra&quot;, &quot;Opel Astra&quot;, &quot;O… ## $ `Tehnicka karakteristika` &lt;chr&gt; &quot;Cilindara&quot;, &quot;KS&quot;, &quot;Dužina m&quot;, &quot;Masa kg&quot;, &quot;C… ## $ Vrijednost &lt;dbl&gt; 4.000, 125.000, 4.267, 1285.000, 4.000, 136.… ## # A tibble: 6 × 3 ## `Model auta` `Tehnicka karakteristika` Vrijednost ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 Opel Astra Cilindara 4 ## 2 Opel Astra KS 125 ## 3 Opel Astra Dužina m 4.27 ## 4 Opel Astra Masa kg 1285 ## 5 Audi A4 Cilindara 4 ## 6 Audi A4 KS 136 U ovoj tablici očito je narušen princip urednih podataka da u jedan stupac treba biti pohranjen samo jedan tip varijable - tehničke karakteristike automobila smještene su u jedinstveni stupac naziva Tehnicka.karakteristika a u stupcu Vrijednost nalaze se vrijednosti vrlo različitih tipova (masa u kg, dužina u m i sl.). Pokušajte urediti ovaj okvir uz pomoć naredbe pivot_wider. Zadatak 9.10 - funkcija pivot_wider (2) # stvorite okvir `auti2` koji će biti uređena inačica okvira `auti` # proučite okvir `auti2` auti2 &lt;- pivot_wider(auti, names_from = `Tehnicka karakteristika`, values_from = Vrijednost) glimpse(auti2) head(auti2) ## Rows: 5 ## Columns: 6 ## $ `Model auta` &lt;chr&gt; &quot;Opel Astra&quot;, &quot;Audi A4&quot;, &quot;Renault Grand Scenic&quot;, &quot;Citroen… ## $ Cilindara &lt;dbl&gt; 4, 4, 4, 6, 2 ## $ KS &lt;dbl&gt; 125, 136, 110, 215, 103 ## $ `Dužina m` &lt;dbl&gt; 4.267, 4.703, 4.560, NA, NA ## $ `Masa kg` &lt;dbl&gt; 1285, 1470, NA, 1816, 1260 ## $ Ventila &lt;dbl&gt; NA, NA, 16, NA, NA ## # A tibble: 5 × 6 ## `Model auta` Cilindara KS `Dužina m` `Masa kg` Ventila ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Opel Astra 4 125 4.27 1285 NA ## 2 Audi A4 4 136 4.70 1470 NA ## 3 Renault Grand Scenic 4 110 4.56 NA 16 ## 4 Citroen C6 6 215 NA 1816 NA ## 5 Fiat 500L 2 103 NA 1260 NA Naredbe pivot_longer i pivot_wider ne koriste se samo za “neuredne” podatke. One mogu biti vrlo korisne kod pretvorbe tzv. “širokih” podatka (wide data) u “dugačke” (long data). Prikažimo ovo na primjeru tzv. podataka o potrošačkim košaricama. Potrošačka košarica predstavlja zapis artikala koje je kupac kupio tijekom jednog dolaska u trgovinu (bilo da se radi o virtualnoj trgovini ili stvarnom prodajnom mjestu). Ako podatke o potrošačkoj košarici zapisujemo u “širokom” formatu, onda podatke organiziramo tako da stupci predstavljaju pojedine artikle a retci jednu kupnju (ili račun). Vrijednost 1 znači da se artikl našao u košarici, 0 da nije bio prisutan. Ovakav prikaz pogodan je za različite tipove analiza, ali nije ekonomičan - podaci će često imati jako puno “nula”. S druge strane, “dugački” format jednostavno u svaki redak stavlja kombinaciju identifikatora košarice (ili broja računa) i naziv (ili šifru) kupljenog artikla. Ovakav zapis imati će znatno više redaka, ali je znatno pogodniji u slučajevima kada je broj artikala u asortimanu daleko veći od broja artikala u prosječnoj košarici. Zadatak 9.11 - podatkovni skup potrosackaKosarica # učitajte podatke iz datoteke `potrosackaKosarica.csv` u podatkovni okvir imena `racuni` # proučite okvir `racuni` racuni &lt;- read_csv(&quot;potrosackaKosarica.csv&quot;, show_col_types = F) glimpse(racuni) head(racuni) ## Rows: 104 ## Columns: 21 ## $ racunID &lt;dbl&gt; 15671, 15672, 15673, 15674, 15675, 15676, 15677, 156… ## $ `Coca cola 2l` &lt;dbl&gt; 0, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0… ## $ `Čipi Čips` &lt;dbl&gt; 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1… ## $ `Nutella 400 g` &lt;dbl&gt; 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 1, 1, 0, 0, 0, 0… ## $ `Karlovačko pivo` &lt;dbl&gt; 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0… ## $ `Ožujsko pivo` &lt;dbl&gt; 1, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0… ## $ `Omekšivač 1.5l` &lt;dbl&gt; 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 1, 0, 1, 1… ## $ `Voda 2l` &lt;dbl&gt; 0, 0, 1, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 0, 1, 0, 1, 0… ## $ Naranče &lt;dbl&gt; 0, 0, 0, 1, 1, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0… ## $ Jabuke &lt;dbl&gt; 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0… ## $ Mandarine &lt;dbl&gt; 0, 0, 1, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 1, 0, 0, 1… ## $ Salvete &lt;dbl&gt; 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0… ## $ Ajvar &lt;dbl&gt; 0, 0, 1, 1, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 1… ## $ Ketchup &lt;dbl&gt; 1, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0… ## $ Senf &lt;dbl&gt; 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0… ## $ `Mlijeko 0.5l` &lt;dbl&gt; 0, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 0… ## $ `Kiselo vrhnje` &lt;dbl&gt; 0, 1, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0… ## $ `Feta sir` &lt;dbl&gt; 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0… ## $ Sardine &lt;dbl&gt; 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1… ## $ `Tuna pašteta` &lt;dbl&gt; 1, 1, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1… ## $ Nescaffe &lt;dbl&gt; 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 1, 1, 0, 0… ## # A tibble: 6 × 21 ## racunID `Coca cola 2l` `Čipi Čips` `Nutella 400 g` `Karlovačko pivo` ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 15671 0 0 0 0 ## 2 15672 1 0 1 1 ## 3 15673 1 1 0 0 ## 4 15674 0 0 0 0 ## 5 15675 1 0 1 0 ## 6 15676 0 0 0 0 ## # ℹ 16 more variables: `Ožujsko pivo` &lt;dbl&gt;, `Omekšivač 1.5l` &lt;dbl&gt;, ## # `Voda 2l` &lt;dbl&gt;, Naranče &lt;dbl&gt;, Jabuke &lt;dbl&gt;, Mandarine &lt;dbl&gt;, ## # Salvete &lt;dbl&gt;, Ajvar &lt;dbl&gt;, Ketchup &lt;dbl&gt;, Senf &lt;dbl&gt;, ## # `Mlijeko 0.5l` &lt;dbl&gt;, `Kiselo vrhnje` &lt;dbl&gt;, `Feta sir` &lt;dbl&gt;, ## # Sardine &lt;dbl&gt;, `Tuna pašteta` &lt;dbl&gt;, Nescaffe &lt;dbl&gt; Ukoliko želimo pohraniti podatkovni okvir u CSV datoteku, za to možemo koristiti jednostavnu funkciju write_csv. Ova funkcija ima niz potencijalno korisnih parametara, no najvažniji su podatkovni okvir kojeg pohranjujemo, te datoteka u koju isti spremamo. Zadatak 9.12 - pretvorba okvira u ‘dugi’ format # pretvorite podatke okvira `racuni` iz &quot;širokog&quot; formata u &quot;dugi&quot; # rezultat pohranite u datoteku &#39;potrosackaKosaricaDugiFormat.csv&#39; # pretvorite podatke okvira `racuni` iz &quot;širokog&quot; formata u &quot;dugi&quot; racuniDugi &lt;- pivot_longer(racuni, cols = -racunID, names_to = &quot;artikl&quot;, values_to = &quot;vrijednost&quot;) # moramo još malo &quot;popraviti&quot; okvir racuniDugi &lt;- racuniDugi[racuniDugi$vrijednost != 0, 1:2] racuniDugi &lt;- racuniDugi[order(racuniDugi$racunID), ] head(racuniDugi) # rezultat pohranite u datoteku &#39;potrosackaKosaricaDugiFormat.csv&#39; write_csv(racuniDugi, file = &#39;potrosackaKosaricaDugiFormat.csv&#39;) ## # A tibble: 6 × 2 ## racunID artikl ## &lt;dbl&gt; &lt;chr&gt; ## 1 15671 Ožujsko pivo ## 2 15671 Jabuke ## 3 15671 Ketchup ## 4 15671 Senf ## 5 15671 Tuna pašteta ## 6 15672 Coca cola 2l Zadatak 9.13 - pretvorba okvira u ‘široki’ format # pokušajte &quot;dugi&quot; format oblikovati natrag u &quot;široki&quot; # pohranite rezultat u datoteku `potrosackaKosaricaSirokiFormat.csv` # pripremamo okvir - dodajemo vrijednosti za &quot;raspršivanje&quot; racuniSiroki &lt;- racuniDugi racuniSiroki$vrijednost &lt;- 1 racuniSiroki &lt;- pivot_wider(racuniSiroki, names_from = artikl, values_from = vrijednost, values_fill = 0) head(racuniSiroki,3) # pohranite rezultat u datoteku `potrosackaKosaricaSirokiFormat.csv` write_csv(racuniSiroki, file = &#39;potrosackaKosaricaSirokiFormat.csv&#39;) ## # A tibble: 3 × 21 ## racunID `Ožujsko pivo` Jabuke Ketchup Senf `Tuna pašteta` `Coca cola 2l` ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 15671 1 1 1 1 1 0 ## 2 15672 0 0 0 0 1 1 ## 3 15673 0 0 0 0 1 1 ## # ℹ 14 more variables: `Nutella 400 g` &lt;dbl&gt;, `Karlovačko pivo` &lt;dbl&gt;, ## # `Mlijeko 0.5l` &lt;dbl&gt;, `Kiselo vrhnje` &lt;dbl&gt;, `Čipi Čips` &lt;dbl&gt;, ## # `Voda 2l` &lt;dbl&gt;, Mandarine &lt;dbl&gt;, Ajvar &lt;dbl&gt;, Nescaffe &lt;dbl&gt;, ## # Naranče &lt;dbl&gt;, `Feta sir` &lt;dbl&gt;, Salvete &lt;dbl&gt;, `Omekšivač 1.5l` &lt;dbl&gt;, ## # Sardine &lt;dbl&gt; 9.2.2 Funkcije separate i unite Paket tidyr ima još niz korisnih funkcija namijenjenih “uređivanju” podataka a mi ćemo ovdje obratiti još dvije koje se relativno često koriste - separate i unite. Funkcija separate je korisna kada neki stupac ima “složene” vrijednosti koje želimo rastaviti u dva ili više stupaca. Zadatak 9.14 - podatkovni skup odjeli # čitajte podatke iz datoteke `odjeli.csv` u varijablu `odjeli` # proučite okvir `odjeli` odjeli &lt;- read_csv(&quot;odjeli_csv&quot;, show_col_types = = F) glimpse(odjeli) head(odjeli) ## Rows: 28 ## Columns: 4 ## $ Odjel &lt;chr&gt; &quot;A&quot;, &quot;A&quot;, &quot;A&quot;, &quot;A&quot;, &quot;A&quot;, &quot;A&quot;, &quot;A&quot;, &quot;B&quot;, &quot;B&quot;, &quot;B&quot;, &quot;B&quot;, &quot;B&quot;, &quot;… ## $ Kvartal &lt;chr&gt; &quot;Q1-2015&quot;, &quot;Q2-2015&quot;, &quot;Q3-2015&quot;, &quot;Q4-2015&quot;, &quot;Q1-2016&quot;, &quot;Q2-20… ## $ PrihodKn &lt;dbl&gt; 12416.2, 224290.1, 10643.7, 191229.3, 258697.4, 121865.3, 183… ## $ RashodKn &lt;dbl&gt; 23100.5, 63886.1, 35467.8, 12249.1, 61514.6, 46092.6, 16096.6… ## # A tibble: 6 × 4 ## Odjel Kvartal PrihodKn RashodKn ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 A Q1-2015 12416. 23100. ## 2 A Q2-2015 224290. 63886. ## 3 A Q3-2015 10644. 35468. ## 4 A Q4-2015 191229. 12249. ## 5 A Q1-2016 258697. 61515. ## 6 A Q2-2016 121865. 46093. Ova tablica prikazuje prihode i rashode odjela neke tvrtke po kvartalima. Kvartali su trenutno pohranjeni u složenu varijablu Kvartal koja se sastoji od identifikatora godišnjeg kvartala (Q1, Q2, Q3 ili Q4) i godine. Za potrebe analize vjerojatno bi bilo zgodno ovo rastaviti u dva stupca - Kvartal (koji bi pohranjivao samo identifikator kvartala) i Godina. Paket tidyr za ovakve potrebe nudi funkciju separate sa sljedećim potpisom: separate(data, col, into, sep = &quot;[^[:alnum:]]+&quot;, remove = TRUE, convert = FALSE, extra = &quot;warn&quot;, fill = &quot;warn&quot;, ...) Potpunu dokumentaciju funkcije možemo pogledati naredbom ?separate a ovdje ćemo navesti objašnjenje nekih važnijih parametara: col - stupac kojeg rastavljamo (ne moramo koristiti navodnike) into - imena novih stupaca (preporučuje se koristiti znakovni vektor) sep - separator vrijednosti u originalnom stupcu, default-na vrijednost je zapravo regularni izraz za “nešto što nije alfanumerički znak” remove - opisuje da li je potrebno ukloniti originalni stupac ili ne Pokušajmo primijeniti ovu funkciju na tablicu odjeli. Ponovimo usput princip korištenja pipeline operatora. Zadatak 9.15 - funkcija separate # razdvojite stupac `Kvartal` u stupce `Kvartal` i `Godina` uz uklanjanje originalnog stupca # rezultat pohranite u varijablu `odjeli2` # sve učinite u sklopu jedne naredbe uz pomoć `%&gt;%` operatora # proučite okvir `odjeli2` odjeli %&gt;% separate(Kvartal, c(&quot;Kvartal&quot;, &quot;Godina&quot;), &quot;-&quot;) -&gt; odjeli2 glimpse(odjeli2) head(odjeli2) ## Rows: 28 ## Columns: 5 ## $ Odjel &lt;chr&gt; &quot;A&quot;, &quot;A&quot;, &quot;A&quot;, &quot;A&quot;, &quot;A&quot;, &quot;A&quot;, &quot;A&quot;, &quot;B&quot;, &quot;B&quot;, &quot;B&quot;, &quot;B&quot;, &quot;B&quot;, &quot;… ## $ Kvartal &lt;chr&gt; &quot;Q1&quot;, &quot;Q2&quot;, &quot;Q3&quot;, &quot;Q4&quot;, &quot;Q1&quot;, &quot;Q2&quot;, &quot;Q3&quot;, &quot;Q1&quot;, &quot;Q2&quot;, &quot;Q3&quot;, &quot;… ## $ Godina &lt;chr&gt; &quot;2015&quot;, &quot;2015&quot;, &quot;2015&quot;, &quot;2015&quot;, &quot;2016&quot;, &quot;2016&quot;, &quot;2016&quot;, &quot;2015… ## $ PrihodKn &lt;dbl&gt; 12416.2, 224290.1, 10643.7, 191229.3, 258697.4, 121865.3, 183… ## $ RashodKn &lt;dbl&gt; 23100.5, 63886.1, 35467.8, 12249.1, 61514.6, 46092.6, 16096.6… ## # A tibble: 6 × 5 ## Odjel Kvartal Godina PrihodKn RashodKn ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 A Q1 2015 12416. 23100. ## 2 A Q2 2015 224290. 63886. ## 3 A Q3 2015 10644. 35468. ## 4 A Q4 2015 191229. 12249. ## 5 A Q1 2016 258697. 61515. ## 6 A Q2 2016 121865. 46093. Uočite da su stupci Kvartal i Godina zapravo kategorijske varijable i da bi ih bilo dobro faktorizirati. Faktoriziranje stupaca je nešto teže izvesti uz pomoć pipeline operatora (iako je izvedivo!) no u narednim poglavljima naučiti ćemo kako to puno lakše napraviti uz pomoć funkcija iz paketa dplyr. Funkcija separate se često koristi za rastavljanje datuma (npr. 2016-10-28 u godinu, mjesec i dan) no u takvim situacijama preporuka je koristiti paket lubridate koji je stvoren upravo za lakše upravljanje datumima. Ovaj paket upoznati ćemo u jednom od sljedećih poglavlja. Za kraj naučimo još funkciju unite koja se nešto rijeđe koristi a zapravo je inverz funkcije separate. Potpis funkcije unite je: unite(data, col, ..., sep = &quot;_&quot;, remove = TRUE) I u ovom slučaju dokumentaciju lako dohvaćamo sa ?unite, a ovdje dajemo opis parametara koji potencijalno zahtijevaju dodatno objašnjenje: col - ime novog stupca (nije nužno koristiti navodnike) ... - imena stupaca koje spajamo - ne moramo koristiti navodnike, a ukoliko ima puno stupaca možemo se koristiti sličnom sintaksom za odabir kao i kod funkcije pivot_longer Isprobajmo naredbu na okviru odjeli2. Zadatak 9.16 - funkcija unite # spojite stupce `Kvartal` i `Godina` iz tablice `odjeli2` u jedinstven stupac `Kvartal` # uklonite stupce `Kvartal` i `Godina` # koristite `-` kao separator # spremite rezultat u varijablu `odjeli3` # sve ovo izvedite u sklopu jedne naredbe uz pomoć `%&gt;%` operatora # proučite okvire `odjeli` i `odjeli3` odjeli2 %&gt;% unite(Kvartal, Kvartal, Godina, sep = &quot;-&quot;) -&gt; odjeli3 glimpse(odjeli) cat(&quot;----------------\\n&quot;) glimpse(odjeli3) cat(&quot;----------------\\n&quot;) head(odjeli) cat(&quot;----------------\\n&quot;) head(odjeli3) ## Rows: 28 ## Columns: 4 ## $ Odjel &lt;chr&gt; &quot;A&quot;, &quot;A&quot;, &quot;A&quot;, &quot;A&quot;, &quot;A&quot;, &quot;A&quot;, &quot;A&quot;, &quot;B&quot;, &quot;B&quot;, &quot;B&quot;, &quot;B&quot;, &quot;B&quot;, &quot;… ## $ Kvartal &lt;chr&gt; &quot;Q1-2015&quot;, &quot;Q2-2015&quot;, &quot;Q3-2015&quot;, &quot;Q4-2015&quot;, &quot;Q1-2016&quot;, &quot;Q2-20… ## $ PrihodKn &lt;dbl&gt; 12416.2, 224290.1, 10643.7, 191229.3, 258697.4, 121865.3, 183… ## $ RashodKn &lt;dbl&gt; 23100.5, 63886.1, 35467.8, 12249.1, 61514.6, 46092.6, 16096.6… ## ---------------- ## Rows: 28 ## Columns: 4 ## $ Odjel &lt;chr&gt; &quot;A&quot;, &quot;A&quot;, &quot;A&quot;, &quot;A&quot;, &quot;A&quot;, &quot;A&quot;, &quot;A&quot;, &quot;B&quot;, &quot;B&quot;, &quot;B&quot;, &quot;B&quot;, &quot;B&quot;, &quot;… ## $ Kvartal &lt;chr&gt; &quot;Q1-2015&quot;, &quot;Q2-2015&quot;, &quot;Q3-2015&quot;, &quot;Q4-2015&quot;, &quot;Q1-2016&quot;, &quot;Q2-20… ## $ PrihodKn &lt;dbl&gt; 12416.2, 224290.1, 10643.7, 191229.3, 258697.4, 121865.3, 183… ## $ RashodKn &lt;dbl&gt; 23100.5, 63886.1, 35467.8, 12249.1, 61514.6, 46092.6, 16096.6… ## ---------------- ## # A tibble: 6 × 4 ## Odjel Kvartal PrihodKn RashodKn ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 A Q1-2015 12416. 23100. ## 2 A Q2-2015 224290. 63886. ## 3 A Q3-2015 10644. 35468. ## 4 A Q4-2015 191229. 12249. ## 5 A Q1-2016 258697. 61515. ## 6 A Q2-2016 121865. 46093. ## ---------------- ## # A tibble: 6 × 4 ## Odjel Kvartal PrihodKn RashodKn ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 A Q1-2015 12416. 23100. ## 2 A Q2-2015 224290. 63886. ## 3 A Q3-2015 10644. 35468. ## 4 A Q4-2015 191229. 12249. ## 5 A Q1-2016 258697. 61515. ## 6 A Q2-2016 121865. 46093. Zadaci za vježbu Inicijalizirajte generator slučajnih brojeva uz pomoć naredbe set.seed(1234). Potom uz pomoć jedne naredbe i %&gt;% operatora izvedite sljedeće: stvorite 100000 nasumičnih brojeva izvučenih iz normalne razdiobe za aritmetičkom sredinom 10000 i standardnom devijacijom 1000 zaokružite brojeve na prvi veći cijeli broj izbacite duplikate iz skupa poredajte skup po veličini slučajnim odabirom iz skupa izvucite 100 elemenata organizirajte tih 100 elemenata u matricu 10 x 10, složenu po retcima izračunajte sume redaka matrice ispišite prosjek suma redaka na zaslon. U datoteci weather.csv nalaze se podaci o izmjerenim vremenskim uvjetima od strane meteorološke stanice koja svaki sat vremena mjeri temperaturu, tlak, vlažnost i brzinu vjetra (podaci su preuzeti i prilagođeni iz podatkovnog skupa paketa weatherData dostupnog na CRAN-u). Izvedite sljedeće: učitajte datoteku u podatkovni okvir i proučite učitane podatke (names, str, summary, head…) odgovorite: da li se radi o urednim podacima? Zašto? poduzmite odgovarajuće korake kako bi dobili podatkovni okvir koji odgovara principu urednih podataka spremite “uređeni” u okvir u datoteku weatherClean.csv Programirajmo u R-u by Damir Pintar is licensed under a Creative Commons Attribution-NonCommercial-NoDerivatives 4.0 International License.Based on a work at https://ratnip.github.io/FER_OPJR/ References "],["datumi.html", "10 Rad sa vremenskim podacima 10.1 Rad sa datumima 10.2 Klase POSIXct i POSIXlt 10.3 Paket lubridate Zadaci za vježbu", " 10 Rad sa vremenskim podacima 10.1 Rad sa datumima Upravljanje datumima i vremenskim oznakama uvijek predstavlja izazov kod rada sa podatkovnim skupovima budući da moramo voditi računa o stvarima kao što su: različiti oblici prikaza datuma i vremena različite interne reprezentacije različite vremenske zone razlika između matematičkog i kalendarskog poimanja vremenskih perioda Jedan od češće korištenih standarda je tzv “unix vrijeme” (ili “POSIX vrijeme”) koja vrijeme računa kao broj sekundi protekao od ponoći 1. siječnja 1970. UTC (Coordinated Universal Time). Ne koriste svi informacijski sustavi POSIX vrijeme; npr. Microsoft Excel ima svoj format gdje broji dane od 1.1.1900., a onda za određeni dan broj sati, minuta i sekundi protekao od ponoći. Programski jezik R ima tri klase za upravljanje datumima / vremenskim oznakama: Date za prikaz datuma POSIXct za kompaktni prikaz vremenske oznake POSIXlt za “dugi” prikaz vremenske oznake (u obliku liste) 10.1.1 Klasa Date Klasu Date koristimo kada nas zanima datum ali ne i vrijeme neke obzervacije ili poslovnog događaja. Ova klasa nema svoj konstruktor, već objekte ovog tipa (najčešće) stvaramo uz pomoć sljedećih funkcija: Sys.Date() koja vraća današnji datum as.Date() kojoj kao parametar prosljeđujemo znakovni niz koji reprezentira datum Funkcija as.Date() po default-u prihvaća datume oblika %Y-%m-%d, gdje %Y predstavlja četveroznamenkastu godinu a %m i %d dvoznamenkasti mjesec i dan. Ukoliko želimo interpretirati datum koji je zapisan u nekom drugom obliku onda moramo funkciji dodati parametar format koji će parametarski opisati oblik kojeg koristimo (npr. za 28/10/1978 bi vrijednost parametra format trebala biti %d/%m/%Y). Sve moguće oblikovne specifikacije mogu se pogledati uz pomoć naredbe ?strptime iako, kao što ćemo se uvjeriti kasnije, jednostavnija metoda jest koristiti se funkcijama paketa lubridate. Zadatak 10.1 - klasa Date # ispišite današnji datum # pretvorite sljedeće znakovne nizove u objekt tipa `Date` i ispišite rezultat na zaslon: # &#39;1986-12-27&#39;,&#39;2016-31-05&#39;, &#39;17. 10. 2015.&#39;, &#39;01#01#2001&#39; # ispišite današnji datum Sys.Date() # pretvorite sljedeće znakovne nizove u objekt tipa `Date` i ispišite rezultat na zaslon: # &#39;1986-12-27&#39;,&#39;2016-31-05&#39;, &#39;17. 10. 2015.&#39;, &#39;01#01#2001&#39; as.Date(&#39;1986-12-27&#39;) as.Date(&#39;2016-31-05&#39;, format = &#39;%Y-%d-%m&#39;) as.Date(&#39;17. 10. 2015.&#39;, format = &#39;%d. %m. %Y&#39;) as.Date(&#39;01#01#2001&#39;, format = &#39;%d#%m#%Y&#39;) ## [1] &quot;2024-01-18&quot; ## [1] &quot;1986-12-27&quot; ## [1] &quot;2016-05-31&quot; ## [1] &quot;2015-10-17&quot; ## [1] &quot;2001-01-01&quot; Sa datumima možemo raditi jednostavne računske operacije kao što je dodavanje i oduzimanje dana (koristimo operatore + i - i cijele brojeve) ili razliku u danima između dva datuma (operator -). Zadatak 10.2 - aritmetika s datumima # ispišite koji je datum bio 1000 dana prije današnjeg datuma # dodajte jedan dan datumima 28.2.2015. i 28.2.2016 i ispišite rezultat # ispišite koliko je dana prošlo od 1.1.2000. do danas # ispišite koji je datum bio 1000 dana prije današnjeg datuma Sys.Date() - 1000 # dodajte jedan dan datumima 28.2.2015. i 28.2.2016 i ispišite rezultat as.Date(&#39;2015-02-28&#39;) + 1 as.Date(&#39;2016-02-28&#39;) + 1 # ispišite koliko je dana prošlo od 1.1.2000. do danas Sys.Date() - as.Date(&#39;2000-01-01&#39;) ## [1] &quot;2021-04-23&quot; ## [1] &quot;2015-03-01&quot; ## [1] &quot;2016-02-29&quot; ## Time difference of 8783 days Zadnji izraz će zapravo rezultirati objektom klase difftime koja označava vremenski interval. Ispis koristi tzv. “automatski” odabir jedinice (konkretno, parametar units postavljen na \"auto\") koji će pokušati odabrati najprikladniju vremensku jedinicu za ispis. Ukoliko želimo eksplicitno odabrati koju vremensku jedinicu želimo (sekunde, minute, sate, dane ili tjedne) onda možemo umjesto operatora - koristiti funkciju difftime uz parametar units postavljen na znakovni niz odabrane vremenski jedinice (\"seconds\", \"minutes\", itd.). Zadatak 10.3 - funkcija difftime # Koliko je prošlo tjedana između 1.3.2016. i 1.3.2015.? # koristite funkciju `difftime` # NAPOMENA: ne morate eksplicitno pozvati funkciju `as.Date`, funkcija `difftime` # će to sama učiniti ako pošaljete datum u default-nom obliku # koliko je prošlo sati od 1.3.2015. do danas? # Koliko je prošlo tjedana između 1.3.2016. i 1.3.2015.? # koristite funkciju `difftime` # NAPOMENA: ne morate eksplicitno pozvati funkciju `as.Date`, funkcija `difftime` # će to sama učiniti ako pošaljete datum u default-nom obliku difftime(&#39;2016-03-01&#39;, &#39;2015-03-01&#39;, units = &quot;weeks&quot;) # koliko je prošlo sati od 1.3.2015. do danas? difftime(Sys.Date(), &#39;2015-03-01&#39;, units = &quot;hours&quot;) ## Time difference of 52.28571 weeks ## Time difference of 77881 hours Funkcija difftime zapravo radi i sa vremenskim oznakama, tj. ne moramo nužno raditi na razini datuma, već se možemo spustiti do razine sekunde. Ovo ćemo isprobati kada naučimo klasu POSIXct u nastavku. Isto tako, ako nam treba samo broj (sekundi, sati, dana i sl.), lako transformiramo izlaz u cijeli broj uz pomoć funkcije as.numeric. Jezik R implementira i posebnu varijantu funkcije seq za rad sa datumima koja ima sljedeći potpis: seq(from, to, by, length.out = NULL, along.with = NULL, ...) Parametri ove funkcije su sljedeći: from - početni datum (obvezni parametar) to - konačni datum by - korak sekvence u danima ili znakovni niz tipa \"7 days\", \"2 weeks\" i sl. (za sve mogućnosti pogledati dokumentaciju!) length.out - duljina sekvence along.with - vektor čiju duljinu uzimamo za referencu Isprobajmo ovu funkciju. Zadatak 10.4 - funkcija seq i datumi # ispišite sekvencu datuma od 1.1.2010. do 1.1.2030. u koracima od 6 mjeseci # napravite raspored čišćenja zajedničkih prostora za stambenu zgradu # prostori se moraju čistiti svaka 3 tjedna # svaki stan mora imati svoj datum čišćenja # stanovi su opisani sljedećim podatkovnim okvirom stanovi &lt;- data.frame(broj_stana = 1:10, prezime = c(&quot;Ebert&quot;, &quot;Ladovac&quot;, &quot;Cerić&quot;, &quot;Dikla&quot;, &quot;Anić&quot;, &quot;Perić&quot;, &quot;Žužić&quot;, &quot;Babić&quot;, &quot;Ibiz&quot;, &quot;Radler&quot;)) # dodajte stupac `ciscenje` sa po jednim datumom za svaki pojedini stan # redom po brojevima stana, za idućih 10 čišćenja počevši od današnjeg datuma # (za ambiciozne: dodajte 5 takvih stupaca koji će pokrivati 50 # nastupajućih čišćenja) # ispišite podatkovni okvir `stanovi` # ispišite sekvencu datuma od 1.1.2010. do 1.1.2030. u koracima od 6 mjeseci seq(as.Date(&#39;2010-01-01&#39;), as.Date(&#39;2030-01-01&#39;), by = &quot;6 months&quot;) # dodajte stupac `ciscenje` sa po jednim datumom za svaki pojedini stan # redom po brojevima stana, počevši od današnjeg datuma seq(Sys.Date(), by = &quot;3 weeks&quot;, along.with = stanovi$broj_stana) -&gt; stanovi$ciscenje # ispišite podatkovni okvir `stanovi` stanovi ## [1] &quot;2010-01-01&quot; &quot;2010-07-01&quot; &quot;2011-01-01&quot; &quot;2011-07-01&quot; &quot;2012-01-01&quot; ## [6] &quot;2012-07-01&quot; &quot;2013-01-01&quot; &quot;2013-07-01&quot; &quot;2014-01-01&quot; &quot;2014-07-01&quot; ## [11] &quot;2015-01-01&quot; &quot;2015-07-01&quot; &quot;2016-01-01&quot; &quot;2016-07-01&quot; &quot;2017-01-01&quot; ## [16] &quot;2017-07-01&quot; &quot;2018-01-01&quot; &quot;2018-07-01&quot; &quot;2019-01-01&quot; &quot;2019-07-01&quot; ## [21] &quot;2020-01-01&quot; &quot;2020-07-01&quot; &quot;2021-01-01&quot; &quot;2021-07-01&quot; &quot;2022-01-01&quot; ## [26] &quot;2022-07-01&quot; &quot;2023-01-01&quot; &quot;2023-07-01&quot; &quot;2024-01-01&quot; &quot;2024-07-01&quot; ## [31] &quot;2025-01-01&quot; &quot;2025-07-01&quot; &quot;2026-01-01&quot; &quot;2026-07-01&quot; &quot;2027-01-01&quot; ## [36] &quot;2027-07-01&quot; &quot;2028-01-01&quot; &quot;2028-07-01&quot; &quot;2029-01-01&quot; &quot;2029-07-01&quot; ## [41] &quot;2030-01-01&quot; ## broj_stana prezime ciscenje ## 1 1 Ebert 2024-01-18 ## 2 2 Ladovac 2024-02-08 ## 3 3 Cerić 2024-02-29 ## 4 4 Dikla 2024-03-21 ## 5 5 Anić 2024-04-11 ## 6 6 Perić 2024-05-02 ## 7 7 Žužić 2024-05-23 ## 8 8 Babić 2024-06-13 ## 9 9 Ibiz 2024-07-04 ## 10 10 Radler 2024-07-25 # (za ambiciozne: dodajte 5 takvih stupaca koji će pokrivati 50 # nastupajućih čišćenja) stanovi &lt;- data.frame(broj_stana = 1:10, prezime = c(&quot;Ebert&quot;, &quot;Ladovac&quot;, &quot;Cerić&quot;, &quot;Dikla&quot;, &quot;Anić&quot;, &quot;Perić&quot;, &quot;Žužić&quot;, &quot;Babić&quot;, &quot;Ibiz&quot;, &quot;Radler&quot;)) temp &lt;- data.frame(broj_stana = rep(stanovi$broj_stana, 5), ciklus = rep(1:5, each = nrow(stanovi)), ciscenje = seq(Sys.Date(), by = &quot;3 weeks&quot;, length.out = nrow(stanovi) * 5)) temp &lt;- pivot_wider(temp, names_from = ciklus, names_prefix = &quot;ciklus_&quot;, values_from = ciscenje) stanovi &lt;- cbind(stanovi, temp[, 2:6]) stanovi ## broj_stana prezime ciklus_1 ciklus_2 ciklus_3 ciklus_4 ciklus_5 ## 1 1 Ebert 2024-01-18 2024-08-15 2025-03-13 2025-10-09 2026-05-07 ## 2 2 Ladovac 2024-02-08 2024-09-05 2025-04-03 2025-10-30 2026-05-28 ## 3 3 Cerić 2024-02-29 2024-09-26 2025-04-24 2025-11-20 2026-06-18 ## 4 4 Dikla 2024-03-21 2024-10-17 2025-05-15 2025-12-11 2026-07-09 ## 5 5 Anić 2024-04-11 2024-11-07 2025-06-05 2026-01-01 2026-07-30 ## 6 6 Perić 2024-05-02 2024-11-28 2025-06-26 2026-01-22 2026-08-20 ## 7 7 Žužić 2024-05-23 2024-12-19 2025-07-17 2026-02-12 2026-09-10 ## 8 8 Babić 2024-06-13 2025-01-09 2025-08-07 2026-03-05 2026-10-01 ## 9 9 Ibiz 2024-07-04 2025-01-30 2025-08-28 2026-03-26 2026-10-22 ## 10 10 Radler 2024-07-25 2025-02-20 2025-09-18 2026-04-16 2026-11-12 10.2 Klase POSIXct i POSIXlt Klasa POSIXct nam je pogodna kada nam nije dosta samo pohraniti datum, već moramo znati i točno vrijeme za neku obzervaciju ili poslovni događaj. Objekt ove klase najčešće stvaramo uz pomoć sljedećih funkcija: Sys.time() koja vraća trenutnu vremensku oznaku uzimajući u obzir postavljenu vremensku zonu as.POSIXct() kojoj kao parametar prosljeđujemo znakovni niz koji predstavlja datum i vrijeme Funkcija as.POSIXct() kao parametar očekuje vremensku oznaku tipa %Y-%m-%d %H:%M:%S gdje su prve tri oblikovne specifikacije istovjetne već poznatoj specifikaciji datuma, dok %H, %M i %S predstavljaju dvoznamenkaste sate, minute i sekunde (gleda se 24-satni oblik prikaza vremena). Za parsiranje drugih oblika vremenskih oznaka potrebno je - kao i kod klase Date - dodati parametar format sa oblikovnom specifikacijom kako intepretirati zadani znakovni niz. Opet, za popis svih parametara nam pomaže poziv ?strptime, iako je u praksi poželjna opcija za lakši rad proučiti paket lubridate kojeg ćemo raditi kasnije. Funkciji as.POSIXct možemo dodati i parametar tz postavljen na znakovni niz koji definira vremensku zonu. Zadatak 10.5 - klasa POSIXct # ispišite trenutni datum i vrijeme # pretvorite sljedeće znakovne nizove u vremenske oznake i ispišite ih na zaslon: # &quot;2015-10-28 15:30:42&quot; # &quot;01-12-2001 14:30&quot; &lt;-- oznaka očitana u New York-u, SAD, vremenska zona EST # ispišite trenutni datum i vrijeme Sys.time() # pretvorite sljedeće znakovne nizove u vremenske oznake i ispišite ih na zaslon: # &quot;2015-10-28 15:30:42&quot; # &quot;01-12-2001 14:30&quot; &lt;-- oznaka očitana u New York-u, SAD, vremenska zona EST as.POSIXct(&quot;2015-10-28 15:30:42&quot;) as.POSIXct(&quot;01-12-2001 14:30&quot;, tz = &quot;EST&quot;, format = &quot;%d-%m-%Y %H:%M&quot;) ## [1] &quot;2024-01-18 13:05:40 CET&quot; ## [1] &quot;2015-10-28 15:30:42 CET&quot; ## [1] &quot;2001-12-01 14:30:00 EST&quot; Imena vremenskih zona su standardizirana (tzv. “Olsonove vremenske zone”) a dohvaćaju se uz pomoć operativnog sustava a možemo ih ispisati uz pomoć funkcije OlsonNames(). Trenutnu vremensku zonu platforme možemo ispisati uz pomoć funkcije Sys.timezone(). Zadatak 10.6 - vremenske zone # ispišite trenutnu vremensku zonu # ispišite 10 nasumično odabranih oznaka vremenskih zona instaliranih na trenutnoj platformi # ispišite trenutnu vremensku zonu Sys.timezone() # ispišite 10 nasumično odabranih oznaka vremenskih zona instaliranih na trenutnoj platformi sample(OlsonNames(), 10) ## [1] &quot;Europe/Zagreb&quot; ## [1] &quot;Europe/Tiraspol&quot; &quot;Etc/GMT+10&quot; &quot;US/East-Indiana&quot; ## [4] &quot;America/Recife&quot; &quot;GB&quot; &quot;America/Araguaina&quot; ## [7] &quot;America/Paramaribo&quot; &quot;Europe/Tallinn&quot; &quot;Asia/Kuwait&quot; ## [10] &quot;America/Martinique&quot; Vremenske oznake također mogu koristiti operatore + i - uz cjelobrojne vrijednosti kao drugi operand pri čemu se od vremenske oznake oduzimaju ili dodaju sekunde. Isto tako, možemo oduzimati dvije vremenske oznake kako bi dobili razliku u sekundama, ili koristiti funkciju difftime sa odabranom vrijednosti vremenske jedinice. Zadatak 10.7 - aritmetika sa vremenskim oznakama # ispišite koje će biti vrijeme 1000 sekundi od ovog trenutka # ispišite koliko je prošlo sati od ponoći 1.1.2015. do sad # ispišite koje će biti vrijeme 1000 sekundi od ovog trenutka Sys.time() + 1000 # ispišite koliko je prošlo sati od ponoći 1.1.2015. do sad difftime(Sys.time(), &quot;2015-01-01 00:00:00&quot;, units = &quot;hours&quot;) ## [1] &quot;2024-01-18 13:22:20 CET&quot; ## Time difference of 79309.09 hours Klasa POSIXlt se ponaša isto kao i POSIXct (za stvaranje se koristimo funkcijom as.POSIXlt), no zapravo se radi o listi koja nam omogućuje jednostavno izvlačenje određenih parametara iz vremenske oznake, kao što su broj sekundi, broj minuta, dan u tjednu i sl. Sve elemente liste lako možemo vidjeti ako napravimo POSIXlt objekt i onda pozovemo funkciju unclass nad njim, pri čemu će se on pretvoriti u “običnu” listu. Možemo ići i korak dalje - ako listu ubacimo u funkciju unlist, kao rezultat dobivamo obični znakovni vektor. Zadatak 10.8 - klasa POSIXlt # pretvorite sljedeći znakovni niz u vremensku oznaku tipa `POSIXlt` # pohranite rezultat u varijablu `t_long` # &quot;1.5.2013 13:35&quot; # ispišite broj sati i broj minuta vremenske oznake `t_long` # ispisom njenih elemenata naziva `hour` i `min` # uklonite klasu i svojstvo liste varijable `t_long` # i ispišite ju na zaslon # pretvorite sljedeći znakovni niz u vremensku oznaku tipa `POSIXlt` # pohranite rezultat u varijablu `t_long` # &quot;1.5.2013 13:35&quot; t_long &lt;- as.POSIXlt(&quot;1.5.2013 13:35&quot;, format = &quot;%d.%m.%Y %H:%M&quot;) # ispišite broj sati i broj minuta vremenske oznake `t_long` # ispisom njenih elemenata naziva `hour` i `min` t_long$hour t_long$min # uklonite klasu i svojstvo liste varijable `t_long` # i ispišite ju na zaslon t_long %&gt;% unclass() %&gt;% unlist() ## [1] 13 ## [1] 35 ## sec min hour mday mon year wday yday isdst zone gmtoff ## &quot;0&quot; &quot;35&quot; &quot;13&quot; &quot;1&quot; &quot;4&quot; &quot;113&quot; &quot;3&quot; &quot;120&quot; &quot;1&quot; &quot;CEST&quot; NA 10.3 Paket lubridate Iako jezik R ima relativno dobru podršku za rad sa datumima i vremenskim oznakama, upravljanje istima možemo učiniti znatno učinkovitijim uz paket lubridate. Ukoliko analiziramo podatke gdje je vremenska komponenta jako bitna, ili upravljamo podatkovnim skupovima koji koriste različite oblike zapisa datuma i vremenskih oznaka, onda si proces analize uvelike olakšavamo i ubrzavamo korištenjem funkcija iz ovog paketa. Jedna od stvari koja je možda najkorisnija programerima koji ne vole pisati oblikovne specifikacije za parsiranje datuma je porodica funkcija za parsiranje datuma čija imena odgovaraju okvirnom izgledu zapisa kojeg želimo parsirati. Npr. funkcija imena ymd zna parsirati znakovne nizove u kojima je datum zapisan redoslijedom godina-mjesec-dan. Funkcija je dovoljno “pametna” da sama interpretira pojedinosti oko zapisa, kao što su delimiteri, znakovna polja i sl. Ukoliko zapis ima drugi raspored dana, mjeseca i godine, potrebno je samo adekvatno razmjestiti slova u nazivu funkcije. Zadatak 10.9 - funkcije paketa lubridate za parsiranje datuma # library(lubridate) #učitati ako je potrebno! # koristeći se funkcijama iz paketa `lubridate` # parsirajte u datume i ispišite sljedeće znakovne nizove # &quot;2016-07-31&quot; # &quot;28.2.1983.&quot; # &quot;07#31#1996&quot; # &quot;20010830&quot; # koristeći se funkcijama iz paketa `lubridate` # parsirajte u datume i ispišite sljedeće znakovne nizove # &quot;2016-07-31&quot; # &quot;28.2.1983.&quot; # &quot;07#31#1996&quot; # &quot;20010830&quot; ymd(&quot;2016-07-31&quot;) dmy(&quot;28.2.1983.&quot;) mdy(&quot;07#31#1996&quot;) ymd(&quot;20010830&quot;) ## [1] &quot;2016-07-31&quot; ## [1] &quot;1983-02-28&quot; ## [1] &quot;1996-07-31&quot; ## [1] &quot;2001-08-30&quot; Navedeni koncept može se koristiti i za vremenske oznake, samo imenu funkcije dodamo podcrtu i “specifikaciju” sati, minuta i sekundi (npr. ymd_hms). Zadatak 10.10 - funkcije paketa lubridate za parsiranje vremenskih oznaka # koristeći se funkcijama iz paketa `lubridate` # parsirajte u vremenske oznake i ispišite sljedeće znakovne nizove # &quot;17.5.1977. 10:15pm&quot; # &quot;20160429 10.05.17&quot; # koristeći se funkcijama iz paketa `lubridate` # parsirajte u vremenske oznake i ispišite sljedeće znakovne nizove # &quot;17.5.1977. 10:15pm&quot; # &quot;20160429 10.05.17&quot; dmy_hm(&quot;17.5.1977. 10:15pm&quot;) ymd_hms(&quot;20160429 10.05.17&quot;) ## [1] &quot;1977-05-17 22:15:00 UTC&quot; ## [1] &quot;2016-04-29 10:05:17 UTC&quot; Uočimo da ove funkcije uvijek za vremensku zonu postavljaju UTC. Ovo je namjerno napravljeno s ciljem da se motivira korištenje jedinstvene vremenske zone u podatkovnom skupu kojeg analiziramo. Ukoliko želimo, tijekom parsiranja možemo postaviti vremensku zonu uz pomoć parametra tz. Isto tako, kod već inicijaliziranih vremenskih oznaka možemo upravljati vremenskim zonama uz pomoć sljedećih funkcija force_tz, tz - “nameće” novu vremensku zonu tj. ostavlja iste vrijednosti vremenske oznake ali postavlja vremensku zonu koju definiramo with_tz - provodi transformaciju vremenske oznake u onu koja odgovara traženoj vremenskoj zoni t &lt;- ymd_hms(&quot;20161129 10.05.17&quot;, tz = &quot;EST&quot;) t force_tz(t, tz = &quot;CET&quot;) # ili tz(t) = &quot;CET&quot; with_tz(t, tz = &quot;CET&quot;) ## [1] &quot;2016-11-29 10:05:17 EST&quot; ## [1] &quot;2016-11-29 10:05:17 CET&quot; ## [1] &quot;2016-11-29 16:05:17 CET&quot; Paket lubridate također uvelike olakšava izvlačenje segmenata datuma i vremena iz vremenskih oznaka uz pomoć funkcija kao što su year, week, month i sl. Uz pomoć istih funkcija možemo lako i izmijeniti neku od komponenti vremena. Zadatak 10.11 - izvlačenje elemenata vremenskih oznaka x &lt;- dmy_hms(&quot;19.7.1996. 16:15:27&quot;) # iz gornje vremenske oznake izvucite i ispišite sate te potom minute # postavite godinu gornje vremenske oznake na 2011., a mjesec na lipanj # ispišite `x` x &lt;- dmy_hms(&quot;19.7.1996. 16:15:27&quot;) # iz gornje vremenske oznake izvucite i ispišite sate te potom minute hour(x) minute(x) # postavite godinu gornje vremenske oznake na 2011., a mjesec na lipanj year(x) &lt;- 2011 month(x) &lt;- 6 # ispišite `x` x ## [1] 16 ## [1] 15 ## [1] &quot;2011-06-19 16:15:27 UTC&quot; Za potpuni popis funkcija pogledajte dokumentaciju paketa lubridate. Za trenutni datum i vrijeme lubridate nudi alternative funkcijama Sys.Date() i Sys.time() koje se jednostavno zovu today() i now(). Zadatak 10.12 - funkcije today i now # ispišite sutrašnji datum # ispišite koliko je bilo sati, minuta i sekundi prije točno sat vremena # ispišite sutrašnji datum today() + 1 # ispišite koliko je bilo sati, minuta i sekundi prije točno sat vremena now() - 60*60 ## [1] &quot;2024-01-19&quot; ## [1] &quot;2024-01-18 12:05:41 CET&quot; Već smo rekli da upravljanje vremenskom komponentom u podacima može postati vrlo kompleksno, pogotovo ako uzmemo u obzir da vremenski intervali mogu biti zadani generički (npr. “2 godine”) ili konkretno (raspon između dva datuma) te da se matematički i kalendarski način računanja vremena često ne poklapaju (npr. “za godinu dana” može značiti točan matematički izračun sekundi u 365 dana, ili kalendarski “isti datum iduće godine”). Paket lubridate definira četiri mogućnosti kod definiranja vremena i vremenskih intervala: trenutak (instant) - vremenska oznaka zaokružena na sekundu trajanje (duration) - “generički” definiran interval u sekundama period - slično trajanju, ali omogućuje definiranje trajanja koja matematički ne traju uvijek isto (npr. “3 mjeseca”) interval - vrijeme omeđeno između dva točno određena trenutka Trenutke smo već upoznali, to su vremenske oznake koje smo do sada stvarali. Za stvaranje trajanja i perioda imamo intuitivno definirane funkcije koje se nazivaju po engleskim nazivima za vremenske jedinice, pri čemu trajanja imaju dodano slovo d kao prefiks (od duration). Tako imamo funkcije minutes i dminutes, hours i dhours, weeks i dweeks i sl. (uočite da ne postoji funkcija dmonths, budući da “mjesec dana” ne možemo jednoznačno pretvoriti u sekunde!). Zadatak 10.13 - trajanja i periodi # ispišite objekte koji predstavljaju trajanje i period od 3 tjedna # u varijablu `v` upišite period od 5 godina, 3 mjeseca i 2 dana # dodajte gornji period današnjem datumu # ispišite objekte koji predstavljaju trajanje i period od 3 tjedna weeks(3) dweeks(3) # u varijablu `v` upišite period od 5 godina, 3 mjeseca i 2 dana v &lt;- years(5) + months(3) + days(2) # dodajte gornji period današnjem datumu today() + v ## [1] &quot;21d 0H 0M 0S&quot; ## [1] &quot;1814400s (~3 weeks)&quot; ## [1] &quot;2029-04-20&quot; Uočite da gornji izraz nismo lako mogli dobiti “matematički”. Konačno, interval stvaramo uz pomoć funkcije interval kojoj dajemo početni i konačni trenutak, ili uz pomoć funkcije as.interval kojoj dajemo trajanje/period i početni trenutak. Možemo također koristiti i operator %--% sa dvije vremenske oznake (tj. trenutka) kao operandima. Zadatak 10.14 - intervali # stvorite varijablu `interval1` koja će pohraniti interval # od 6 mjeseci prije današnjeg dana # do 6 mjeseci iza današnjeg dana # stvorite varijablu `interval2` koja će pohraniti interval od današnjeg dana # do datuma koji će se dogoditi za 4 mjeseca, 3 tjedna i 2 dana # stvorite varijablu `interval3` koja će pohraniti interval # od 1.5.2002. do 1.7.2002. # ispišite sva tri intervala # stvorite varijablu `interval1` koja će pohraniti interval # od 6 mjeseci prije današnjeg dana # do 6 mjeseci iza današnjeg dana interval1 &lt;- interval(today() - months(6), today() + months(6)) # stvorite varijablu `interval2` koja će pohraniti interval od današnjeg dana # do datuma koji će se dogoditi za 4 mjeseca, 3 tjedna i 2 dana interval2 &lt;- as.interval(months(4) + weeks(3) + days(2), today()) # stvorite varijablu `interval3` koja će pohraniti interval # od 1.5.2002. do 1.7.2002. interval3 &lt;- dmy(&quot;1.5.2002.&quot;) %--% dmy(&quot;1.7.2002.&quot;) # ispišite sva tri intervala interval1 interval2 interval3 ## [1] 2023-07-18 UTC--2024-07-18 UTC ## [1] 2024-01-18 UTC--2024-06-10 UTC ## [1] 2002-05-01 UTC--2002-07-01 UTC Kod intervala je zgodno što između ostalog možemo: provjeriti da li se neki trenutak nalazi unutar nekog intervala uz pomoć operatora %within% provjeriti da li se intervali preklapaju uz pomoć funkcije int_overlaps() lako dohvatiti početak i kraj intervala uz pomoć funkcija int_start() i int_end “spojiti” dva intervala uz pomoć funkcije union ili naći presjek uz pomoć funkcije intersect brojne druge mogućnosti koje možemo naučiti gledajući dokumentaciju Zadatak 10.15 - pomoćne funkcije za rad sa intervalima # provjerite da li je današnji dan unutar intervala definiranog varijablom `interval1` # ukoliko se `interval1` i `interval2` preklapaju # ispišite njihov presjek # provjerite da li je današnji dan unutar intervala definiranog varijablom `interval1` today() %within% interval1 # ukoliko se `interval1` i `interval2` preklapaju # ispišite njihov presjek if (int_overlaps(interval1, interval1)) intersect(interval1, interval2) ## [1] TRUE ## [1] 2024-01-18 UTC--2024-06-10 UTC U ovom dijelu upoznali smo se sa jednim dijelom funkcionalnosti koje nude klase za upravljanje datumima i vremenskim oznakama jezika R te paket lubridate. Za dodatne informacije pogledajte službenu dokumentaciju jezika R i paketa lubridate, a dobar izvor je i članak “Dates and Times Made Easy with lubridate” kojeg je napisao sam autor paketa Hadley Wickham a koji je dostupan na ovoj poveznici. Zadaci za vježbu Sljedeći zadaci odnose se na podatkovni skup pohranjen u CSV datoteci crimeSample.csv a koji predstavlja uzorak iz evidencije kriminalnih incidenata u gradu Philadelphiji (originalni podatkovni skup može se naći na ovoj poveznici). Originalni skup stupaca je reduciran a iz skupa svih obzervacija slučajnim odabirom uzorkovano je 1000 incidenata. Prije rješavanja zadataka učitajte podatke u podatkovni okvir crimes i upoznajte se s podatkovnim skupom (str, head, itd.) Pretvorite stupac sa vremenskom oznakom iz znakovnog tipa u POSIXct tip. Podatkovnom okviru dodajte sljedeće stupce: Year, Month, Hour. Stupce popunite odgovarajućim informacijama iz vremenske oznake. Odgovorite na pitanje: u kojem mjesecu se događa najviše zločina? Koji sat u danu je prema podacima “najopasniji”? Programirajmo u R-u by Damir Pintar is licensed under a Creative Commons Attribution-NonCommercial-NoDerivatives 4.0 International License.Based on a work at https://ratnip.github.io/FER_OPJR/ "],["nizovi.html", "11 Obrada znakovnih nizova 11.1 Rad sa znakovnim nizovima Zadaci za vježbu", " 11 Obrada znakovnih nizova 11.1 Rad sa znakovnim nizovima R ima jako dobru podršku za rad sa znakovnim nizovima, no funkcije koje nudi osnovni R nisu intuitivne niti konzistentne ako ih uspoređujemo sa sličnim funkcijama u drugim programskim jezicima. Upravo iz ovih razloga pojavio se paket stringr koji nudi vrlo učinkovitu alternativu postojećim funkcijama vezanih uz znakovne nizove te predstavlja jedan od najpopularnijih “dodatnih” R paketa. No prije upoznavanja sa funkcijama koje nudi ovaj paket potrebno je kratko se osvrnuti na općenitu problematiku upravljanja znakovnim nizovima u analizi podataka te na tehnologiju bez koje je provedba analize znakovnih nizova gotovo nezamisliva - tzv. regularni izrazi. 11.1.1 Analiza teksta i regularni izrazi Analiza teksta neizbježan je element kod analize podatkovnih skupova. Bilo da se radi o jednostavnoj identifikaciji kategorija, traženju podnizova ili nečem daleko složenijem kao što su specijalizirane metode rudarenja teksta (engl. text mining), teško je zamisliti bilo kakvu smislenu analizu podataka koja prije ili kasnije ne zahtijeva poznavanje barem osnovnih metoda analize znakovnih nizova. Neovisno o razini složenosti analize znakovnih nizova koju želimo provesti, jedna tehnologija je sveprisutna i univerzalno primjenjiva - regularni izrazi. Ovdje se radi o posebnom jeziku uz pomoć kojeg definiramo “uzorke” (patterns) na osnovu kojih pretražujemo neki tekst, radimo izmjene i sl. Detaljni pregled tehnologije regularnih izraza izlazi iz okvira ovog udžbenika. U nastavku ćemo navesti samo kratke informacije u svrhu brzog pregleda ili podsjetnika. Ukoliko se do sada uopće niste susretali s ovom tehnologijom, snažno preporučujemo ulaganje truda i svladavanje barem osnovnih koncepata, npr. uz pomoć nekog od dostupnih internetskih. Jedan od vrlo kratkih ali učinkovitih mini-tečajeva regularnih izraza možete naći ovdje . Regularni izraz jednostavno je niz znakova koji predstavlja uzorak kojeg tražimo unutar nekog teksta. Npr. regularni izraz gram se nalazi u znakovnom nizu Programski jezik R ali se ne nalazi u znakovnom nizu Analiza teksta. Kažemo da smo pronašli “slaganje” (match) regularnog izraza sa prvim nizom ali ne i sa drugim. Ovakav regularni izraz nije previše fleksibilan - prava moć regularnih izraza krije se u mogućnosti slaganja posebnih izraza koji će se uz pomoć posebnog opisa moći slagati sa “općenitijim” oblicima znakovnih nizova. Tipičan primjer je adresa elektroničke pošte - konkretnije, provjera da li je korisnik unio adresu koja odgovara “općenitom” obliku adrese elektroničke pošte. Jedno od mogućnosti je jednostavno izraz @ kojim zapravo samo provjeravamo postojanje tog znaka u danom znakovnom nizu. Time smo osigurali određenu razinu kontrole, ali isto tako smo dopustili “adrese” tipa @@@ i @23456. Uz malo “rada” na izrazu mogli bi doći do malo boljeg rješenja, koje npr. može izgledati ovako: \\w+@\\w+\\.\\w+ Iako izgleda kao niz nasumičnih znakova, osnovnim poznavanjem regularnih izraza možemo relativno lako interpretirati gornji izraz. Znak \\w označava “slovo ili znamenku”, znak + znači “1 ili više” i sl. Ako bi htjeli “prepričati” gornji regularni izraz govornim jezikom, to bi bilo “jedno ili više slova ili znamenki, potom znak @, pa jedno ili više slova ili znamenki, zatim točka i onda konačno opet jedno ili više slova ili znamenki”. Iako ovo nije pretjerano sofisticirani izraz, on je ipak kvalitetniji od prvog pokušaja. Daljnje proširenje je itekako moguće i iako naknadnim dodavanjima sve više gubimo neposrednu čitljivost, isto tako postižemo sve višu i višu razinu kontrole koja se približava formalnim odrednicama kako adresa elektroničke pošte mora izgledati (za ovakve specifične uporabe često se isplati i provjeriti javno dostupne repozitorije regularnih izraza gdje možemo naći složene ali kvalitetne i pomno testirane izraze koje je dovoljno jednostavno prekopirati u naš programski kod). Važno je napomenuti da nema jednog jedinstvenog standarda za regularne izraze. Postoji tzv. “POSIX standard” u dvije inačice - BRE i ERE (Basic Regular Expressions i Extended Regular Expressions) koje su zapravo gotovo iste, osim što BRE zahtjeva malo intenzivniju uporabu znaka \\. Još jedan popularni standard je tzv. “Perl standard” koji predstavlja inačicu regularnih izraza implementiranih u jeziku Perl. Budući da je Perl jedan od vodećih jezika za upravljanje tekstom tako je i ovaj standard postao jedan od najšire prihvaćenih načina korištenja regularnih izraza. U općenitom slučaju, gotovo svi popularniji programski jezici imaju podršku za regularne izraze, bilo već ugrađene u jezik, bilo uz pomoć dodatnih paketa. R je jedan od jezika koji već sadrži podršku za regularne izraze u svojem osnovnom paketu. Štoviše, R ima ugrađenu paralelnu podršku za tri najraširenija standarda - POSIX ERE, POSIX BRE i Perl. POSIX ERE je zadana postavka, a određenim parametrima možemo se lako “prebaciti” na BRE (extended = FALSE) ili Perl (perl = TRUE). U daljnjim poglavljima držati ćemo se ERE standarda, ali bitno je znati i za prethodno navedene postavke želimo li koristiti već gotove izraze koji su razvijeni u nekom drugom standardu (a ne želimo se zamarati sa prebacivanjem iz jednog standarda u drugi). Sljedeća tablica daje kratki pregled nekih češće korištenih elemenata regularnih izraza u jeziku R: Element Značenje abcd niz slova “abcd” 1234 niz znamenki “1234” \\\\d ili [:digit:] ili [0-9] bilo koja znamenka \\\\D ili [:alpha:] ili [A-Za-z] bilo koje slovo [:alnum:] bilo koje slovo ili znamenka . bilo koji znak \\\\. točka [abc] samo navedeni znakovi [^abc] svi znakovi osim navedenih * nula ili više ponavljanja + jedno ili više ponavljanja {n} točno n ponavljanja {m, n} najmanje m, najviše n ponavljanja ? opcionalni znak [:space:] ili \\\\s bilo kakva praznina [:punct:] znakovi interpunkcije ^...$ oznaka za početak i kraj (ab|cd) niz “ab” ili niz “cd” Uočite da kod korištenja specijalnog znaka \\ zapravo moramo koristiti “dvostruki znak” \\\\ (prvi put da naznačimo R-u da se radi o specijalnom znaku, drugi put da ga doslovno upotrijebimo kao dio regularnog izraza). Osnovne funkcije jezika R za rad sa znakovnim nizovima (a time i regularnim izrazima) su između ostalog grep, grepl, regexrp, gregexrp, regmatches, sub, gsub itd. No budući da paket stringr nudi skup alternativnih funkcija sa gotovo istim funkcionalnostima ali uz daleko intuitivnija imena i konzistentnije potpise, mi ćemo se usredotočiti na upravo te funkcije a učenje osnovnih ostavljamo čitateljima koji žele upotpuniti svoje znanje učenjem svih dostupnih alata koje nudi jezik R. 11.1.2 Paket stringr Već smo rekli da paket stringr zapravo u izvjesnoj mjeri reimplementira već postojeće funkcije jezika R, ali na intuitivniji i konzistentniji način. Ako želimo biti precizni, funkcije paketa stringr su zapravo funkcionalno nešto skromnije, no to je napravljeno s konkretnom namjerom - funkcionalnost je reducirana na poslove za koje se smatra da predstavljaju daleko najčešće korištene funkcionalnosti kod analize teksta. Funkcionalnost koja je “izbačena” tiče se specifičnih slučajeva za koje će programer morati potražiti alternativna rješenja (često u obliku osnovnih funkcija), no dobitak je u jednostavnijim, intuitivnijim funkcijama koje su lakše za učenje i učinkovito dugoročno korištenje. Pored navedenih “popravljanja” paket stringr omogućuje i sljedeće: konzistentno tretiranje faktora kao znakovnih nizova lakše korištenje izlaza funkcija za ulaz nastupajuće funkcije, što je pogotovo korisno uz operator %&gt;% Možemo početi sa nekim jednostavnijim funkcijama za koje ne trebamo regularne izraze (navodimo pojednostavljene potpise funkcija, za potpune pogledajte dokumentaciju): str_c(string1, string2, ...) - spajanje znakovnih nizova, alternativa funkciji paste0 str_length(string) - vraća duljinu znakovnog niza str_sub(string, start, end) - vraća podniz str_sub(string, start, end) &lt;- string2 - umetanje novog podniza (ne mora biti iste duljine kao izbačeni podniz!) str_trim(string) - uklanjanje praznina s početka i kraja niza Zadatak 11.1 - osnovne funkcije za rad sa znakovnim nizovima niz1 &lt;- &quot; Ovo je primjer &quot; niz2 &lt;- &quot;spajanja nizova! &quot; # uz pomoć jedne naredbe spojite gornje nizove, potom # iz rezultata uklonite praznine s početka i kraja niza, # zatim izdvojite podniz od 8. do 23. znaka te konačni rezultat ispišite na zaslon niz &lt;- &quot;R je pretjerano kompliciran i nimalo lagan jezik!&quot; # u gornjem nizu znakova zamjenite sve od 9. znaka (brojeno od početka) # do 13. (brojeno od kraja) sa praznim nizom # ispišite niz niz1 &lt;- &quot; Ovo je primjer &quot; niz2 &lt;- &quot;spajanja nizova! &quot; # uz pomoć jedne naredbe spojite gornje nizove, potom # iz rezultata uklonite praznine s početka i kraja niza, # zatim izdvojite podniz od 8. do 23. znaka te konačni rezultat ispišite na zaslon str_c(niz1, niz2) %&gt;% str_trim() %&gt;% str_sub(8, 23) niz &lt;- &quot;R je pretjerano kompliciran i nimalo lagan jezik!&quot; # u gornjem nizu znakova zamjenite sve od 9. znaka (brojeno od početka) # do 13. (brojeno od kraja) sa praznim nizom str_sub(niz, 9, -13) &lt;- &quot;&quot; # ispišite niz niz ## [1] &quot;primjer spajanja&quot; ## [1] &quot;R je prelagan jezik!&quot; Funkcija str_c ima i parametar sep za dodavanje separatora, te parametar collapse za spajanje elemenata znakovnog vektora u jedinstveni niz uz vrijednost parametra kao separator. Zadatak 11.2 - spajanje znakovnih nizova niz1 &lt;- &quot;Za spajanje&quot; niz2 &lt;- &quot;ovih nizova&quot; niz3 &lt;- &quot;potreban je razmak!&quot; # spojite gornje nizove u jedinstveni niz i ispišite rezultat nizovi &lt;- c(&quot;A&quot;, &quot;ovi&quot;, &quot;nizovi&quot;, &quot;su&quot;, &quot;elementi&quot;, &quot;vektora...&quot;) # spojite elemente gornjeg vektora u jedan niz i ispišite rezultat niz1 &lt;- &quot;Za spajanje&quot; niz2 &lt;- &quot;ovih nizova&quot; niz3 &lt;- &quot;potreban je razmak!&quot; # spojite gornje nizove u jedinstveni niz i ispišite rezultat str_c(niz1, niz2, niz3, sep = &quot; &quot;) nizovi &lt;- c(&quot;A&quot;, &quot;ovi&quot;, &quot;nizovi&quot;, &quot;su&quot;, &quot;elementi&quot;, &quot;vektora...&quot;) # spojite elemente gornjeg vektora u jedan niz i ispišite rezultat str_c(nizovi, collapse = &quot; &quot;) ## [1] &quot;Za spajanje ovih nizova potreban je razmak!&quot; ## [1] &quot;A ovi nizovi su elementi vektora...&quot; Pogledajmo sada neke funkcije koje rade sa regularnim izrazima: str_detect(string, pattern) - vraća TRUE ako niz sadrži uzorak, inače FALSE str_extract(string, pattern) - vraća niz znakova koji odgovara prvoj pojavi uzorka str_extract_all(string, pattern) - vraća listu sa svim pojavama koje odgovaraju uzorku str_replace(string, pattern, replacement) - mijenja prvu pojavu uzorka sa zadanim novim nizom str_replace_all(string, pattern, replacement) - mijenja sve pojave uzorka sa zadanim novim nizom Sve ove funkcije su vektorizirane, tj. ponašaju se logično (tj. “paralelizirano”) kad im kao određeni parametar pošaljemo vektor - npr. ako funkciji str_replace pošaljemo vektor znakovnih nizova i vektor “zamjena”, svaka prva pojava uzorka biti će zamijenjena odgovarajućim elementom u poretku zamjena. Za detalje oko ovakvog proširenog korištenja uputno je pogledati dokumentaciju. Zadatak 11.3 - funkcije i regularni izrazi adrese &lt;- c(&quot;pero.peric@fer.hr&quot;, &quot;iva.ivic@etfos.hr&quot;, &quot;ppetrovic@gmail.com&quot;, &quot;branko1987@yahoo.com&quot;, &quot;jaRULZ4EVR@gmail.nz&quot;, &quot;dperkovic@efzg.hr&quot;, &quot;lalaic1998@gmail.co.uk&quot;, &quot;perica.markic@fer.hr&quot;) # prebrojite i ispišite koliko u gornjem popisu ima mail adresa iz domene `fer.hr` # ispišite sve adrese koje sadrže bar jednu znamenku # ispišite sve adrese koje na drugom mjestu imaju samoglasnik # ispišite sve jedinstvene domene adresa elektroničke pošte iz gornjeg niza adresa # (domenom smatramo dio adrese iza znaka `@`) # anonimizirajte gornje adrese: niz znakova ispred znaka &#39;@&#39; # zamijenite nasumičnim šesteroznamenkastim prirodnim brojem # prebrojite i ispišite koliko u gornjem popisu ima mail adresa iz domene `fer.hr` str_detect(adrese, &quot;fer\\\\.hr&quot;) %&gt;% sum # ispišite sve adrese koje sadrže bar jednu znamenku adrese[str_detect(adrese, &#39;[:digit:]&#39;)] # ispišite sve adrese koje na drugom mjestu imaju samoglasnik str_detect(adrese, &quot;^.[aeiouAEIOU]&quot;) %&gt;% adrese[.] #ili `]`(adrese, .) # moze i str_detect(adrese, &quot;^.(a|e|i|o|u|A|E|I|O|U)&quot;) %&gt;% adrese[.] # ispišite sve jedinstvene domene adresa elektroničke pošte iz gornjeg niza adresa # (domenom smatramo dio adrese iza znaka `@`) str_extract(adrese, &#39;@(.*)&#39;) %&gt;% str_sub(2) %&gt;% unique # anonimizirajte gornje adrese: niz znakova ispred znaka &#39;@&#39; # zamijenite nasumičnim šesteroznamenkastim prirodnim brojem sample(100000:999999, length(adrese)) %&gt;% as.character %&gt;% str_replace(adrese, &#39;^[^@]*&#39;, .) ## [1] 2 ## [1] &quot;branko1987@yahoo.com&quot; &quot;jaRULZ4EVR@gmail.nz&quot; &quot;lalaic1998@gmail.co.uk&quot; ## [1] &quot;pero.peric@fer.hr&quot; &quot;jaRULZ4EVR@gmail.nz&quot; &quot;lalaic1998@gmail.co.uk&quot; ## [4] &quot;perica.markic@fer.hr&quot; ## [1] &quot;fer.hr&quot; &quot;etfos.hr&quot; &quot;gmail.com&quot; &quot;yahoo.com&quot; &quot;gmail.nz&quot; ## [6] &quot;efzg.hr&quot; &quot;gmail.co.uk&quot; ## [1] &quot;715037@fer.hr&quot; &quot;206896@etfos.hr&quot; &quot;861759@gmail.com&quot; ## [4] &quot;278787@yahoo.com&quot; &quot;581691@gmail.nz&quot; &quot;258345@efzg.hr&quot; ## [7] &quot;618764@gmail.co.uk&quot; &quot;112453@fer.hr&quot; Konačno, naučimo jednu relativno korisnu funkciju nazvanu str_split. Ova funkcija rastavlja znakovni niz na vektor znakovnih nizova, ovisno o danom separatoru (koji može biti razmak, neki odabrani znak ali i regularni izraz), a često se koristi kao “primitivnija” alternativa funkcijama read.csv i read.table kada ulazne podatke želimo “ručno” rastaviti i parsirati, ili za analizu teksta kada paragrafe teksta “razbijamo” na pojedinačne riječi. Ova funkcija pretpostavlja da ćemo joj proslijediti niz znakovnih nizova za rastavljanje te nam kao rezultat vraća listu; ukoliko rastavljamo samo jedan niz, lako rezultat pretvaramo u vektor korištenjem funkcije unlist. str_split(&quot;Primjer funkcije str_split&quot;, pattern = &quot;[:space:]&quot;) %&gt;% unlist ## [1] &quot;Primjer&quot; &quot;funkcije&quot; &quot;str_split&quot; Pokažimo sada jedan vrlo jednostavni primjer analize teksta - pronalazak najčešće pojavljivanih riječi u odabranom tekstu. Za potrebe ovog zadatka morati ćemo pročitati podatke iz tekstualne datoteke. Jedan od najjednostavnijih načina kako ovo možemo učiniti jest kombinacija funkcija file (koja otvara konekciju prema tekstualnoj datoteci, slično načinu upravljanja datotekama u C-u) i readLines koja čita određeni broj redaka iz datoteke i sprema ih u znakovni vektor. Ako je datoteka dovoljno mala da sve retke možemo čitati odjednom, onda ove dvije funkcije možemo pozvati ovako: con &lt;- file(&quot;datoteka.txt&quot;, &quot;r&quot;) # r = &quot;read&quot; rows &lt;- readLines(con) # ili readLines(con, n = 100) za čitanje samo određenog broja redaka close(con) # zatvaranje toka Sljedeći zadatak koristiti će dvije tekstualne datoteke HobbitChapterOne.txt - datoteka čiji tekst analiziramo i stopwords.txt - datoteka sa čestim riječima koje “nisu vrijedne” za analizu koju ćemo izvesti Zadatak 11.4 - jednostavna analiza teksta # u varijablu `hobbit` učitajte tekst iz datoteke `HobbitChapterOne.txt` # a u varijablu `stopwords` stop riječi iz datoteke `stopwords.txt` # provedite sljedeće korake: # - spojite sve elemente iz varijable `hobbit` u jedan jedinstveni znakovni niz # - uklonite interpunkcijske znakove iz teksta # - prebacite tekst u &quot;lowercase&quot; (funkcija `tolower`) # - rastavite tekst na riječi po prazninama # - izbacite &quot;prazne&quot; riječi (riječi duljine 0) ako ih ima # - izbacite sve riječi koje se nalaze u vektoru `stopwords` # - izračunajte frekvencije riječi # - ispišite na zaslon 20 najčešće korištenih riječi # u varijablu `hobbit` učitajte tekst iz datoteke `HobbitChapterOne.txt` # a u varijablu `stopwords` stop riječi iz datoteke `stopwords.txt` con &lt;- file(&quot;HobbitChapterOne.txt&quot;) hobbit &lt;- readLines(con) close(con) con &lt;- file(&quot;stopwords.txt&quot;) stopwords &lt;- readLines(con) close(con) # provedite sljedeće korake: # - spojite sve elemente iz varijable `hobbit` u jedan jedinstveni znakovni niz # - uklonite interpunkcijske znakove iz teksta # - prebacite tekst u &quot;lowercase&quot; (funkcija `tolower`) # - rastavite tekst na riječi po prazninama # - izbacite &quot;prazne&quot; riječi (riječi duljine 0) ako ih ima # - izbacite sve riječi koje se nalaze u vektoru `stopwords` # # - izračunajte frekvencije riječi # - ispišite na zaslon 20 najčešće korištenih riječi hobbit %&gt;% str_c(collapse = &quot; &quot;) %&gt;% str_replace_all(&#39;[:punct:]&#39;, &#39;&#39;) %&gt;% tolower %&gt;% str_split(&#39;[:space:]&#39;) %&gt;% unlist -&gt; hobbit2 hobbit3 &lt;- hobbit2[!(hobbit2 %in% stopwords | nchar(hobbit2) == 0)] freq &lt;- table(hobbit3) %&gt;% sort(decreasing = T) freq[1:20] ## hobbit3 ## bilbo gandalf one thorin dwarves door baggins good hobbit little ## 39 36 36 34 31 27 25 25 25 24 ## long went know time away go old things come morning ## 24 23 20 19 17 17 17 17 16 16 Zadaci za vježbu Sljedeći zadaci odnose se na podatkovni skup pohranjen u CSV datoteci crimeSample.csv a koji predstavlja uzorak iz evidencije kriminalnih incidenata u gradu Philadelphiji (originalni podatkovni skup može se naći na ovoj poveznici). Originalni skup stupaca je reduciran a iz skupa svih obzervacija slučajnim odabirom uzorkovano je 1000 incidenata. Prije rješavanja zadataka učitajte podatke u podatkovni okvir crimes i upoznajte se s podatkovnim skupom (str, head, itd.) Odgovorite na pitanje: koliki je postotak incidenata gdje opis incidenta sadrži riječ \"burglary\" ili \"robbery\"? (savjet: pretvorite cijeli stupac sa opisom zločina u mala slova uz pomoć funkcije tolower()). Ispišite na zaslon sve jedinstvene četveroznamenkaste brojeve koje možete naći u nazivima ulica u kojima je evidentiran kriminalni incident. Programirajmo u R-u by Damir Pintar is licensed under a Creative Commons Attribution-NonCommercial-NoDerivatives 4.0 International License.Based on a work at https://ratnip.github.io/FER_OPJR/ "],["prilagodba-podatkovnih-skupova-uz-paket-dplyr.html", "12 Prilagodba podatkovnih skupova uz paket dplyr 12.1 Ogledni podatkovni skup: Titanic 12.2 Stvaranje podskupa obzervacija uz filter i slice 12.3 Stvaranje podskupa varijabli uz select 12.4 Stvaranje novih stupaca uz mutate 12.5 Ogledni podatkovni skup: Houston flights 12.6 Grupiranje i agregacija uz group_by i summarise 12.7 Spajanje podatkovnih okvira uz join funkcije 12.8 Integracija sa vanjskim izvorima podataka Zadaci za vježbu", " 12 Prilagodba podatkovnih skupova uz paket dplyr Paket dplyr jedan je od novijih paketa jezika R čija je glavna funkcija učinkovito i pojednostavljeno upravljanje podatkovnim okvirima uz pomoć skupa intuitivno dizajniranih funkcija. U trenutku pisanja ove lekcije nalazi se na vrhu liste najpopularnijih paketa usprkos jakoj “konkurenciji” u ovom području koju čine iznimno popularni paketi kao što su plyr, data.table ali i osnovne, tradicionalne metode za rad sa podatkovnim okvirima. Bilo koja od ovih opcija predstavlja dobar izbor, a iako paket dplyr nije najučinkovitiji glede samih performansi (daleko najbolje performanse trenutno nudi paket data.table), prednost ovog paketa je njegova intuitivna, čitljiva sintaksa koja programski rad sa podatkovnim okvirima čini brzim i jednostavnim te je odličan izbor za programere koji se upoznaju sa R-om ili se jednostavno žele usredotočiti na rad sa podacima kroz čitljiv, lako održiv programski kod. Konkretne prednosti koje donosi paket dplyr su sljedeće: jednostavna sintaksa (slična SQL-u, ali proceduralna) koja koristi pet glavnih “glagola” za manipulaciju podatkovnim okvirima i kao takva definira svojevrsni samostalni jezik unutar jezika R veća učinkovitost od metoda koje nudi osnovni paket (inicijalno je dplyr dizajniran za veću učinkovitost programiranja, ne nužno za bolje performanse, no u međuvremenu implementacija određenih rutina u C-u omogućila je i poboljšanje i performansi izvođenja) integracija sa relacijskim bazama podataka (funkcije paketa dplyr mogu se koristiti direktno nad tablicama u bazi uz pomoć automatskog prevođenja funkcija paketa dplyr u SQL naredbe) Spomenutih osnovnih “pet glagola” koje nudi paket dplyr su sljedeći: filter - za filtriranje podatkovnog skupa po retcima select - za odabir pojedinih stupaca arrange - za promjenu redoslijeda redaka mutate - za stvaranje novih stupaca iz postojećih summarise - za agregiranje podataka Pored pet osnovnih glagola vrlo često koristimo i: group_by za grupiranje podataka unutar podatkovnog skupa porodicu join funkcija za spajanje podatkovnih okvira Poznavatelji jezika SQL lako će uočiti paralele između tog jezika i navedenih funkcionalnosti paketa dplyr. Najveća razlika jest u tome što SQL radi “deklarativno”, tj. moramo pratiti pravila izgradnje SQL naredbe koja “sve radi odjednom”, dok u R-u uz pomoć funkcija paketa dplyr i već ranije upoznatog operatora %&gt;% radnje nad podatkovnim skupovima možemo izvoditi proceduralno, s jasnim tijekom obrade podataka slijeva na desno. Prije detaljnog pregleda funkcionalnosti paketa dplyr pogledajmo ogledni podatkovni skup kojeg ćemo koristiti tijekom ove lekcije. 12.1 Ogledni podatkovni skup: Titanic Odaberimo za početak jedan često korišteni podatkovni skup – “Titanic Passenger Survival Dataset”. Ovaj skup pruža informacije o sudbinama putnika prekoocenaskog putničkog broda Titanic koji je potonuo 14. travnja 1912. godine pri čemu je od 2223 putnika i članova posade preživjelo samo njih 706. Podatkovni skup između ostalog sadrži imena putnika, spol, godište u trenutku potonuća, putničku klasu i sl. Postoji inačica ovog podatkovnog skupa koja dolazi sa samom R distribucijom, no mi ćemo koristiti njegovu proširenu inačicu sa Kaggle natjecanja “Titanic: Machine Learning From Disaster” o kojem se više detalja može saznati na ovoj poveznici. Učitajmo ovaj podatkovni skup uz pomoć funkcije read_csv, već viđene funkcije paketa readr koja “nadograđuje” funkciju read.csv. Isto tako, umjesto funkcije str, možemo koristiti njezin ekvivalent glimpse kojeg nudi paket dplyr. Zadatak 11.1 - podatkovni skup Titanic # učitajte podatkovni skup iz datoteke `Titanic.csv` u varijablu `titanic` uz pomoć funkcije `read_csv` iz paketa `readr` # prije korištenja funkcije proučite dokumentaciju iste #pogledajte strukturu podatkovnog okvira `titanic` uz pomoć funkcije `glimpse` #i prvih nekoliko redaka uz pomoć funkcije `head` titanic &lt;- read_csv(&quot;Titanic.csv&quot;) glimpse(titanic) head(titanic) ## Rows: 891 Columns: 12 ## ── Column specification ─────────────────────────────────────────── ## Delimiter: &quot;,&quot; ## chr (5): Name, Sex, Ticket, Cabin, Embarked ## dbl (7): PassengerId, Survived, Pclass, Age, SibSp, Parch, Fare ## ## ℹ Use `spec()` to retrieve the full column specification for this data. ## ℹ Specify the column types or set `show_col_types = FALSE` to quiet this message. ## Rows: 891 ## Columns: 12 ## $ PassengerId &lt;dbl&gt; 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17,… ## $ Survived &lt;dbl&gt; 0, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 1, 0, 1, 0, 1… ## $ Pclass &lt;dbl&gt; 3, 1, 3, 1, 3, 3, 1, 3, 3, 2, 3, 1, 3, 3, 3, 2, 3, 2, 3, 3… ## $ Name &lt;chr&gt; &quot;Braund, Mr. Owen Harris&quot;, &quot;Cumings, Mrs. John Bradley (Fl… ## $ Sex &lt;chr&gt; &quot;male&quot;, &quot;female&quot;, &quot;female&quot;, &quot;female&quot;, &quot;male&quot;, &quot;male&quot;, &quot;mal… ## $ Age &lt;dbl&gt; 22, 38, 26, 35, 35, NA, 54, 2, 27, 14, 4, 58, 20, 39, 14, … ## $ SibSp &lt;dbl&gt; 1, 1, 0, 1, 0, 0, 0, 3, 0, 1, 1, 0, 0, 1, 0, 0, 4, 0, 1, 0… ## $ Parch &lt;dbl&gt; 0, 0, 0, 0, 0, 0, 0, 1, 2, 0, 1, 0, 0, 5, 0, 0, 1, 0, 0, 0… ## $ Ticket &lt;chr&gt; &quot;A/5 21171&quot;, &quot;PC 17599&quot;, &quot;STON/O2. 3101282&quot;, &quot;113803&quot;, &quot;37… ## $ Fare &lt;dbl&gt; 7.2500, 71.2833, 7.9250, 53.1000, 8.0500, 8.4583, 51.8625,… ## $ Cabin &lt;chr&gt; NA, &quot;C85&quot;, NA, &quot;C123&quot;, NA, NA, &quot;E46&quot;, NA, NA, NA, &quot;G6&quot;, &quot;C… ## $ Embarked &lt;chr&gt; &quot;S&quot;, &quot;C&quot;, &quot;S&quot;, &quot;S&quot;, &quot;S&quot;, &quot;Q&quot;, &quot;S&quot;, &quot;S&quot;, &quot;S&quot;, &quot;C&quot;, &quot;S&quot;, &quot;S&quot;… ## # A tibble: 6 × 12 ## PassengerId Survived Pclass Name Sex Age SibSp Parch Ticket Fare Cabin ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; ## 1 1 0 3 Braund… male 22 1 0 A/5 2… 7.25 &lt;NA&gt; ## 2 2 1 1 Cuming… fema… 38 1 0 PC 17… 71.3 C85 ## 3 3 1 3 Heikki… fema… 26 0 0 STON/… 7.92 &lt;NA&gt; ## 4 4 1 1 Futrel… fema… 35 1 0 113803 53.1 C123 ## 5 5 0 3 Allen,… male 35 0 0 373450 8.05 &lt;NA&gt; ## 6 6 0 3 Moran,… male NA 0 0 330877 8.46 &lt;NA&gt; ## # ℹ 1 more variable: Embarked &lt;chr&gt; Mogli smo uočiti da funkcija read_csv formalno ne vraća “obični” podatkovni okvir, već objekt klase tibble. Što je “tibble”? To je kolokvijalni naziv za objekt klase tbl_df, koja predstavlja svojevrsnu nadogradnju klase data.frame, tj. osnovnog podatkovnog okvira. Najveća prednost ovog tipa objekta jest što će se kod pokušaja ispisa cijelog okvira na zaslon (što se najčešće događa omaškom i što rezultira “smrzavanjem” R konzole) pozvati posebna funkcija koja će ispisati samo dio okvira i moći će se odmah nastaviti s radom. Ako želimo neki postojeći podatkovni okvir “nadograditi” u tibble, to možemo učiniti uz pomoć naredbe as_tibble (uočite kako se funkcije iz kolekcije tidyverse često oslanjaju na podcrtu tj. “underscore” kako bi ih lakše identificirali kao nadogradnje osnovnih funkcija koje imaju slične nazive ali koriste točku). Uz pomoć funkcije options i parametara tibble.print_max i tibble.width možemo kontrolirati koliko u općenitom slučaju želimo ispisati stupaca i redaka u općenitom slučaju npr: # zelim u ispisu vidjeti najvise 10 redaka ali sve stupce options(tibble.print_max = 10, tibble.width = Inf) a kod pojedinog ispisa broj redaka možemo birati uz pomoć parametra n: # `df` je klase `tbl`, zelim vidjeti 50 redaka u ispisu print(df, n = 50) Prije nastavka bilo bi dobro pobliže se upoznati sa podatkovnim skupom kojeg ćemo koristiti, bilo nešto detaljnijim istraživanjem podatkovnog skupa, bilo prikupljanjem dokumentacije o istom. Kraći opis samog podatkovnog skupa preuzet sa službenih stranica Keggle natjecanja slijedi: VARIABLE DESCRIPTIONS: survival Survival (0 = No; 1 = Yes) pclass Passenger Class (1 = 1st; 2 = 2nd; 3 = 3rd) name Name sex Sex age Age sibsp Number of Siblings/Spouses Aboard parch Number of Parents/Children Aboard ticket Ticket Number fare Passenger Fare cabin Cabin embarked Port of Embarkation (C = Cherbourg; Q = Queenstown; S = Southampton) SPECIAL NOTES: Pclass is a proxy for socio-economic status (SES) 1st ~ Upper; 2nd ~ Middle; 3rd ~ Lower Age is in Years; Fractional if Age less than One (1) If the Age is Estimated, it is in the form xx.5 With respect to the family relation variables (i.e. sibsp and parch) some relations were ignored. The following are the definitions used for sibsp and parch. Sibling: Brother, Sister, Stepbrother, or Stepsister of Passenger Aboard Titanic Spouse: Husband or Wife of Passenger Aboard Titanic (Mistresses and Fiances Ignored) Parent: Mother or Father of Passenger Aboard Titanic Child: Son, Daughter, Stepson, or Stepdaughter of Passenger Aboard Titanic Other family relatives excluded from this study include cousins, nephews/nieces, aunts/uncles, and in-laws. Some children travelled only with a nanny, therefore parch=0 for them. As well, some travelled with very close friends or neighbors in a village, however, the definitions do not support such relations. U ovom trenutku bi trebalo razmotriti uključuje li podatkovni skup neke kategorijske podatke. Kao što smo naučili, za razliku od funkcije read.csv koja automatski faktorizira sve znakovne stupce (što nije preporučljivo), funkcija read_csv iz paketa readr ne faktorizira ništa, već to ostavlja na odgovornost analitičaru. Iako ovo predstavlja dodatni posao za analitičara, razina kontrole i robusnosti koja se time dobiva je više nego dostatni kompromis. U podatkovnom skupu titanic uočavamo sljedeće kategorijske varijable: Survival (preživljavanje – 2 kategorije: 0 i 1) Pclass (putnička klasa – 3 kategorije: 1, 2 i 3) Sex (spol – 2 kategorije: “M” i “F”) Embarked (luka ukrcaja – 3 kategorije: “C”, “Q” i “S”) Faktorizirajmo navedene stupce. Zadatak 11.2 - Kategorizacija stupaca podatkovnoga skupa Titanic # pretvorite stupce `Survival`, `Pclass`, `Sex` i `Embarked` # podatkovnog okvira `titanic` u faktore # proučite podatkovni okvir `titanic` # uz pomoć funkcije `glimpse` # pretvorite stupce `Survival`, `Pclass`, `Sex` i `Embarked` # podatkovnog okvira `titanic` u faktore titanic$Survived &lt;- as.factor(titanic$Survived) titanic$Pclass &lt;- as.factor(titanic$Pclass) titanic$Sex &lt;- as.factor(titanic$Sex) titanic$Embarked &lt;- as.factor(titanic$Embarked) # proučite podatkovni okvir `titanic` # uz pomoć funkcije `glimpse` glimpse(titanic) ## Rows: 891 ## Columns: 12 ## $ PassengerId &lt;dbl&gt; 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17,… ## $ Survived &lt;fct&gt; 0, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 1, 0, 1, 0, 1… ## $ Pclass &lt;fct&gt; 3, 1, 3, 1, 3, 3, 1, 3, 3, 2, 3, 1, 3, 3, 3, 2, 3, 2, 3, 3… ## $ Name &lt;chr&gt; &quot;Braund, Mr. Owen Harris&quot;, &quot;Cumings, Mrs. John Bradley (Fl… ## $ Sex &lt;fct&gt; male, female, female, female, male, male, male, male, fema… ## $ Age &lt;dbl&gt; 22, 38, 26, 35, 35, NA, 54, 2, 27, 14, 4, 58, 20, 39, 14, … ## $ SibSp &lt;dbl&gt; 1, 1, 0, 1, 0, 0, 0, 3, 0, 1, 1, 0, 0, 1, 0, 0, 4, 0, 1, 0… ## $ Parch &lt;dbl&gt; 0, 0, 0, 0, 0, 0, 0, 1, 2, 0, 1, 0, 0, 5, 0, 0, 1, 0, 0, 0… ## $ Ticket &lt;chr&gt; &quot;A/5 21171&quot;, &quot;PC 17599&quot;, &quot;STON/O2. 3101282&quot;, &quot;113803&quot;, &quot;37… ## $ Fare &lt;dbl&gt; 7.2500, 71.2833, 7.9250, 53.1000, 8.0500, 8.4583, 51.8625,… ## $ Cabin &lt;chr&gt; NA, &quot;C85&quot;, NA, &quot;C123&quot;, NA, NA, &quot;E46&quot;, NA, NA, NA, &quot;G6&quot;, &quot;C… ## $ Embarked &lt;fct&gt; S, C, S, S, S, Q, S, S, S, C, S, S, S, S, S, S, Q, S, S, C… Postoji i sažetija alternativa za faktoriziranje stupaca koja koristi lapply: categories &lt;- c(&quot;Survived&quot;, &quot;Pclass&quot;, &quot;Sex&quot;, &quot;Embarked&quot;) titanic[categories] &lt;- lapply(titanic[categories], as.factor) Sada kada dobro razumijemo naš podatkovni skup i kada smo obavili inicijalne pripreme u smislu kategorizacije stupaca, možemo krenuti sa upoznavanjem funkcija paketa dplyr. 12.2 Stvaranje podskupa obzervacija uz filter i slice U poglavlju o podatkovnim okvirima smo već naučili da se “rezanje” podatkovnih okvira može raditi slično rezanju matrica - uz pomoć indeksnih vektora kojima definiramo koje retke/stupce zadržavamo. Isto tako, naučili smo da indeksni vektori mogu biti cjelobrojni (lokacijski), logički i imenski. Kod definicije podskupa redaka daleko najčešći tip indeksnog vektora je logički - uz pomoć varijabli tj. stupaca definiramo određeni kriterij koji “filtrira” retke. Nažalost, osnovna R-ova sintaksa korištenja logičkih indeksnih redaka za određivanje podskupa redaka je ponešto nespretna, što se može vidjeti iz primjera: podaci[podaci$a &gt; 5 &amp; podaci$b != 3, ] Prvi i očiti problem jest potreba ponavljanja imena podatkovnog okvira (koju možemo eliminirati uz pomoć funkcije attach, što smo rekli da nije idealno rješenje jer donosi niz novih potencijalnih problema). Drugo pitanje jest problem čitljivosti - gornju naredbu nije lako vizualno interpretirati, tj. naknadnim pregledom koda nije lako odmah uočiti da se radi o reduciranju broja redaka. Funkcija filter eksplicitnom sintaksom odaje da se radi o filtriranju redaka, a također omogućuje korištenje imena stupaca bez potrebe za referenciranjem imena podatkovnog okvira: filter(podaci, a &gt; 5 &amp; b != 3) Isto tako, dobro je uočiti da je prvi argument funkcije sam podatkovni skup, što nam omogućuje jednostavno ulančavanje. Na ovom principu dizajnirana je većina funkcija paketa dplyr. Gore navedena funkcija predstavlja najčešći način odabira podskupa redaka (poznavatelji SQL-a uočiti će sličnost sa WHERE segmentom SQL upita). Pored funkcije filter, za određivanje podskupa redaka imamo i sljedeće funkcije, također vrlo intuitivnih imena (radi lakše interpretacije umjesto potpisa funkcija dajemo primjere parametara): distinct(podaci) - za uklanjanje duplikata slice(podaci, 1:10) - za lokacijsko indeksiranje sample_frac(podaci, 0.2) - nasumični odabir dijela skupa po danom omjeru sample_n(podaci, 50) - nasumični odabir zadanog broja redaka top_n(podaci, 10, a) - prvih n redaka, gledano po poretku stupca a Za poredak redaka u ispisu možemo koristiti: arrange(podaci, a, desc(b)) - poredaj po stupcu a uzlazno pa po b silazno Isprobajmo ovo na primjerima: Zadatak 11.3 - odabir redaka # ispišite podatke o svim putnicima prve klase starijim od 60 godina # ispišite podatke o svim preživjelim muškim putnicima koji # u imenu imaju `George` ili `Frank` # provjerite ima li u podatkovnom skupu duplih obzervacija # nasumično izaberite i ispišite podatke o pet putnika koji nisu preživjeli potonuće # ispis poredati silazno po cijeni karte # ispišite podatke o pet najstarijih putnica prve klase # ispišite podatke o svim putnicima prve klase starijim od 60 godina filter(titanic, Pclass == 1 &amp; Age &gt; 60) ## # A tibble: 14 × 12 ## PassengerId Survived Pclass Name Sex Age SibSp Parch Ticket Fare Cabin ## &lt;dbl&gt; &lt;fct&gt; &lt;fct&gt; &lt;chr&gt; &lt;fct&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; ## 1 55 0 1 Ostby… male 65 0 1 113509 62.0 B30 ## 2 97 0 1 Golds… male 71 0 0 PC 17… 34.7 A5 ## 3 171 0 1 Van d… male 61 0 0 111240 33.5 B19 ## 4 253 0 1 Stead… male 62 0 0 113514 26.6 C87 ## 5 276 1 1 Andre… fema… 63 1 0 13502 78.0 D7 ## 6 439 0 1 Fortu… male 64 1 4 19950 263 C23 … ## 7 457 0 1 Mille… male 65 0 0 13509 26.6 E38 ## 8 494 0 1 Artag… male 71 0 0 PC 17… 49.5 &lt;NA&gt; ## 9 546 0 1 Nicho… male 64 0 0 693 26 &lt;NA&gt; ## 10 556 0 1 Wrigh… male 62 0 0 113807 26.6 &lt;NA&gt; ## 11 626 0 1 Sutto… male 61 0 0 36963 32.3 D50 ## 12 631 1 1 Barkw… male 80 0 0 27042 30 A23 ## 13 746 0 1 Crosb… male 70 1 1 WE/P … 71 B22 ## 14 830 1 1 Stone… fema… 62 0 0 113572 80 B28 ## # ℹ 1 more variable: Embarked &lt;fct&gt; # ispišite podatke o svim preživjelim muškim putnicima koji # u imenu imaju `George` ili `Frank` filter(titanic, str_detect(Name, &quot;(George|Frank)&quot;) &amp; Sex == &quot;male&quot; &amp; Survived == 1) ## # A tibble: 6 × 12 ## PassengerId Survived Pclass Name Sex Age SibSp Parch Ticket Fare Cabin ## &lt;dbl&gt; &lt;fct&gt; &lt;fct&gt; &lt;chr&gt; &lt;fct&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; ## 1 166 1 3 &quot;Golds… male 9 0 2 363291 20.5 &lt;NA&gt; ## 2 371 1 1 &quot;Harde… male 25 1 0 11765 55.4 E50 ## 3 508 1 1 &quot;Bradl… male NA 0 0 111427 26.6 &lt;NA&gt; ## 4 571 1 2 &quot;Harri… male 62 0 0 S.W./… 10.5 &lt;NA&gt; ## 5 710 1 3 &quot;Mouba… male NA 1 1 2661 15.2 &lt;NA&gt; ## 6 832 1 2 &quot;Richa… male 0.83 1 1 29106 18.8 &lt;NA&gt; ## # ℹ 1 more variable: Embarked &lt;fct&gt; # provjerite ima li u podatkovnom skupu duplih obzervacija nrow(titanic) == nrow(distinct(titanic)) ## [1] TRUE # nasumično izaberite i ispišite podatke o pet putnika koji nisu preživjeli potonuće # ispis poredati silazno po cijeni karte filter(titanic, Survived == 0) %&gt;% sample_n(5) %&gt;% arrange(desc(Fare)) ## # A tibble: 5 × 12 ## PassengerId Survived Pclass Name Sex Age SibSp Parch Ticket Fare Cabin ## &lt;dbl&gt; &lt;fct&gt; &lt;fct&gt; &lt;chr&gt; &lt;fct&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; ## 1 51 0 3 Panula… male 7 4 1 31012… 39.7 &lt;NA&gt; ## 2 552 0 2 Sharp,… male 27 0 0 244358 26 &lt;NA&gt; ## 3 151 0 2 Batema… male 51 0 0 S.O.P… 12.5 &lt;NA&gt; ## 4 336 0 3 Denkof… male NA 0 0 349225 7.90 &lt;NA&gt; ## 5 768 0 3 Mangan… fema… 30.5 0 0 364850 7.75 &lt;NA&gt; ## # ℹ 1 more variable: Embarked &lt;fct&gt; # ispišite podatke o pet najstarijih putnica prve klase filter(titanic, Pclass == 1 &amp; Sex == &quot;female&quot;) %&gt;% top_n(5, Age) %&gt;% arrange(Age) ## # A tibble: 6 × 12 ## PassengerId Survived Pclass Name Sex Age SibSp Parch Ticket Fare Cabin ## &lt;dbl&gt; &lt;fct&gt; &lt;fct&gt; &lt;chr&gt; &lt;fct&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; ## 1 12 1 1 Bonnel… fema… 58 0 0 113783 26.6 C103 ## 2 196 1 1 Lurett… fema… 58 0 0 PC 17… 147. B80 ## 3 269 1 1 Graham… fema… 58 0 1 PC 17… 153. C125 ## 4 367 1 1 Warren… fema… 60 1 0 110813 75.2 D37 ## 5 830 1 1 Stone,… fema… 62 0 0 113572 80 B28 ## 6 276 1 1 Andrew… fema… 63 1 0 13502 78.0 D7 ## # ℹ 1 more variable: Embarked &lt;fct&gt; Uočite da “prvih n” redaka samo odabire podskup redaka, neće ga nužno ispisati po redu. Ukoliko želimo poredani ispis moramo koristiti i funkciju arrange. 12.3 Stvaranje podskupa varijabli uz select Druga metoda rezanja podatkovnog okvira jest odabir podskupa stupaca. Za razliku od biranja podskupa redaka, gdje se najčešće služimo logičkim indeksiranjem tj. filtriranjem po određenom kriteriju, stupce tj. varijable najčešće referenciramo po njihovom imenu. Sintaksa odabira podskupa stupaca po imenu uz pomoć osnovnog načina indeksiranja u R-u izgleda na primjer ovako: podaci[, c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;)] Ovdje također uočavamo određenu nespretnost i teškoću interpretacije. Nazivi stupaca moraju biti ugrađeni u funkciju stvaranja vektora što smanjuje čitljivost, a naredba nigdje eksplicitno ne iskazuje da se radi o odabiru stupaca već do moramo zaključiti iz položaja indeksnog vektora. Dodatno, nema jednostavnog načina za odabir raspona stupaca po imenu, postojanju nekog podniza ili uzorka unutar imena i sl. Funkcija select nam omogućuje eksplicitni odabir stupaca uz pomoć sintakse: select(podaci, a, b, c) Dakle jednostavno navodimo podatkovni okvir i niz stupaca koje želimo odabrati. Ovdje je također lako uočiti sličnost sa SQL-om, konkretno SELECT segmentom SQL upita. No gornja sintaksa nije sve što ova funkcija nudi - select ima čitav niz pomoćnih funkcija i operatora koji uvelike proširuju njezinu funkcionalnost, kao npr: select(podaci, a:c) - odaberi stupce od a do c select(podaci, -a, -b) - odaberi sve stupce osim a i b select(podaci, starts_with(\"PO\"))) - odaberi stupce koji počinju sa slovima \"PO\" select(podaci, contains(\"stup\")) - odaberi stupce koji sadrže podniz \"stup\" select(podaci, matches(\"[123]{2,3}\")) - odaberi stupce koji odgovaraju danom regularnom izrazu Ovo nisu sve mogućnosti, no dodatne opcije lako je pronaći u službenoj dokumentaciji. Isprobajmo ovu naredbu, također na podatkovnom skupu Titanic. Zadatak 11.4 - funkcija select # za nasumično odabranih 10 redaka ispišite ime putnika, dob te # da li je preživio potonuće ili ne # za prvih 10 najstarijih putnika ispišite sve atribute od imena do cijene karte # za nasumično odabranih 1% redaka ispišite sve atribute osim identifikatora # putnika i broja kabine # za retke od broja 10 do broja 20 ispišite sve stupce koji počinju samoglasnikom # za nasumičnih 10 putnika koji imaju nepoznat broj godina ispišite sve # atribute od imena do cijene karte, # potom putničku klasu te konačno da li je putnik preživio ili ne # poredajte ispis abecedno po imenu # za nasumično odabranih 10 redaka ispišite ime putnika, dob te # da li je preživio potonuće ili ne sample_n(titanic, 10) %&gt;% select(Name, Age, Survived) ## # A tibble: 10 × 3 ## Name Age Survived ## &lt;chr&gt; &lt;dbl&gt; &lt;fct&gt; ## 1 Millet, Mr. Francis Davis 65 0 ## 2 Wilhelms, Mr. Charles 31 1 ## 3 Davis, Miss. Mary 28 1 ## 4 Brocklebank, Mr. William Alfred 35 0 ## 5 Lindahl, Miss. Agda Thorilda Viktoria 25 0 ## 6 Vande Walle, Mr. Nestor Cyriel 28 0 ## 7 Nosworthy, Mr. Richard Cater 21 0 ## 8 Artagaveytia, Mr. Ramon 71 0 ## 9 Youseff, Mr. Gerious 45.5 0 ## 10 Bryhl, Mr. Kurt Arnold Gottfrid 25 0 # za prvih 10 najstarijih putnika ispišite sve atribute od imena do cijene karte top_n(titanic, 10, Age) %&gt;% select(Name:Fare) ## # A tibble: 11 × 7 ## Name Sex Age SibSp Parch Ticket Fare ## &lt;chr&gt; &lt;fct&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 Wheadon, Mr. Edward H male 66 0 0 C.A. 24579 10.5 ## 2 Ostby, Mr. Engelhart Cornelius male 65 0 1 113509 62.0 ## 3 Goldschmidt, Mr. George B male 71 0 0 PC 17754 34.7 ## 4 Connors, Mr. Patrick male 70.5 0 0 370369 7.75 ## 5 Duane, Mr. Frank male 65 0 0 336439 7.75 ## 6 Millet, Mr. Francis Davis male 65 0 0 13509 26.6 ## 7 Artagaveytia, Mr. Ramon male 71 0 0 PC 17609 49.5 ## 8 Barkworth, Mr. Algernon Henry Wilson male 80 0 0 27042 30 ## 9 Mitchell, Mr. Henry Michael male 70 0 0 C.A. 24580 10.5 ## 10 Crosby, Capt. Edward Gifford male 70 1 1 WE/P 5735 71 ## 11 Svensson, Mr. Johan male 74 0 0 347060 7.78 # za nasumično odabranih 1% redaka ispišite sve atribute osim identifikatora # putnika i broja kabine sample_frac(titanic, 0.01) %&gt;% select(-PassengerId, -Cabin) ## # A tibble: 9 × 10 ## Survived Pclass Name Sex Age SibSp Parch Ticket Fare Embarked ## &lt;fct&gt; &lt;fct&gt; &lt;chr&gt; &lt;fct&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; &lt;fct&gt; ## 1 0 3 Cacic, Mr. Luka male 38 0 0 315089 8.66 S ## 2 1 2 Shelley, Mrs. W… fema… 25 0 1 230433 26 S ## 3 0 3 Lefebre, Miss. … fema… NA 3 1 4133 25.5 S ## 4 0 3 Tobin, Mr. Roger male NA 0 0 383121 7.75 Q ## 5 0 3 Dean, Mr. Bertr… male 26 1 2 C.A. … 20.6 S ## 6 0 3 Skoog, Miss. Ma… fema… 2 3 2 347088 27.9 S ## 7 0 2 Moraweck, Dr. E… male 54 0 0 29011 14 S ## 8 0 3 Nysveen, Mr. Jo… male 61 0 0 345364 6.24 S ## 9 0 3 Braund, Mr. Owe… male 22 1 0 A/5 2… 7.25 S # za retke od broja 10 do broja 20 ispišite sve stupce koji počinju samoglasnikom slice(titanic, 10:20) %&gt;% select(matches(&quot;^[AEIOUaeiou]&quot;)) ## # A tibble: 11 × 2 ## Age Embarked ## &lt;dbl&gt; &lt;fct&gt; ## 1 14 C ## 2 4 S ## 3 58 S ## 4 20 S ## 5 39 S ## 6 14 S ## 7 55 S ## 8 2 Q ## 9 NA S ## 10 31 S ## 11 NA C # za nasumičnih 10 putnika koji imaju nepoznat broj godina ispišite sve # atribute od imena do cijene karte, # potom putničku klasu te konačno da li je putnik preživio ili ne # poredajte ispis abecedno po imenu filter(titanic, is.na(Age)) %&gt;% sample_n(10) %&gt;% select(Name:Fare, Pclass, Survived) %&gt;% arrange(Name) ## # A tibble: 10 × 9 ## Name Sex Age SibSp Parch Ticket Fare Pclass Survived ## &lt;chr&gt; &lt;fct&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; &lt;fct&gt; &lt;fct&gt; ## 1 Farthing, Mr. John male NA 0 0 PC 17… 222. 1 0 ## 2 Garfirth, Mr. John male NA 0 0 358585 14.5 3 0 ## 3 Harrington, Mr. Charle… male NA 0 0 113796 42.4 1 0 ## 4 Mitkoff, Mr. Mito male NA 0 0 349221 7.90 3 0 ## 5 Moore, Mr. Leonard Cha… male NA 0 0 A4. 5… 8.05 3 0 ## 6 Moran, Mr. James male NA 0 0 330877 8.46 3 0 ## 7 Paulner, Mr. Uscher male NA 0 0 3411 8.71 3 0 ## 8 Peter, Miss. Anna fema… NA 1 1 2668 22.4 3 1 ## 9 Saalfeld, Mr. Adolphe male NA 0 0 19988 30.5 1 1 ## 10 Sadlier, Mr. Matthew male NA 0 0 367655 7.73 3 0 12.4 Stvaranje novih stupaca uz mutate U radu sa podatkovnim skupovima često se pojavi potreba za stvaranjem dodatnih varijabli uz pomoć informacija pohranjenih u jednoj ili više postojećih varijabli. Novi stupac najčešće stvaramo uz pomoć nekog izraza koji opisuje na koji način transformiramo postojeće podatke; motivacija može biti normalizacija numeričke varijable, stvaranje indikatorske ili kategorijske varijable, sumiranje više varijabli u jednu jedinstvenu varijablu ili bilo koja druga transformacija s ciljem dobivanja nove varijable koja je na neki način potrebna za daljnji proces analize. Ako pretpostavimo stvaranje novog stupca koji će pohraniti zbroj numeričkih vrijednosti postojećih stupaca, onda bi uz pomoć osnovnih funkcija R-a to proveli na sljedeći način: podaci$c &lt;- podaci$a + podaci$b Paket dplyr nam nudi alternativu u obliku funkcija mutate i transmute: mutate(podaci, c = a + b) transmute(podaci, c = a + b) Razlika: mutate vraća cijeli originalni podatkovni okvir uz novostvorene stupce, dok transmute zadržava samo one koje smo naveli unutar poziva funkcije. Zbog toga transmute možemo koristiti kao skraćenu kombinaciju mutate i select, npr: transmute(podaci, a, c = a + b) # isto kao i mutate(podaci, c = a + b) %&gt;% select(a, c) (NAPOMENA: Ovdje se ne moramo bojati degradacije performansi zbog kopiranja okvira, budući da R kod dodavanja stupca radi “plitku kopiju” (shallow copy), tj. novi okvir samo referencira novi stupac dok dijeli reference na preostale stupce sa “originalnim” okvirom. “Duboka kopija” (deep copy) bi značilo da se svi stupci kopiraju u potpuno novi okvir, u kojem slučaju bi ova operacija bila resursno “skupa”) Uočite da mutate i transmute nisu alternative naredbi UPDATE iz SQL-a, već zapravo odgovaraju SELECT segmentu naredbe u scenarijima kada ne biramo pojedine stupce već ih kombiniramo u sklopu izraza. Funkcije mutate i transmute koriste uobičajene (vektorizirane) funkcije i operatore, a imamo na raspolaganju i niz dodatnih tzv. “prozorskih” (window) funkcija koje nam omogućuju dodatnu fleksibilnost kod stvaranja novih varijabli, kao npr: ntile, cut - stvaranje kategorijske varijable koja grupira vrijednosti u n ladica; ntile će napraviti kategorije jednake veličine, dok će cut rezati u ovisnosti o veličini intervala numeričkih vrijednosti dense_rank, min_rank - rangiranje obzervacija (razlika je samo u tretiranju obzervacija sa istim vrijednostima) between - opisuje da li je varijabla nekog stupca u intervalu zadanom sa dva druga stupca pmin, pmax - “paralelni minimum i maksimum”, tj. minimum ili maksimum vrijednosti odabranih stupaca gledano po retcima itd. Popis svih dostupnih funkcija može se pronaći u dokumentaciji. Zadatak 11.5 - funkcija mutate # tablici `titanic` dodajte logički stupac `hadRelativesOnBoard` koji će opisivati # da li je putnik imao rodbine na brodu # za nasumičnih 10 putnica starijih od 20 godina koje su se ukrcale u Southamptonu # ispišite ime putnice, putničku klasu i prilagođenu cijenu karte # cijenu karte zamijenite odgovarajućom cijenom koliko bi ona iznosila danas # (pretpostavite da je $1 iz 1912. jednak današnjih $23.85, uračunavajući inflaciju) # novi stupac nazovite `FareToday` a # iznos zaokružite na dvije decimale i dodajte prefiks `$` # ispis poredajte po putničkoj klasi silazno # stvorite stupac FareCategory kojim ćete podijeliti cijene karata # u pet kategorija jednake veličine # potom nasumično izaberite 20 putnika i ispišite # ime putnika, putničku klasu, cijenu karte i kategoriju # ispis poredajte po kategoriji cijene # tablici `titanic` dodajte stupac `EmbarkationPort` u kojem će pisati puno # ime luke ukrcaja (Southampton, Queenstown ili Cherbourg) # koristite `mutate` i dva `ifelse` # ispišite prvih 10 redaka tablice `titanic` # tablici `titanic` dodajte logički stupac `hadRelativesOnBoard` koji će opisivati # da li je putnik imao rodbine na brodu titanic &lt;- mutate(titanic, hadRelativesOnBoard = SibSp &gt; 0 | Parch &gt; 0) # za nasumičnih 10 putnica starijih od 20 godina koje su se ukrcale u Southamptonu # ispišite ime putnice, putničku klasu i prilagođenu cijenu karte # cijenu karte zamijenite odgovarajućom cijenom koliko bi ona iznosila danas # (pretpostavite da je $1 iz 1912. jednak današnjih $23.85, uračunavajući inflaciju) # novi stupac nazovite `FareToday` a iznos zaokružite na dvije decimale i dodajte prefiks `$` # ispis poredajte po putničkoj klasi silazno filter(titanic, Sex == &#39;female&#39;, Age &gt; 20, Embarked == &#39;S&#39;) %&gt;% sample_n(10) %&gt;% transmute(Name, Pclass, FareToday = str_c(&quot;$&quot;, round(Fare * 23.85, 2))) %&gt;% arrange(desc(Pclass)) ## # A tibble: 10 × 3 ## Name Pclass FareToday ## &lt;chr&gt; &lt;fct&gt; &lt;chr&gt; ## 1 Asplund, Mrs. Carl Oscar (Selma Augusta Emilia Johansson) 3 $748.59 ## 2 Andersson, Mrs. Anders Johan (Alfrida Konstantia Brogren) 3 $745.91 ## 3 Lahtinen, Mrs. William (Anna Sylfven) 2 $620.1 ## 4 Ball, Mrs. (Ada E Hall) 2 $310.05 ## 5 Mack, Mrs. (Mary) 2 $250.43 ## 6 Swift, Mrs. Frederick Joel (Margaret Welles Barron) 1 $618.41 ## 7 Shutes, Miss. Elizabeth W 1 $3660.08 ## 8 Perreault, Miss. Anne 1 $2229.98 ## 9 Hogeboom, Mrs. John C (Anna Andrews) 1 $1859.31 ## 10 Robert, Mrs. Edward Scott (Elisabeth Walton McMillan) 1 $5040.4 # stvorite stupac FareCategory kojim ćete podijeliti cijene karata # u pet kategorija jednake veličine # potom nasumično izaberite 20 putnika i ispišite # ime putnika, putničku klasu, cijenu karte i kategoriju # ispis poredajte po kategoriji cijene mutate(titanic, FareCategory = ntile(Fare, 5)) %&gt;% sample_n(20) %&gt;% select(Name, Pclass, Fare, FareCategory) %&gt;% arrange(FareCategory) ## # A tibble: 20 × 4 ## Name Pclass Fare FareCategory ## &lt;chr&gt; &lt;fct&gt; &lt;dbl&gt; &lt;int&gt; ## 1 &quot;Carlsson, Mr. August Sigfrid&quot; 3 7.80 1 ## 2 &quot;Coelho, Mr. Domingos Fernandeo&quot; 3 7.05 1 ## 3 &quot;Parkes, Mr. Francis \\&quot;Frank\\&quot;&quot; 2 0 1 ## 4 &quot;Attalah, Mr. Sleiman&quot; 3 7.22 1 ## 5 &quot;Rogers, Mr. William John&quot; 3 8.05 2 ## 6 &quot;Harris, Mr. George&quot; 2 10.5 2 ## 7 &quot;Kraeff, Mr. Theodor&quot; 3 7.90 2 ## 8 &quot;Moore, Mr. Leonard Charles&quot; 3 8.05 2 ## 9 &quot;Hamalainen, Master. Viljo&quot; 2 14.5 3 ## 10 &quot;Panula, Master. Eino Viljami&quot; 3 39.7 4 ## 11 &quot;Andersson, Mr. Anders Johan&quot; 3 31.3 4 ## 12 &quot;Hart, Miss. Eva Miriam&quot; 2 26.2 4 ## 13 &quot;Smith, Mr. James Clinch&quot; 1 30.7 4 ## 14 &quot;Blank, Mr. Henry&quot; 1 31 4 ## 15 &quot;Chibnall, Mrs. (Edith Martha Bowerman)&quot; 1 55 5 ## 16 &quot;Robbins, Mr. Victor&quot; 1 228. 5 ## 17 &quot;Maioni, Miss. Roberta&quot; 1 86.5 5 ## 18 &quot;Warren, Mrs. Frank Manley (Anna Sophia Atkinson)&quot; 1 75.2 5 ## 19 &quot;Chaffee, Mr. Herbert Fuller&quot; 1 61.2 5 ## 20 &quot;Fortune, Miss. Mabel Helen&quot; 1 263 5 # tablici `titanic` dodajte stupac `EmbarkationPort` u kojem će pisati puno ime luke ukrcaja # (Southampton, Queenstown ili Cherbourg) # koristite `mutate` i dva `ifelse` mutate(titanic, EmbarkationPort = ifelse(Embarked == &#39;S&#39;, &#39;Southampton&#39;, ifelse(Embarked == &#39;C&#39;, &#39;Cherbourg&#39;, &#39;Queenstown&#39;))) -&gt; titanic # ispišite prvih 10 redaka tablice `titanic` head(titanic, 10) ## # A tibble: 10 × 14 ## PassengerId Survived Pclass Name Sex Age SibSp Parch Ticket Fare Cabin ## &lt;dbl&gt; &lt;fct&gt; &lt;fct&gt; &lt;chr&gt; &lt;fct&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; ## 1 1 0 3 Braun… male 22 1 0 A/5 2… 7.25 &lt;NA&gt; ## 2 2 1 1 Cumin… fema… 38 1 0 PC 17… 71.3 C85 ## 3 3 1 3 Heikk… fema… 26 0 0 STON/… 7.92 &lt;NA&gt; ## 4 4 1 1 Futre… fema… 35 1 0 113803 53.1 C123 ## 5 5 0 3 Allen… male 35 0 0 373450 8.05 &lt;NA&gt; ## 6 6 0 3 Moran… male NA 0 0 330877 8.46 &lt;NA&gt; ## 7 7 0 1 McCar… male 54 0 0 17463 51.9 E46 ## 8 8 0 3 Palss… male 2 3 1 349909 21.1 &lt;NA&gt; ## 9 9 1 3 Johns… fema… 27 0 2 347742 11.1 &lt;NA&gt; ## 10 10 1 2 Nasse… fema… 14 1 0 237736 30.1 &lt;NA&gt; ## # ℹ 3 more variables: Embarked &lt;fct&gt;, hadRelativesOnBoard &lt;lgl&gt;, ## # EmbarkationPort &lt;chr&gt; 12.5 Ogledni podatkovni skup: Houston flights Učitajmo paket dplyr i podatkovni okvir hflights koji se nalazi u paketu istog imena i može ga se dohvatiti iz CRAN repozitorija. Nakon učitavanja paketa podatkovni okvir možemo prebaciti u globalnu okolinu uz pomoć funkcije data. Zadatak 11.6 - podatkovni skup hflights # učitajte paket `hflights` # ukoliko je potrebno instalirajte ga sa CRAN repozitorija # uz pomoć funkcije `data` učitajte okvir u globalnu okolinu # pretvorite okvir u `hflights` u &quot;tibble&quot; # upoznajte se s podatkovnim skupom `hflights` # pored funkcija glimpse/head/itd. možete pogledati i dokumentaciju # skupa uz pomoć naredbe `?hflights` #install.packages(&quot;hflights&quot;) # ukoliko je potrebno #library(dplyr) # ako već nisu učitani #library(hflights) data(hflights) hflights &lt;- as_tibble(hflights) glimpse(hflights) head(hflights) ## Rows: 227,496 ## Columns: 21 ## $ Year &lt;int&gt; 2011, 2011, 2011, 2011, 2011, 2011, 2011, 2011, 2011… ## $ Month &lt;int&gt; 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1… ## $ DayofMonth &lt;int&gt; 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 1… ## $ DayOfWeek &lt;int&gt; 6, 7, 1, 2, 3, 4, 5, 6, 7, 1, 2, 3, 4, 5, 6, 7, 1, 2… ## $ DepTime &lt;int&gt; 1400, 1401, 1352, 1403, 1405, 1359, 1359, 1355, 1443… ## $ ArrTime &lt;int&gt; 1500, 1501, 1502, 1513, 1507, 1503, 1509, 1454, 1554… ## $ UniqueCarrier &lt;chr&gt; &quot;AA&quot;, &quot;AA&quot;, &quot;AA&quot;, &quot;AA&quot;, &quot;AA&quot;, &quot;AA&quot;, &quot;AA&quot;, &quot;AA&quot;, &quot;AA&quot;… ## $ FlightNum &lt;int&gt; 428, 428, 428, 428, 428, 428, 428, 428, 428, 428, 42… ## $ TailNum &lt;chr&gt; &quot;N576AA&quot;, &quot;N557AA&quot;, &quot;N541AA&quot;, &quot;N403AA&quot;, &quot;N492AA&quot;, &quot;N… ## $ ActualElapsedTime &lt;int&gt; 60, 60, 70, 70, 62, 64, 70, 59, 71, 70, 70, 56, 63, … ## $ AirTime &lt;int&gt; 40, 45, 48, 39, 44, 45, 43, 40, 41, 45, 42, 41, 44, … ## $ ArrDelay &lt;int&gt; -10, -9, -8, 3, -3, -7, -1, -16, 44, 43, 29, 5, -9, … ## $ DepDelay &lt;int&gt; 0, 1, -8, 3, 5, -1, -1, -5, 43, 43, 29, 19, -2, -3, … ## $ Origin &lt;chr&gt; &quot;IAH&quot;, &quot;IAH&quot;, &quot;IAH&quot;, &quot;IAH&quot;, &quot;IAH&quot;, &quot;IAH&quot;, &quot;IAH&quot;, &quot;IA… ## $ Dest &lt;chr&gt; &quot;DFW&quot;, &quot;DFW&quot;, &quot;DFW&quot;, &quot;DFW&quot;, &quot;DFW&quot;, &quot;DFW&quot;, &quot;DFW&quot;, &quot;DF… ## $ Distance &lt;int&gt; 224, 224, 224, 224, 224, 224, 224, 224, 224, 224, 22… ## $ TaxiIn &lt;int&gt; 7, 6, 5, 9, 9, 6, 12, 7, 8, 6, 8, 4, 6, 5, 6, 12, 8,… ## $ TaxiOut &lt;int&gt; 13, 9, 17, 22, 9, 13, 15, 12, 22, 19, 20, 11, 13, 15… ## $ Cancelled &lt;int&gt; 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0… ## $ CancellationCode &lt;chr&gt; &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, … ## $ Diverted &lt;int&gt; 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0… ## # A tibble: 6 × 21 ## Year Month DayofMonth DayOfWeek DepTime ArrTime UniqueCarrier FlightNum ## &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;int&gt; ## 1 2011 1 1 6 1400 1500 AA 428 ## 2 2011 1 2 7 1401 1501 AA 428 ## 3 2011 1 3 1 1352 1502 AA 428 ## 4 2011 1 4 2 1403 1513 AA 428 ## 5 2011 1 5 3 1405 1507 AA 428 ## 6 2011 1 6 4 1359 1503 AA 428 ## # ℹ 13 more variables: TailNum &lt;chr&gt;, ActualElapsedTime &lt;int&gt;, AirTime &lt;int&gt;, ## # ArrDelay &lt;int&gt;, DepDelay &lt;int&gt;, Origin &lt;chr&gt;, Dest &lt;chr&gt;, Distance &lt;int&gt;, ## # TaxiIn &lt;int&gt;, TaxiOut &lt;int&gt;, Cancelled &lt;int&gt;, CancellationCode &lt;chr&gt;, ## # Diverted &lt;int&gt; 12.6 Grupiranje i agregacija uz group_by i summarise U literaturi koja se bavi analizom podataka često ćemo naići na tzv. SAC paradigmu (engl. Split-Apply-Combine). Radi se o strategiji koja se svodi na rastavljanje velikog zadatka na manje dijelove, obavljanje određenog posla na svakom od dijelova te konačno kombiniranje svih rezultata u jedinstvenu cjelinu. Potrebu za ovom paradigmom nailazimo u različitim scenarijima analize - u eksploratornoj analizi podataka htjet ćemo izračunati različite statistike ili stvoriti nove varijable zasebno za različite podskupove podataka (npr. ovisno o nekoj kategorijskoj varijabli); kod obrade iznimno velikih količina podataka često želimo ubrzati proces obrade na način da podatke razbijemo u manje skupove koji će se svaki obrađivati zasebno (poznati princip Map-Reduce). Poznavatelji SQL-a će ovaj princip lako prepoznati kao grupiranje i agregaciju koji se provode kroz GROUP BY segment SQL upita uz prateće elemente u SELECT dijelu. Paket dplyr nudi vrlo sličnu funkcionalnost (iako na proceduralni način) - prvo provedemo “grupiranje”, tj. stvaranje podskupova redaka nekog okvira, a onda provodimo daljnje obrade paralelno nad svakim podskupom, da bi na kraju sve rezultate sakupili u jedinstveni podatkovni okvir. Za grupiranje dplyr nudi funkciju group_by kojom tablicu (podatkovni okvir) pretvaramo u “grupiranu tablicu” (grouped_tbl): group_by(podaci, a, b, c) Isprobajmo ovu funkciju na našem okviru hflights. Zadatak 11.7 - grupirana tablica # stvorite varijablu `flight815` koja će sadržavati retke iz tablice `hflights` # vezane uz let broj 815 # stvorite varijablu `grouped815` koja će sadržavati retke iz `flight815` # grupirane po mjesecu # provjerite klasu varijabli `flight815` i `grouped815` # uz pomoć funkcije `glimpse` pogledajte strukture varijabli `flight815` i `grouped815` # stvorite varijablu `flight815` koja će sadržavati retke iz tablice `hflights` # vezane uz let broj 815 flight815 &lt;- filter(hflights, FlightNum == 815) # stvorite varijablu `grouped815` koja će sadržavati retke iz `flight815` # grupirane po mjesecu grouped815 &lt;- group_by(flight815, Month) # provjerite klasu varijabli `flight815` i `grouped815` class(flight815) class(grouped815) ## [1] &quot;tbl_df&quot; &quot;tbl&quot; &quot;data.frame&quot; ## [1] &quot;grouped_df&quot; &quot;tbl_df&quot; &quot;tbl&quot; &quot;data.frame&quot; # uz pomoć funkcije `glimpse` pogledajte strukture varijabli `flight815` i `grouped815` glimpse(flight815) print(&quot;------------------------&quot;) # radi preglednijeg ispisa na konzoli glimpse(grouped815) ## Rows: 95 ## Columns: 21 ## $ Year &lt;int&gt; 2011, 2011, 2011, 2011, 2011, 2011, 2011, 2011, 2011… ## $ Month &lt;int&gt; 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4… ## $ DayofMonth &lt;int&gt; 30, 29, 28, 27, 26, 25, 24, 23, 22, 21, 20, 19, 18, … ## $ DayOfWeek &lt;int&gt; 6, 5, 4, 3, 2, 1, 7, 6, 5, 4, 3, 2, 1, 7, 6, 5, 4, 3… ## $ DepTime &lt;int&gt; 2116, 2109, 2111, 2112, 2124, 2145, 2114, 2110, 2116… ## $ ArrTime &lt;int&gt; 2255, 2252, 2255, 2326, 2321, 2327, 2324, 2301, 2305… ## $ UniqueCarrier &lt;chr&gt; &quot;CO&quot;, &quot;CO&quot;, &quot;CO&quot;, &quot;CO&quot;, &quot;CO&quot;, &quot;CO&quot;, &quot;CO&quot;, &quot;CO&quot;, &quot;CO&quot;… ## $ FlightNum &lt;int&gt; 815, 815, 815, 815, 815, 815, 815, 815, 815, 815, 81… ## $ TailNum &lt;chr&gt; &quot;N74856&quot;, &quot;N57852&quot;, &quot;N78866&quot;, &quot;N57863&quot;, &quot;N57868&quot;, &quot;N… ## $ ActualElapsedTime &lt;int&gt; 219, 223, 224, 254, 237, 222, 250, 231, 229, 217, 23… ## $ AirTime &lt;int&gt; 194, 191, 190, 197, 198, 200, 192, 187, 186, 192, 18… ## $ ArrDelay &lt;int&gt; 12, 6, 9, 40, 35, 41, 38, 18, 19, 10, 29, 33, 35, 4,… ## $ DepDelay &lt;int&gt; 6, -1, 1, 2, 14, 35, 4, 0, 6, 9, 6, 17, 38, 11, 3, -… ## $ Origin &lt;chr&gt; &quot;IAH&quot;, &quot;IAH&quot;, &quot;IAH&quot;, &quot;IAH&quot;, &quot;IAH&quot;, &quot;IAH&quot;, &quot;IAH&quot;, &quot;IA… ## $ Dest &lt;chr&gt; &quot;LAX&quot;, &quot;LAX&quot;, &quot;LAX&quot;, &quot;LAX&quot;, &quot;LAX&quot;, &quot;LAX&quot;, &quot;LAX&quot;, &quot;LA… ## $ Distance &lt;int&gt; 1379, 1379, 1379, 1379, 1379, 1379, 1379, 1379, 1379… ## $ TaxiIn &lt;int&gt; 10, 13, 15, 18, 12, 10, 14, 19, 12, 12, 20, 15, 12, … ## $ TaxiOut &lt;int&gt; 15, 19, 19, 39, 27, 12, 44, 25, 31, 13, 39, 18, 15, … ## $ Cancelled &lt;int&gt; 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0… ## $ CancellationCode &lt;chr&gt; &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, … ## $ Diverted &lt;int&gt; 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0… ## [1] &quot;------------------------&quot; ## Rows: 95 ## Columns: 21 ## Groups: Month [6] ## $ Year &lt;int&gt; 2011, 2011, 2011, 2011, 2011, 2011, 2011, 2011, 2011… ## $ Month &lt;int&gt; 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4… ## $ DayofMonth &lt;int&gt; 30, 29, 28, 27, 26, 25, 24, 23, 22, 21, 20, 19, 18, … ## $ DayOfWeek &lt;int&gt; 6, 5, 4, 3, 2, 1, 7, 6, 5, 4, 3, 2, 1, 7, 6, 5, 4, 3… ## $ DepTime &lt;int&gt; 2116, 2109, 2111, 2112, 2124, 2145, 2114, 2110, 2116… ## $ ArrTime &lt;int&gt; 2255, 2252, 2255, 2326, 2321, 2327, 2324, 2301, 2305… ## $ UniqueCarrier &lt;chr&gt; &quot;CO&quot;, &quot;CO&quot;, &quot;CO&quot;, &quot;CO&quot;, &quot;CO&quot;, &quot;CO&quot;, &quot;CO&quot;, &quot;CO&quot;, &quot;CO&quot;… ## $ FlightNum &lt;int&gt; 815, 815, 815, 815, 815, 815, 815, 815, 815, 815, 81… ## $ TailNum &lt;chr&gt; &quot;N74856&quot;, &quot;N57852&quot;, &quot;N78866&quot;, &quot;N57863&quot;, &quot;N57868&quot;, &quot;N… ## $ ActualElapsedTime &lt;int&gt; 219, 223, 224, 254, 237, 222, 250, 231, 229, 217, 23… ## $ AirTime &lt;int&gt; 194, 191, 190, 197, 198, 200, 192, 187, 186, 192, 18… ## $ ArrDelay &lt;int&gt; 12, 6, 9, 40, 35, 41, 38, 18, 19, 10, 29, 33, 35, 4,… ## $ DepDelay &lt;int&gt; 6, -1, 1, 2, 14, 35, 4, 0, 6, 9, 6, 17, 38, 11, 3, -… ## $ Origin &lt;chr&gt; &quot;IAH&quot;, &quot;IAH&quot;, &quot;IAH&quot;, &quot;IAH&quot;, &quot;IAH&quot;, &quot;IAH&quot;, &quot;IAH&quot;, &quot;IA… ## $ Dest &lt;chr&gt; &quot;LAX&quot;, &quot;LAX&quot;, &quot;LAX&quot;, &quot;LAX&quot;, &quot;LAX&quot;, &quot;LAX&quot;, &quot;LAX&quot;, &quot;LA… ## $ Distance &lt;int&gt; 1379, 1379, 1379, 1379, 1379, 1379, 1379, 1379, 1379… ## $ TaxiIn &lt;int&gt; 10, 13, 15, 18, 12, 10, 14, 19, 12, 12, 20, 15, 12, … ## $ TaxiOut &lt;int&gt; 15, 19, 19, 39, 27, 12, 44, 25, 31, 13, 39, 18, 15, … ## $ Cancelled &lt;int&gt; 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0… ## $ CancellationCode &lt;chr&gt; &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, … ## $ Diverted &lt;int&gt; 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0… # ispišite prvih pet redaka varijable `flight815` head(flight815) print(&quot;------------------------&quot;) # ispišite prvih pet redaka varijable `grouped815` head(grouped815) ## # A tibble: 6 × 21 ## Year Month DayofMonth DayOfWeek DepTime ArrTime UniqueCarrier FlightNum ## &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;int&gt; ## 1 2011 4 30 6 2116 2255 CO 815 ## 2 2011 4 29 5 2109 2252 CO 815 ## 3 2011 4 28 4 2111 2255 CO 815 ## 4 2011 4 27 3 2112 2326 CO 815 ## 5 2011 4 26 2 2124 2321 CO 815 ## 6 2011 4 25 1 2145 2327 CO 815 ## # ℹ 13 more variables: TailNum &lt;chr&gt;, ActualElapsedTime &lt;int&gt;, AirTime &lt;int&gt;, ## # ArrDelay &lt;int&gt;, DepDelay &lt;int&gt;, Origin &lt;chr&gt;, Dest &lt;chr&gt;, Distance &lt;int&gt;, ## # TaxiIn &lt;int&gt;, TaxiOut &lt;int&gt;, Cancelled &lt;int&gt;, CancellationCode &lt;chr&gt;, ## # Diverted &lt;int&gt; ## [1] &quot;------------------------&quot; ## # A tibble: 6 × 21 ## # Groups: Month [1] ## Year Month DayofMonth DayOfWeek DepTime ArrTime UniqueCarrier FlightNum ## &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;int&gt; ## 1 2011 4 30 6 2116 2255 CO 815 ## 2 2011 4 29 5 2109 2252 CO 815 ## 3 2011 4 28 4 2111 2255 CO 815 ## 4 2011 4 27 3 2112 2326 CO 815 ## 5 2011 4 26 2 2124 2321 CO 815 ## 6 2011 4 25 1 2145 2327 CO 815 ## # ℹ 13 more variables: TailNum &lt;chr&gt;, ActualElapsedTime &lt;int&gt;, AirTime &lt;int&gt;, ## # ArrDelay &lt;int&gt;, DepDelay &lt;int&gt;, Origin &lt;chr&gt;, Dest &lt;chr&gt;, Distance &lt;int&gt;, ## # TaxiIn &lt;int&gt;, TaxiOut &lt;int&gt;, Cancelled &lt;int&gt;, CancellationCode &lt;chr&gt;, ## # Diverted &lt;int&gt; Vidimo da grupiranjem nismo “izgubili” nikakvu informaciju - grupirani podatkovni okvir i dalje izgleda identično originalnom, “negrupiranom” okviru. Zapravo jedina naznaka da je nešto drugačije jest nova, nasljeđena klasa te redak Groups:.. u ispisu redaka. Ovo znači da je grupiranje okvira samo naznaka da se neke daljnje (najčešće agregacijske) operacije ne izvode nad cijelim okvirom, već nad pojedinim grupama. Isto tako, ukoliko želimo, okvir uvijek možemo lako “odgrupirati” uz pomoć funkcije ungroup. Za agregaciju se koristimo funkcijom summarise koja prima podatke (grupiranu tablicu) a potom kombinacije agregacijskih funkcija i stupaca nad kojim se iste izvršavaju, npr.: summarise(podaci, meanA = mean(a), sdA = sd(a)) Za agregacijsku funkciju u pravilu možemo koristiti bilo koju funkciju koja vektor vrijednosti svodi na jednu vrijednost (npr. mean, max, sd itd.), a često korištene funkcije koje nudi sam paket dplyr su: first, last, nth - prvi, zadnji, n-ti element grupe n, n_distinct - broj (jedinstvenih) vrijednosti Zadatak 11.8 - funkcija summarise # izračunajte prosječno kašnjenje u dolasku leta za varijable `flight815` i `grouped815` # koristite funkciju `summarise` summarise(flight815, meanDelay = mean(ArrDelay)) print(&quot;------------------------&quot;) summarise(grouped815, meanDelay = mean(ArrDelay)) ## # A tibble: 1 × 1 ## meanDelay ## &lt;dbl&gt; ## 1 21.6 ## [1] &quot;------------------------&quot; ## # A tibble: 6 × 2 ## Month meanDelay ## &lt;int&gt; &lt;dbl&gt; ## 1 4 21.1 ## 2 5 20.9 ## 3 6 28.0 ## 4 8 -27.5 ## 5 9 14 ## 6 10 -13 Uočite da je poželjno imenovati agregirane stupce. U praksi ne čuvamo referencu na grupirane tablice već unutar jedne naredbe provodimo cijeli proces odabira redaka i stupaca, grupiranja i provođenja agregacije. Ako koristimo operator %&gt;%, onda to može izgledati ovako: filter(podaci, a &gt; 5) %&gt;% group_by(a,b) %&gt;% summarise(mean(c)) %&gt;% arrange(desc(b)) Konačno, ponovimo još jednom lako uočljivu sličnost gornjeg izraza sa SQL upitima u relacijskim bazama, uz bitnu razliku da ovdje operacije provodimo proceduralno što uvelike povećava čitljivost te da vrlo lako u bilo kojem trenutku možemo pohraniti i provjeriti međurezultat. Pokušajmo sada iskoristiti sva dosadašnja saznanja o paketu dplyr i riješiti sljedeće primjere. Svi zadaci vezani su uz cijeli podatkovni skup hflights. Zadatak 11.9 - složeni upiti # ispišite koliko je bilo otkazanih letova zbog # lošeg vremena u svakom mjesecu # tablica rezultata mora imati stupce # `Month` i `BadWeatherCancellations` # ispišite prosječno vrijeme kašnjenja u dolasku # kod odlaznih letova u zrakoplovne luke # LAX, JFK i LGA u različitim danima u tjednu # novi stupac nazovite &#39;MeanArrDelay&#39; # ignorirajte retke sa NA vrijednostima vremena kašnjenja # ispis poredajte po vremenu kašnjenja silazno # ispišite koliko je bilo otkazanih letova zbog # lošeg vremena u svakom mjesecu # tablica rezultata mora imati stupce # `Month` i `BadWeatherCancellations` filter(hflights, CancellationCode == &#39;B&#39;) %&gt;% group_by(Month) %&gt;% summarise(BadWeatherCancellations = n()) ## # A tibble: 12 × 2 ## Month BadWeatherCancellations ## &lt;int&gt; &lt;int&gt; ## 1 1 149 ## 2 2 929 ## 3 3 50 ## 4 4 40 ## 5 5 106 ## 6 6 49 ## 7 7 29 ## 8 8 108 ## 9 9 38 ## 10 10 46 ## 11 11 13 ## 12 12 95 # ispišite prosječno vrijeme kašnjenja u dolasku # kod odlaznih letova u zrakoplovne luke # LAX, JFK i LGA u različitim danima u tjednu # novi stupac nazovite &#39;MeanArrDelay&#39; # ignorirajte retke sa NA vrijednostima vremena kašnjenja # ispis poredajte po vremenu kašnjenja silazno filter(hflights, Dest %in% c(&#39;LAX&#39;, &#39;JFK&#39;, &#39;LGA&#39;)) %&gt;% group_by(DayOfWeek, Dest) %&gt;% summarise(MeanArrDelay = round(mean(ArrDelay, na.rm = T) , 2)) %&gt;% ungroup() %&gt;% arrange(desc(MeanArrDelay)) ## `summarise()` has grouped output by &#39;DayOfWeek&#39;. You can override ## using the `.groups` argument. ## # A tibble: 21 × 3 ## DayOfWeek Dest MeanArrDelay ## &lt;int&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 4 LGA 21.3 ## 2 4 JFK 17.2 ## 3 5 LGA 13.6 ## 4 1 LGA 13.5 ## 5 7 JFK 10.8 ## 6 1 LAX 10.7 ## 7 3 LGA 10.5 ## 8 4 LAX 10.3 ## 9 2 LGA 9.85 ## 10 6 JFK 9.76 ## # ℹ 11 more rows Zadatak 11.10 - složeni upiti (2) # u zadacima koji slijede zamislite da ste prvo napisali # &quot;vlastitu&quot; funkciju koja pronalazi najčešću kategoriju: mostFreqValue &lt;- function(x) table(x) %&gt;% sort(decreasing = T) %&gt;% names %&gt;% `[`(1) # u tablici `hflights` podijelite vrijeme kašnjenja # u dolasku u 10 kategorija uz pomoć funkcije `ntile` # novi stupac nazovite `ArrDelayCatId` # za svaku tu kategoriju ispišite identifikator # kategorije, ukupan broj letova unutar kategorije, # minimalno i maksimalno vrijeme kašnjenja u dolasku # te koja zrakoplovna luka se najčešće # pojavljuje u toj kategoriji # ponovite prethodni primjer ali umjesto funkcije # `ntile` isprobajte funkciju `cut` # u tablici `hflights` podijelite vrijeme kašnjenja # u dolasku u 10 kategorija uz pomoć funkcije `ntile` # novi stupac nazovite `ArrDelayCatId` # za svaku tu kategoriju ispišite identifikator # kategorije, ukupan broj letova unutar kategorije, # minimalno i maksimalno vrijeme kašnjenja u dolasku # te koja zrakoplovna luka se najčešće # pojavljuje u toj kategoriji mutate(hflights, ArrDelayCatId = ntile(ArrDelay, 10)) %&gt;% group_by(ArrDelayCatId) %&gt;% summarise(totalFlights = n(), minArrDelay = min(ArrDelay), maxArrDelay = max(ArrDelay), mostFreqDest = mostFreqValue(Dest)) ## # A tibble: 11 × 5 ## ArrDelayCatId totalFlights minArrDelay maxArrDelay mostFreqDest ## &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; ## 1 1 22388 -70 -14 ATL ## 2 2 22388 -14 -9 ATL ## 3 3 22388 -9 -6 DAL ## 4 4 22388 -6 -3 DAL ## 5 5 22387 -3 0 DAL ## 6 6 22387 0 3 DAL ## 7 7 22387 3 8 DAL ## 8 8 22387 8 15 DAL ## 9 9 22387 15 32 DAL ## 10 10 22387 32 978 DAL ## 11 NA 3622 NA NA DAL # ponovite prethodni primjer ali umjesto funkcije # `ntile` isprobajte funkciju `cut` mutate(hflights, ArrDelayCat = cut(ArrDelay, 10)) %&gt;% group_by(ArrDelayCat) %&gt;% summarise(totalFlights = n(), minArrDelay = min(ArrDelay), maxArrDelay = max(ArrDelay), mostFreqDest = mostFreqValue(Dest)) ## # A tibble: 11 × 5 ## ArrDelayCat totalFlights minArrDelay maxArrDelay mostFreqDest ## &lt;fct&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; ## 1 (-71,34.8] 203101 -70 34 DAL ## 2 (34.8,140] 18551 35 139 DAL ## 3 (140,244] 1849 140 244 ATL ## 4 (244,349] 294 245 346 ATL ## 5 (349,454] 48 350 450 ATL ## 6 (454,559] 16 458 556 ATL ## 7 (559,664] 4 579 663 DFW ## 8 (664,768] 4 685 766 DFW ## 9 (768,873] 4 775 861 DEN ## 10 (873,979] 3 918 978 DFW ## 11 &lt;NA&gt; 3622 NA NA DAL 12.7 Spajanje podatkovnih okvira uz join funkcije Spajanje podatkovnih okvira jest operacija poznata svim programerima koji imaju iskustvo u radu sa relacijskim bazama podataka i SQL-om. Kod pohrane u relacijsku bazu podataka tablice se često dekomponiraju u više tablica postupkom koji se naziva “normalizacija”. Svrha normalizacije je poglavito uklanjanje nepotrebne redundancije - svaka tablica zadržava dovoljno podataka kako bi se prema potrebi operacijom spajanja mogli rekonstruirati originalni podaci tj. skupovi obzervacija. Iako postoje različiti oblici spajanja tablica, daleko najčešće je tzv. “prirodno” spajanje kod koje u jednoj tablici imamo jedinstvene identifikatore vezane uz podatke koji se nalaze u drugoj tablici. Na primjer - zamislimo da imamo tablice Korisnik i Mjesto, gdje tablica korisnika sustava može imati stupac koji pohranjuje poštanski broj mjesta boravišta korisnika, dok se ostali podaci vezani uz mjesta nalaze u drugoj tablici. Pohraniti naziv mjesta u tablicu s korisnicima bilo bi redundantno, budući da poštanski broj kao takav jedinstveno identificira mjesto, a ukoliko želimo kod ispisa korisnika vidjeti i nazive mjesta, obavljamo operaciju prirodnog spajanja dvije tablice po poštanskom broju mjesta koje je tzv. “strani ključ” u tablici Korisnik a istovremeno i “primarni ključ” u tablici Mjesto. Stvorimo ovakve podatkovne okvire (sa tek nekoliko redaka kako bi koncept bio jasniji). # inicijalizacija podatkovnih okvira `korisnik` i `mjesto` korisnik &lt;- data.frame( id = c(1:3), prezime = c(&quot;Ivic&quot;, &quot;Peric&quot;, &quot;Anic&quot;), pbrBoravista = c(10000, 31000, 10000)) mjesto &lt;- data.frame( pbr = c(10000, 21000, 31000), naziv = c(&quot;Zagreb&quot;, &quot;Split&quot;, &quot;Osijek&quot;)) Ako bi htjeli imati okvir sa stupcima (id, prezime, pbrBoravista, naziv), moramo prirodno spojiti ova dva okvira. Paket dplyr za ovo nudi funkciju inner_join: inner_join(df1, df2, by=c(&quot;s1&quot; = &quot;s2&quot;)) gdje su df1 i df2 podatkovni okviri koje spajamo, a nizovi znakova “s1” i “s2” označavaju imena stupaca “lijevog” i “desnog” okvira prema kojima provodimo spajanje (uočite samo jedan znak jednakosti!). Ukoliko stupac kojeg koristimo ima isto ime u obje tablice možemo navesti samo ime tog stupca (ili znakovni vektor više stupaca ako spajamo preko tzv. “kompozitnog” stranog ključa), ili taj parametar potpuno ispustiti (ako su stupci prema kojima provodimo spajanje jedini stupci čiji se nazivi poklapaju). Zadatak 11.11 - prirodno spajanje # stvorite okvir `korisnikMjesto` koji će biti rezultat # prirodnog spajanja okvira `korisnik` i `mjesto` # ispišite okvir `korisnikMjesto` korisnikMjesto &lt;- inner_join(korisnik, mjesto, by = c(&quot;pbrBoravista&quot; = &quot;pbr&quot;)) korisnikMjesto ## id prezime pbrBoravista naziv ## 1 1 Ivic 10000 Zagreb ## 2 2 Peric 31000 Osijek ## 3 3 Anic 10000 Zagreb Vodite računa da je spajanje vrlo “skupa” operacija; ako spajate okvire sa vrlo velikim brojem redaka operacija bi mogla trajati vrlo dugo i zauzeti dosta memorije. U slučaju da često dolazi do potrebe za ovakvim “velikim” spajanjima, onda se snažno preporučuje korištenje paketa data.table koji implementira algoritme sa znatno boljim performansama kod operacija spajanja (korištenjem indeksiranja), ili - ukoliko radimo s podacima iz relacijske baze - provesti spajanja na strani baze podataka i onda u R povući rezultat, umjesto da se spajanje ostavlja na odgovornost R-u. U idućem poglavlju prikazati ćemo kako se ovo potencijalno može izvesti i bez potrebe za pisanjem zasebnih SQL naredbi. Ako pogledamo rezultat gornjeg primjera, možemo vidjeti da smo “izgubili” jedan redak tablice mjesto. Naime, redak (21000, ‘Split’) nije imao pripadajućeg korisnika te je “nestao” iz rezultata. Ovo je potpuno očekivani rezultat prirodnog spajanja, no postoje slučajevi kada želimo zadržati sve retke iz jedne od tablica koje spajamo. U tom slučaju koristimo tzv. “vanjsko spajanje” koje radi identično već viđenom, ali zadržava sve retke iz jedne ili obje od tablica na način da retci koji se ne uspiju spojiti ostaju u rezultatu, ali sa NA vrijednostima sa suprotne strane. Razlikujemo “lijevo”, “desno”, i “puno” vanjsko spajanje, u ovisnosti želimo li zadržati sve retke iz lijeve, desne ili obje tablice. Paket dplyr nudi funkcije koje obavljaju sve ove tipove spajanja, one imaju potpis identičan gore viđenoj funkciji a zovu se left_join, right_join i full_join. Zadatak 11.12 - vanjsko spajanje # stvorite okvir `korisnikMjesto2` koji će biti rezultat # prirodnog spajanja okvira `korisnik` i `mjesto` # ali će zadržati sve retke iz tablice &#39;mjesto` # ispišite okvir `korisnikMjesto2` # retke poredajte po identifikatoru korisnika korisnikMjesto2 &lt;- right_join(korisnik, mjesto, by = c(&quot;pbrBoravista&quot; = &quot;pbr&quot;)) korisnikMjesto2 %&gt;% arrange(id) ## id prezime pbrBoravista naziv ## 1 1 Ivic 10000 Zagreb ## 2 2 Peric 31000 Osijek ## 3 3 Anic 10000 Zagreb ## 4 NA &lt;NA&gt; 21000 Split 12.8 Integracija sa vanjskim izvorima podataka Do sada samo kao izvor podataka gotovo isključivo koristili “čiste” tekstualne datoteke kao što su datoteke CSV standarda. U praksi možemo očekivati vrlo heterogenu prirodu izvora podataka kojima ćemo se morati prilagoditi. Danas gotovo sav softver za upravljanje repozitorijima podataka neovisno o njihovoj implementaciji i modelu podataka nudi mogućnost izvoza podataka u CSV obliku, što nam predstavlja svojevrsni oblik univerzalnog integracijskog rješenja. Usprkos tome, nekad “direktno” priključivanje na izvore (bilo za uvoz ili izvoz podataka) predstavlja brže i praktičnije rješenje, tako da ima smisla proučiti programske strukture koje ovo omogućuju- U nastavku ćemo dati kratki pregled dva primjera češćih izvora podataka koje susrećemo u praksi - Excel datoteke te relacijske baze podataka. 12.8.1 Excel datoteka kao izvor (odredište) podataka Microsoft Excel iznimno je popularna aplikacija za upravljanje tabličnim podacima uz pomoć grafičkog sučelja koju danas mnoge tvrtke koriste u svakodnevnom poslovanju. Zato postoji velik interes za lakšom integracijom ove aplikacije (konkretnije, formata XLS koji koristi) i analitičkih alata kao što je programski jezik R. Nažalost, ova integracija u pravilu nije bila jednostavna zbog činjenice da je Microsoft Excel komercijalan softver s vlastitim, zatvorenim standardima koji često zahtijevaju predinstalaciju posebnih softverskih datoteka kako bi integracija bila omogućena. S obzirom na velik broj inačica paketa Microsoft Office čiji je Excel jedan od segmenata, nemogućnost integracije, nekonzistentnost ponašanja programskoga koda koji ju koristi te problemi prenosivosti koda dugo su vremena bili uobičajena pojava. Zbog ove činjenice i dalje je najprikladniji način komunikacije korištenje međurezultata u obliku nekog od otvorenih tekstualnih standarda, poglavito CSV datoteke. Paket readxl nudi alternativu ovom pristupu na način da omogućuje čitanje XLS i XLSX datoteka, a bez potrebe za prethodnom instalacijom dodatnoga softvera. Rad s ovim paketom jednostavan je. Učitamo paket readxl uz pomoć funkcije library, a potom korištenjem funkcije read_excel i imena XLS ili XLSX datoteke kao parametar učitamo podatke koji se automatski prevode u podatkovni okvir, konkretnije u tibble. Pokušajmo ovo izvesti i učitati podatke iz datoteke ExcelSampleData.xslx. Zadatak 11.13 - Funkcija read_excel # učitajte datoteku `datasets/ExcelSampleData.xslx` u varijablu `sampleData` # proučite podatkovni okvir `ExcelSampleData` # učitajte datoteku `datasets/ExcelSampleData.xslx` u varijablu `sampleData` library(readxl) sampleData &lt;- read_excel(&quot;datasets/ExcelSampleData.xlsx&quot;) # proučite podatkovni okvir `ExcelSampleData` glimpse(sampleData) ## Rows: 43 ## Columns: 7 ## $ OrderDate &lt;dttm&gt; 2014-09-01, 2015-06-17, 2015-09-10, 2015-11-17, 2015-10-3… ## $ Region &lt;chr&gt; &quot;Central&quot;, &quot;Central&quot;, &quot;Central&quot;, &quot;Central&quot;, &quot;Central&quot;, &quot;Ce… ## $ Rep &lt;chr&gt; &quot;Smith&quot;, &quot;Kivell&quot;, &quot;Gill&quot;, &quot;Jardine&quot;, &quot;Andrews&quot;, &quot;Gill&quot;, &quot;… ## $ Item &lt;chr&gt; &quot;Desk&quot;, &quot;Desk&quot;, &quot;Pencil&quot;, &quot;Binder&quot;, &quot;Pencil&quot;, &quot;Pen&quot;, &quot;Bind… ## $ Units &lt;dbl&gt; 2, 5, 7, 11, 14, 27, 28, 28, 36, 42, 46, 50, 50, 53, 55, 6… ## $ `Unit Cost` &lt;dbl&gt; 125.00, 125.00, 1.29, 4.99, 1.29, 19.99, 8.99, 4.99, 4.99,… ## $ Total &lt;dbl&gt; 250.00, 625.00, 9.03, 54.89, 18.06, 539.73, 251.72, 139.72… Sada smo slobodni dalje nastaviti rad s podacima neopterećeni činjenicom da je originalni izvor podataka bila Excel datoteka. Paket readxl primarno je namijenjen čitanju Excel datoteka. Ako rezultate želimo spremiti u XLSX datoteku, za to postoji niz paketa koji manje ili više uspješno obavljaju ovu zadaću. Jedan od njih je writexl i njegova funkcija write_xlsx kojoj dajemo podatkovni okvir te stazu (path) gdje želimo spremiti datoteku. Pripazite – usprkos sličnosti u imenima, paket writexl nema veze s paketom readxl, nisu ga radili isti autori niti je (u trenutku pisanja ovog udžbenika) dio paketa kolekcije tidyverse. Zadatak 11.14 - Funkcija write_xlsx # u varijablu `filteredData` ubacite prvih pet redaka i prva tri stupca # iz varijable `sampleData` # spremite podatke iz `filteredData` u datoteku `datasets/FilteredExcel.xlsx` # u varijablu `filteredData` ubacite prvih pet redaka i prva tri stupca # iz varijable `sampleData` library(writexl) filteredData &lt;- sampleData[1:5, 1:3] # spremite podatke iz `filteredData` u datoteku `datasets/FilteredExcel.xlsx` write_xlsx(filteredData, path = &quot;datasets/FilteredExcel.xlsx&quot;) Zbog već spomenute činjenice da je Microsoft Excel komercijalan softver s vlastitim standardima te nizom dostupnih inačica, razvoj programskih skripti koje se direktno naslanjaju na XLS i XLSX datoteke uvijek će imati izvjesnu dozu rizika u pogledu nestabilnosti i prenosivosti. Proces koji koristi CSV “međurezultate” jest nešto manje praktičan, no dugoročno puno lakše održiv, pogotovo jer se gotovo u potpunosti uklanja ovisnost o paketima, dodatnom softveru te inačicama Excela i R-a. 12.8.2 Rad sa relacijskim bazama Relacijske baze česti su izvor podataka za analize koje radimo u jeziku R. Jedna od standardnih procedura pripreme podataka za analitički proces je tzv. “izvoženje” (engl. export) podataka iz baze u CSV datoteku, koja se potom učitava u R. Često se prije stvaranja CSV datoteke prvo podaci iz baze moraju prikupiti i pripremiti na adekvatan način, što znači da cjelokupni proces pripreme podataka incijalno zahtjeva rad u SQL-u nad bazom podataka. Ovo je pogotovo bitno ako radimo sa većim skupovima podataka koji bi nepotrebno opteretili stroj nad kojim radimo analize u R-u, a koji bi se mogli znatno učinkovitije i brže mogli obraditi u bazi podataka. Gore navedeno ne znači nužno da nam za prikupljanje podataka iz baze treba zaseban alat pomoću kojeg ćemo izvoditi SQL upite. R sadrži niz paketa za direktno spajanje i rad sa popularnijim bazama podataka, kao što su npr. MySQL ili PostgreSQL. Uz pomoć ovih paketa možemo unutar R skripte uspostaviti konekciju sa bazom i izvoditi SQL upite, a sve uz pomoć R naredbi pri čemu kao konačni rezultat dobivamo podatkovni okvir spreman za daljnje korake analize. Npr. rad direktno nad PostgreSQL bazom može izgledati ovako: install.packages(&quot;RPostgreSQL&quot;) library(RPostgreSQL) # unijeti stvarne parametre kod realnog scenarija! dsn_database &lt;- &quot;&lt;database name&gt;&quot; # Naziv tj. URL relacijske baze podataka dsn_hostname &lt;- &quot;&lt;your host name&gt;&quot; # Ime računala gdje se nalazi baza dsn_port &lt;- &quot;&lt;port&gt;&quot; # Broj ulaza, npr. 98939 dsn_uid &lt;- &quot;&lt;your user id&gt;&quot; # Korisničko ime, npr. &quot;admin&quot; dsn_pwd &lt;- &quot;&lt;your password&gt;&quot; # Lozinka, npr. &quot;xxx&quot; tryCatch({ drv &lt;- dbDriver(&quot;PostgreSQL&quot;) print(&quot;Spajam se na bazu…&quot;) conn &lt;- dbConnect(drv, dbname = dsn_database, host = dsn_hostname, port = dsn_port, user = dsn_uid, password = dsn_pwd) print(&quot;Spajanje uspješno!&quot;) }, error=function(cond) { print(&quot;Ne mogu se spojiti na bazu.&quot;) }) df = dbSendQuery(conn, &quot;SELECT * FROM MY_TABLE&quot;) Vidimo da prvo moramo učitati paket s podrškom za spajanje na odabranu bazu, potom uspostavljamo konekciju sa bazom (parametre nam obično daje administrator same baze), a onda uz pomoć odgovarajućih funkcija postavljamo SQL upite). Iako ovakav pristup nije kompliciran i relativno se često koristi, on neumitno zahtijeva miješanje programskog koda u SQL-u i programskog koda u R-u. Paket dplyr može ovdje pomoći na način da rastereti programera od potrebe pisanja SQL upita unutar R skripte. Naime, dplyr sadrži integriranu podršku za automatsku konverziju izraza koji koriste dplyr funkcije direktno u SQL upit, a što je transparentno za korisnika. Drugim riječima, do izvjesne mjere možemo na isti način raditi nad relacijskom bazom podataka kao da se radi o podatkovnim okvirima u memoriji računala. Ovdje trebamo biti oprezni jer ne možemo očekivati da će nam sve funkcionalnosti dplyr-a moći biti automatski prevedene u SQL, ali neke standardne pripremne operacije poput spajanje i filtriranja se na ovaj način mogu raditi direktno u bazi, a kroz čisti R programski kod. Kako bi mogli ovo isprobati u praksi, potrebna nam je relacijska baza podataka. Budući da nije praktično u ovom trenutku instalirati ili pripremati postojeću relacijsku bazu podataka samo za potrebe nekolicine primjera, učinit ćemo ono što radi većina R programera kada želi razvijati programski kod vezan uz relacijske baze, ali izbjeći potrebu za pristupom konkretnoj bazi podataka - koristiti ćemo se tzv. SQLite bazom. Ovo je jednostavna baza koja ne zahtijeva posebnu instalaciju, ne koristi poslužitelj i sve podatke drži u jednoj datoteci. U sljedećem programskom odsječku učitavamo paket RSQLite, stvaramo novu bazu kreiranjem nove datoteke (ili se spajamo na postojeću ako datoteka ne postoji) te spremamo okvir mtcars u tablicu AUTI što će nam glumiti “podatke u bazi”. # instalacija i učitavanje paketa `RSQLite` (izvesti ako je potrebno) #install.packages(&quot;RSQLite&quot;) #library(RSQLite) # otvaramo konekciju sa bazom &quot;SQLite&quot; # (zapravo stvaramo datoteku &#39;moja.baza&#39;) conn &lt;- dbConnect(drv=SQLite(), dbname=&quot;moja.baza&quot;) # stvaramo tablicu `AUTI` u koju pohranjujemo # prvih 100 redaka tablice `mtcars` # ovo simulira &quot;tablicu u bazi&quot; dbWriteTable(conn, &quot;AUTI&quot;, mtcars[1:100,], overwrite = T) # provjeramo popis svih tablica dbListTables(conn) ## [1] &quot;AUTI&quot; Uobičajeni način prikupljanja podataka iz baze jest ugradnja SQL upita direktno u R programski kod i pohrana rezultata u varijablu. # ispisujemo podatke o maksimalnoj brzini i težini svih automobila sa 6 cilindara dbGetQuery(conn, &quot;SELECT mpg, wt FROM AUTI WHERE cyl = 6&quot;) ## mpg wt ## 1 21.0 2.620 ## 2 21.0 2.875 ## 3 21.4 3.215 ## 4 18.1 3.460 ## 5 19.2 3.440 ## 6 17.8 3.440 ## 7 19.7 2.770 Ako dobro poznajemo SQL, onda ovakav način prikupljanja podataka vjerojatno ne izgleda pretjerano kompleksno i uistinu, veliki broj programera i analitičara rado kombinira SQL i R kako bi optimizirali proces prikupljanja i pripreme podataka. No ako nismo “jaki” u SQL-u, ili jednostavno želimo “čistiji” kod, možemo se koristiti alatima koje nam nudi paket dplyr. U idućem primjeru ponoviti ćemo dio gore prikazanog postupka (spojiti ćemo se na SQLite bazu nazvanu moja.baza i ispisati podatke iz tablice AUTI), ali ćemo sve izvesti uz pomoć dplyr funkcija. # povezujem se sa postojećom SQLite bazom conn2 &lt;- dbConnect(drv=SQLite(), dbname=&quot;datasets/12/moja.baza&quot;) # pogledajmo da li je tablica AUTI u bazi dbListTables(conn2) # stvaram referencu na ovu tablicu # (ništa se ne učitava dok ne pristupam podacima!) auti &lt;- src_sqlite(conn2, &quot;AUTI&quot;) # ispisujemo podatke o maksimalnoj brzini i težini svih automobila sa 6 cilindara auti %&gt;% filter(cyl == 6) %&gt;% select(mpg, wt) %&gt;% collect ## [1] &quot;AUTI&quot; ## # A tibble: 7 × 2 ## mpg wt ## &lt;dbl&gt; &lt;dbl&gt; ## 1 21 2.62 ## 2 21 2.88 ## 3 21.4 3.22 ## 4 18.1 3.46 ## 5 19.2 3.44 ## 6 17.8 3.44 ## 7 19.7 2.77 Ključno je znati da dplyr neće ništa izvoditi do trenutka kada mi eksplicitno zatražimo tražene podatke, a i tada će ih dohvaćati “u porcijama” kako nam ne bi zagušio memoriju. Upravo zbog toga smo u gornjem primjeru koristili funkciju collect, koja zapravo znači “dohvati cijeli rezultat i pohrani ga u podatkovni okvir” (u našem slučaju mi smo ga jednostavno ispisali na zaslon). Na ovaj način R programer može znatno rasteretiti svoju R okolinu prebacujući odgovornost “teških” proračuna na bazu podataka, a sve uz korištenje istih funkcija koje koristi za upravljanje podatkovnim skupovima pohranjenim u memoriji računala u obliku podatkovnih okvira. Zadaci za vježbu U zadacima za vježbu poslužiti ćemo se proširenom podatkovnim skupom mammals sleep dostupnim u vizualizacijskom paketu ggplot2. Učitajte paket ggplot2 te potom prenesite podatkovni okvir msleep u globalnu okolinu uz pomoć funkcije data. Prije rješavanja učitajte podatkovni skup i upoznajte se s njim uz pomoć uobičajenih funkcija. Za 10 biljojeda koji najdulje spavaju ispišite ime, koliko dnevno spavaju i prosječnu tjelesnu, težinu u kg. Ispis poredajte po duljini spavanja silazno. Ispišite prosječno, najdulje i najkraće vrijeme spavanja životinja ovisno o njihovom tipu prehrane. Podijelite ukupno vrijeme spavanja u 5 razreda jednoliko po ukupnoj duljini dnevnog spavanja. Za svaki razred ispišite ukupan broj životinja koje pripadaju razredu, a potom posebno ukupan broj pripadnika razreda koji nisu biljojedi. Ispis poredajte od razreda životinja koje najmanje spavaju naviše. Stupce nazovite smisleno i pripazite da konačna tablica nema NA vrijednosti. Sljedeći okvir sadrži šifre statusa očuvanja životinja i njihove opise: conservationStatus &lt;- data.frame( code = c(&quot;ex&quot;, &quot;ew&quot;, &quot;cr&quot;, &quot;en&quot;, &quot;vu&quot;, &quot;nt&quot;, &quot;cd&quot;, &quot;lc&quot;), description = c(&quot;extinct&quot;, &quot;extinct in the wild&quot;, &quot;critically endangered&quot;, &quot;endangered&quot;, &quot;vulnerable&quot;, &quot;near threatened&quot;, &quot;conservation dependent&quot;, &quot;least concern&quot;)) Dodajte okviru msleep stupac conservationDesc koji će sadržavati pripadajuće opise preuzete iz gornjeg okvira. Pripazite da kod proširenja ne izgubite nijedan redak iz okvira msleep. Programirajmo u R-u by Damir Pintar is licensed under a Creative Commons Attribution-NonCommercial-NoDerivatives 4.0 International License.Based on a work at https://ratnip.github.io/FER_OPJR/ "],["ggplot2.html", "13 Vizualizacija podataka uz paket ggplot2 13.1 Eksploratorna analiza podataka 13.2 Vizualizacija podataka uz pomoć jezika R 13.3 Grafička gramatika i paket ggplot2 13.4 Grafovi u eksploratornoj analizi i izvještavanju Zadaci za vježbu", " 13 Vizualizacija podataka uz paket ggplot2 13.1 Eksploratorna analiza podataka Eksploratorna analiza podataka (engl. EDA - exploratory data analysis) proces je analize podatkovnog skupa s ciljem upoznavanja s podacima i donošenjem određenih zaključaka. Knjiga R for Data Science (čiji je koautor Hadley Wickham, autor megapopularnih R paketa kao što su stringr, lubridate, plyr, dplyr i sl.)) navodi da se eksploratorna analiza u principu sastoji od tri dijela: prilagodba podataka (engl. data wrangling) vizualizacija podataka izrada modela pri čemu ovo nije slijedni proces već cirkularni, a faze se često međusobno prožimaju. Bitno je naglasiti da eksploratorna analiza nije proces koji se može automatizirati niti pasivno provoditi; analitičar nije tek promatrač podataka, već ima aktivnu ulogu u procesu. Inicijator cijelog procesa analize upravo su pitanja o podacima koje analitičar uočava i zadaje, a na koje odgovor može dati eksploratorna analiza; pitanja mogu biti raznolika, sažeta ili kompleksna, općenita ili specifična, a vrlo često zahtijevaju visoku razinu kreativnosti i znatiželje od strane analitičara. Ukoliko bismo pokušali dati općeniti predložak o kakvim pitanjima se radi, mogli bi doći do zaključka da su to pitanja: kako se ponaša neka varijabla? Na koji način se mijenja? Koji su odnosi između dvije ili više varijabli? Može li izmjena jedne varijable objasniti izmjenu neke druge varijable? i sl. Prilagodbu podataka već smo djelomice upoznali učenjem osnovnog R-a te paketa tidyr i dplyr, a u ovoj lekciji upoznat ćemo ono što mnogi smatraju okosnicom eksploratorne analize - vizualizaciju podataka. Treća spomenuta faza procesa - izrada modela - tiče se stvaranja sažetih reprezentacija podataka u obliku matematičkih (ili drugih) modela, a koji opisuju odnose i ponašanje varijabli na koristan i/ili lako interpretabilan način (npr. uočavanje linearne ovisnosti između dvije varijable što se može opisati jednostavnom matematičkom jednadžbom). Modeliranjem ćemo se baviti u jednoj od nastupajućih lekcija. 13.2 Vizualizacija podataka uz pomoć jezika R Jedna od često spominjanih karakteristika jezika R su njegove vrhunske funkcionalnosti vezane uz vizualizaciju podataka. Postoji veliki broj analitičara i programera koji R koriste isključivo kao vizualizacijski alat budući da na vrlo brz i jednostavan način mogu proizvesti profesionalne, atraktivne i lako interpretabilne grafove. Osnovni jezik R sam po sebi sadrži vrlo dobru podršku za stvaranje grafova (tzv. base plot sustav), no prava moć vizualizacije krije se u brojnim dodatnim paketima koji su danas dostupni preko CRAN repozitorija. Osnovna podrška za stvaranje grafova ostvaruje se uz pomoć generičke funkcije plot a njena velika prednost je iznimna jednostavnost. Gotovo svaka popularnija klasa ima vlastitu implementaciju ove funkcije, što znači da je za “brzu” vizualizaciju često dovoljno samo proslijediti željeni objekt (ili objekte) navedenoj funkciji. Npr. ako funkciji proslijedimo dva numerička vektora jednake veličine, funkcija plot će automatski stvoriti graf sa prvim vektorom mapiranim na x-os a drugim na y-os (prikazane uz pomoć linearne kontinuirane skale). Funkcija će također automatski dodati prikladne anotacije kao što su linije za osi, oznake na osima (engl. tickmarks) i pripadajuće vrijednosti, nazive osi i sl. Zadatak 13.1 - funkcija ‘plot’ x &lt;- 1:50 # proslijedite `x` i `x*x` funkciji `plot` plot(x, x*x) Osnovna podrška je funkcionalna i jednostavna, ali ograničena. Na stvoreni graf se mogu dodavati nove stvari, ali ne i modificirati. Isto tako, fino podešavanje pojedinih aspekata grafa često pozive čini glomaznim i nečitljivim te se gubi dimenzija jednostavnosti (koja je glavni razlog korištenja funkcije plot). Neki od popularnih paketa za vizualizaciju su grid i lattice. Paket grid nudi bogatiji skup funkcija za stvaranje vizualizacija od onih dostupnih unutar osnovne podrške, ali nema mogućnosti izračuna statistika vezanih uz samu vizualizaciju te je to često potrebno obaviti “ručno” prije pozivanja vizualizacijskih funkcija. Paket lattice je posebno popularan za stvaranje tzv. “uvjetnih” ili “facetiranih” grafova (engl. facet - aspekt, značajka), što znači veći broj grafova istog tipa gdje svaki odgovara pojedinoj vrijednosti neke značajke (npr. usporedba nekih veličina u nekoj populaciji ovisno o spolu ili dobi). Paket lattice također ima podršku za automatsko stvaranje legendi i sl. što se kod drugih paketa često mora raditi ručno. Potencijalni problem ovog paketa jest činjenica da nije zasnovan ni na kakvom formalnom modelu, tako da ga je teško proširivati dodatnim funkcionalnostima. Postoji još popularnih paketa, bilo namijenjenih općenitom stvaranju vizualizacija ili nekim specifičnim primjenama, no za kraj ćemo spomenuti jedan od danas najpopularnijih vizualizacijskih paketa jezika R - paket ggplot2. Autor ovog paketa je već spominjani Hadley Wickham, a zasnovan je na tzv. “grafičkoj gramatici” (zato se i zove ggplot2, gdje dvojka zapravo dolazi od činjenice da je to paket za crtanje dvodimenzionalnih vizualizacija). Popularnost ovog paketa krije se u tome da pokušava objediniti prednosti osnovne podrške za crtanje grafova kao i paketa lattice ali na temelju formalnog, jasno definiranog modela. Prednost ovog pristupa jest ta što omogućuje stvaranje širokog spektra vizualizacija na osnovu koncizne, jasne i sažete sintakse te omogućuje lako proširenje dodatnim funkcionalnostima. Potencijalni problem jest nešto strmija inicijalna krivulja učenja budući da je potrebno prvo usvojiti “logiku” stvaranja grafa, tj. osnovne principe navedene “grafičke gramatike”. No jednom kada se premosti ova početna prepreka, stvaranje kvalitetnih vizualizacija jest brzo, lako i učinkovito, što dokazuje i činjenica da je ggplot2 danas jedan od najpopularnijih paketa za vizualizaciju podataka koji je izišao iz granica jezika R te se reimplementira i u drugim programskim jezicima za analizu podataka (npr. paket ggplot u jeziku Python, paket gramm u Matlab-u). Zbog svega gore navedenog, mi ćemo se u nastavku usredotočiti upravo na paket ggplot2 kao jedan od najpopularnijih i najprimjenjivijih vizualizacijskih paketa jezika R. 13.3 Grafička gramatika i paket ggplot2 Grafička gramatika (engl. grammar of graphics) nam daje sljedeće: principe koji omogućuju stvaranje i interpretaciju kompleksnih vizualizacija naputke što predstavlja “dobro oblikovanu” ili “kvalitetnu” vizualizaciju Kao što jezična gramatika omogućuje oblikovanje “kvalitetnih” rečenica, tako i grafička gramatika zapravo grafove gleda kao svojevrsne “rečenice” čije razumijevanje ovisi o tome kako pojedine komponente uklopiti u jasnu, razumljivu cjelinu. No, također kao kod jezične gramatike, rečenica može biti gramatički ispravna ali i dalje besmislena - drugim riječima, gramatika je temelj za kvalitetu, ali ne i garancija iste; smislenost i svrhovitost konačnog rezultata i dalje ovisi o kreativnosti i sposobnosti stvoritelja rečenice, tj. vizualizacije. Kako bi olakšali učenje grafičke gramatike, što realno predstavlja najveću prepreku svladavanju paketa ggplot2, važno je da se pridržavamo osnovnog principa kojeg možemo parafrazirati ovako - kvalitetna vizualizacija je zapravo kompozicija niza sastavnica od kojih svaka ima jasno definiranu ulogu. Shodno tome, graf ne bismo trebali gledati kao jednu kompaktnu cjelinu, već trebamo pokušati identificirati pojedine dijelove i naučiti na koji način oni doprinose konačnoj vizualizaciji. Navedeni dijelovi nisu nužno vizualne komponente grafa, tj. dijelovi koji sačinjavaju grafiku koju gledamo, već gradivni elementi koje vizualizacijski sustav koristi kako bi stvorio konačni rezultat. 13.3.1 Aspekti podataka, estetike i geometrije Za početak uvedimo pojednostavljeni model gramatike od tri komponente: podaci (koje želimo vizualizirati) estetike (mapiranje podataka na elemente grafa) geometrije (grafička reprezentacija podataka na grafu) Podaci su, naravno, ključna komponenta grafa. Oni predstavljaju ono što želimo prikazati grafom. Isto tako, oni su relativno neovisni od ostalih komponenti vizualizacije - iste principe vizualizacije možemo primijeniti nad različitim podatkovnim skupovima. No usprkos tome, stvaranje novog grafa najčešće počinje sa odabirom podatkovnog skupa, čije značajke diktiraju daljnje korake procesa vizualizacije. Estetike (engl. aesthetics) zapravo nemaju veze sa doslovnom interpretacijom “znanosti o lijepom”, već se zapravo radi o odabiru načina kako određene segmente podatkovnog skupa prikazati na grafu. Naime da bi vizualizacija podatka imala smisla, mi taj podatak moramo prikazati na vizualno interpretabilan način. Uobičajen princip jest prikaz uz pomoć položaja na dvodimenzionalnoj ravnini uz pomoć kartezijevog koordinatnog sustava koji ravninu ortogonalno segmentira uz pomoć dvije osi, nazvane x i y, koje predstavljaju dvije “osnovne estetike”. One nisu jedine - estetike su također i boja, oblik, uzorak i sl. Jedan od načina lakšeg razumijevanja što je zapravo estetika može biti i “ono što se često objašnjava legendom uz graf”; ako je estetika zapravo mapiranje na vizualnu komponentu grafa, legenda grafa je njezin inverz - objašnjenje što koja komponenta zapravo znači. Konačno, geometrija zapravo predstavlja opis kako konkretno nacrtati ono što želimo vizualizirati. Na primjer, ako smo mapirali neke stupce na x i y os, onda bi se pojedina obzervacija mogla prikazati točkom, što je tzv. point geometry. Mogli smo se isto tako odlučiti na linijsku geometriju (line geometry) i iste podatke prikazati linijom koja povezuje obzervacije. Geometrija je zapravo ono što kolokvijalno zovemo “tip grafa”, tj. crtamo tzv. “točkaste grafove” (engl. scatterplot), linijske grafove, stupčaste grafove, pite, histograme i sl. - a sve se to svodi na dodavanje odgovarajuće “geometrije” ggplot grafu. Svaka geometrija ima svoje parametre koji mogu biti opisani fiksno ili biti ovisni o podacima - npr. točka ima svojstva položaja (x i y koordinate), boje i oblika; točke na grafu možemo npr. prikazati kružićem, iksićem ili nekim drugim simbolom, a možemo ih povezati i s nekom estetikom tako da će npr. oblik točke ovisiti o vrijednosti neke kategorijske varijable. Geometrije se mogu “slagati” jedna na drugu tako da isti graf zapravo može biti kombinacija točkastog i linijskog grafa i sl. Prikažimo ovo sve na primjeru. Za prve primjere koristit ćemo se podatkovnim skupom mtcars kojeg smo dobili s osnovnom distribucijom jezika R unutar paketa datasets. Učitajmo taj podatkovni skup u globalnu okolinu uz pomoć funkcije data. Zadatak 13.2 - upoznavanje sa podatkovnim skupom ‘mtcars’ # učitajte podatkovni okvir `mtcars` u globalnu okolinu # proučite okvir `mtcars` (head, glimpse, ?...) # učitajte podatkovni okvir `mtcars` u globalnu okolinu data(mtcars) # proučite okvir `mtcars` (head, glimpse, ?...) glimpse(mtcars) head(mtcars) ## Rows: 32 ## Columns: 11 ## $ mpg &lt;dbl&gt; 21.0, 21.0, 22.8, 21.4, 18.7, 18.1, 14.3, 24.4, 22.8, 19.2, 17.8,… ## $ cyl &lt;dbl&gt; 6, 6, 4, 6, 8, 6, 8, 4, 4, 6, 6, 8, 8, 8, 8, 8, 8, 4, 4, 4, 4, 8,… ## $ disp &lt;dbl&gt; 160.0, 160.0, 108.0, 258.0, 360.0, 225.0, 360.0, 146.7, 140.8, 16… ## $ hp &lt;dbl&gt; 110, 110, 93, 110, 175, 105, 245, 62, 95, 123, 123, 180, 180, 180… ## $ drat &lt;dbl&gt; 3.90, 3.90, 3.85, 3.08, 3.15, 2.76, 3.21, 3.69, 3.92, 3.92, 3.92,… ## $ wt &lt;dbl&gt; 2.620, 2.875, 2.320, 3.215, 3.440, 3.460, 3.570, 3.190, 3.150, 3.… ## $ qsec &lt;dbl&gt; 16.46, 17.02, 18.61, 19.44, 17.02, 20.22, 15.84, 20.00, 22.90, 18… ## $ vs &lt;dbl&gt; 0, 0, 1, 1, 0, 1, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0,… ## $ am &lt;dbl&gt; 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0,… ## $ gear &lt;dbl&gt; 4, 4, 4, 3, 3, 3, 3, 4, 4, 4, 4, 3, 3, 3, 3, 3, 3, 4, 4, 4, 3, 3,… ## $ carb &lt;dbl&gt; 4, 4, 1, 1, 2, 1, 4, 2, 2, 4, 4, 3, 3, 3, 4, 4, 4, 1, 2, 1, 1, 2,… ## mpg cyl disp hp drat wt qsec vs am gear carb ## Mazda RX4 21.0 6 160 110 3.90 2.620 16.46 0 1 4 4 ## Mazda RX4 Wag 21.0 6 160 110 3.90 2.875 17.02 0 1 4 4 ## Datsun 710 22.8 4 108 93 3.85 2.320 18.61 1 1 4 1 ## Hornet 4 Drive 21.4 6 258 110 3.08 3.215 19.44 1 0 3 1 ## Hornet Sportabout 18.7 8 360 175 3.15 3.440 17.02 0 0 3 2 ## Valiant 18.1 6 225 105 2.76 3.460 20.22 1 0 3 1 Vidimo da ovi podaci opisuju karakteristike 32 (stara) automobila kao što su: težina, maksimalna brzina, broj konjskih snaga, broj cilindara i sl. Budući da su neke od varijabli ovog skupa podataka trenutno numeričke, a zapravo bi im više odgovarao kategorijski tip, možemo prije nastavka provesti kategorizaciju tih varijabli. Usput možemo iskoristiti ovu priliku i prikazati parametar labels koji omogućuje “preimenovanje” kategorija (prema numeričkom ili abecednom rasporedu inicijalnih kategorija). mtcars$vs &lt;- factor(mtcars$vs, labels = c(&quot;V&quot;, &quot;S&quot;)) mtcars$am &lt;- factor(mtcars$am, labels = c(&quot;automatic&quot;, &quot;manual&quot;)) mtcars$cyl &lt;- factor(mtcars$cyl) mtcars$gear &lt;- factor(mtcars$gear) mtcars$carb &lt;- factor(mtcars$carb) Kada stvaramo ggplot2 vizualizaciju onda često pomaže da razmišljamo o “slojevima” grafa. Svaki sloj na neki način “prekriva” graf poput prozirne folije, što nam omogućuje postavljanje više različitih tipova reprezentacije podataka na isti graf (npr. prikazujemo točke ali ih i povežemo linijom). Recimo da nas zanima kako se odnose težina automobila i njegova maksimalna brzina. Intuitivni način vizualizacije bio bi: težina automobila (wt) na x os grafa potrošnja (mpg) na y os grafa Pogledajmo kako ovo izvesti uz pomoć ggplot2 vizualizacije. Uočimo da ćemo za početak namjerno koristiti “opširan” način stvaranja grafa - ovakav način se gotovo nikad ne koristi u praksi budući da postoji puno podesniji, sažeti način poziva metode, no na ovaj način lako ćemo uočiti pojedine bitne elemente izgradnje grafa. Stvorimo tzv. “točkasti” graf (engl. scatterplot) koji pokazuje odnos težine i maksimalne brzine automobila opisanih tablicom mtcars. 13.3.1.1 Prvi ggplot2 graf ggplot() + layer( data = mtcars, # 1. podaci mapping = aes(x = wt, y = mpg), # 2. mapiranja / estetike geom = &quot;point&quot;, # 3. geometrija stat = &quot;identity&quot;, # za sada zanemariti position = &quot;identity&quot;) # za sada zanemariti Osnovna funkcija za izgradnju jest funkcija ggplot. Ona zapravo inicijalizira objekt klase ggplot. Naime, za ggplot2 vizualizacije specifično je da su grafovi zapravo objekti, a ono što inače smatramo grafom je samo njihova vizualna reprezentacija. Ovdje zapravo leži moć ovakvog tipa reprezentacija - graf je nešto što možemo po volji mijenjati, preoblikovati, proširivati i pohranjivati, a vizualizacija predstavlja konačni nusproizvod upravljanja tim objektom. Ovakvom objektu potom dodajemo “slojeve” uz pomoć funkcije layer. Sloj objektu dodajemo uz pomoć operatora +, što predstavlja intuitivan prikaz i olakšava rad sa ovakvim tipom grafova. Sloj kao takav ima one gramatičke aspekte o kojima smo ranije govorili - podatke, estetike i geometrije. U pozivu vidimo još dva aspekta grafičke gramatike - statistike i poziciju - koje ćemo objasniti kasnije. Dovoljno je napomenuti da \"identity\" zapravo znači “ostavi onako kakvo jest”, tj. radi se o nekoj dodatnoj obradi unutar procesa vizualizacije koju za sada zanemarujemo, tj. ne koristimo. Iako formalno svaki sloj ima svoje gramatičke aspekte, gotovo uvijek postoje aspekti koji su zajednički svim slojevima (npr. vrlo često jedan graf prikazuje jedan podatkovni skup a svi slojevi “dijele” x i y os). Ukoliko imamo ovakve zajedničke aspekte onda ih možemo definirati odmah kod stvaranja objekta ggplot koji onda postaju “default-ni” parametri slojeva koje dodajemo (iako oni uvijek imaju opciju “gaženja” tih parametara svojim aspektima). Isto tako, za stvaranje dodatnih slojeva često se koristimo pomoćnim funkcijama intuitivnog imena koje imaju unaprijed podešene najčešće korištene parametre kako ih ne bismo morali stalno ponovo upisivati. Tako npr. funkcija geom_point dodaje sloj koji nasljeđuje već definirane aspekte a kao geometriju koristi točke. Pogledajmo sljedeći primjer koji koristi “skraćeni” način stvaranja navedenog grafa: # prvi `ggplot2` graf, skraćeni način izgradnje grafa ggplot(mtcars, aes(x = wt, y = mpg)) + geom_point() Postoji još jedan “pojednostavljeni” način stvaranja ggplot grafova, a to je uz pomoć funkcije qplot (od “*quick plot”). Ova funkcija zapravo je omotač koji omogućuje da ggplot grafove stvaramo sintaksom vrlo sličnom sintaksi funkcije plot. # prvi `ggplot2` graf, funkcija `qplot` qplot(x = wt, y = mpg, data = mtcars) ## Warning: `qplot()` was deprecated in ggplot2 3.4.0. ## This warning is displayed once every 8 hours. ## Call `lifecycle::last_lifecycle_warnings()` to see where this ## warning was generated. Glavni razlog postojanja ove funkcije jest orijentiranost korisnicima koji traže brzu i učinkovitu alternativu plot funkciji bez potrebe za učenjem novih koncepata. Iako se možda ovakav način stvaranja grafova možda čini zgodan i jednostavan, dugoročno se ipak isplati naučiti “pravu” ggplot2 sintaksu budući da je qplot funkcija dosta limitirana i - poput funkcije plot - inicijalna jednostavnost se sve više gubi što više prilagodbi vizualizacije želimo provesti. Vratimo se sada na naš graf - što ako želimo na njemu prikazati dodatni stupac tj. varijablu? Npr. možemo vidjeti da svi auti imaju 4, 6 ili 8 cilindara. No graf koji imamo je dvodimenzionalan - kako dodati “treću dimenziju”? Odgovor je - koristimo neku dosad neiskorištenu estetiku, npr. boju, veličinu ili oblik točaka. Zadatak 13.3 - Estetika oblika # stvorite `ggplot` graf skupa `mtcars` sa mapiranjima: x = wt, y = mpg, shape = cyl # koristite geometriju točke # što se događa ako koristimo &quot;numeričku&quot; inačicu varijable `cyl` (`as.numeric(cyl)`) ggplot(mtcars, aes(x = wt, y = mpg, shape = cyl)) + geom_point() Zadatak 13.4 - Estetika boje # ponovite isti graf, ali umjesto estetike `shape` koristite estetiku `color` ggplot(mtcars, aes(x = wt, y = mpg, color = cyl)) + geom_point() Zadatak 13.5 - Kombiniranje estetika # ponovite isti graf, ali sada za `cyl` stupac kombinirajte i `shape` i `color` estetiku ggplot(mtcars, aes(x = wt, y = mpg, color = cyl, shape = cyl)) + geom_point() Usporedbom grafova možemo zaključiti da je boju puno lakše vizualno interpetirati od oblika, što znači da je ona često preferirana estetika (ali nije primjerena ako nam grafovi moraju biti crno-bijeli). Isto tako, uočite da možemo lako kombinirati dvije estetike nad istom varijablom, ukoliko želimo. 13.3.1.2 Funkcija labs Vidjeli smo kako ggplot automatski stvara legendu za svoje estetike te da imenuje osi imenom varijable (osi x i y također možemo smatrati svojevrsnim “legendama”). Ukoliko želimo ručno imenovati osi i legende, ali i dodati naslov grafu možemo se poslužiti funkcijom labs koju također dodajemo kao novi sloj i koja može imati sljedeću sintaksu: ggplot(... ) + ... + labs(x = &quot;x os&quot;, y = &quot;y os&quot;, title = &quot;Naslov&quot;) Isprobajmo ovo na primjeru. Zadatak 13.6 - funkcija ‘labs’ # na sljedećem grafu preimenujte osi i legendu # te dodajte adekvatni naslov (najbolje nešto što objašnjava graf) ggplot(mtcars, aes(x = wt, y = mpg, color = cyl, shape = cyl)) + geom_point() # na sljedećem grafu preimenujte osi i legendu # te dodajte adekvatni naslov (najbolje nešto što objašnjava graf) ggplot(mtcars, aes(x = wt, y = mpg, color = cyl, shape = cyl)) + geom_point() + labs(x = &quot;Težina / 1000 lb&quot;, y = &quot;Potrošnja / milja po galonu&quot;, color = &quot;Broj cilindara&quot;, shape = &quot;Broj cilindara&quot;, title = &quot;Teži auti više troše (manje milja na jedan galon benzina)&quot;) 13.3.2 Fiksni parametri geometrije Prije nastavka, obratimo pažnju na jednu prilično važnu stvar koju do sada nismo razjasnili: što kada želimo utjecati na određene parametre odabrane geometrije, ali želimo ih odrediti fiksno, umjesto da budu povezani sa određenom estetikom, tj. mapiranjem na određenu varijablu? Ili, konkretno - što ako želim napraviti graf ovisnosti potrošnje o težini automobila, ali želim da graf ima točke crvene boje, ili oblika “X” - tj. da su boja i oblik fiksni, umjesto da ovise o nekoj varijabli? Odgovor je zapravo vrlo jednostavan - umjesto da za parametar postavimo ime varijable (npr. wt), mi ga inicijaliziramo na znakovnu ili numeričku vrijednost koja je smislena za taj parametar (npr. \"red\" ili \"#FF0000\" za boju, broj od 0 do 25 za oblik). Primjer sintakse: ggplot(mtcars, aes(wt, mpg)) + geom_point(color = &quot;blue&quot;) Primjer krive sintakse: # ggplot će raditi mapiranje riječi &quot;blue&quot; na estetiku `color` ggplot(mtcars, aes(wt, mpg)) + geom_point(aes(color = &quot;blue&quot;)) Pokušajte ovo primijeniti na primjeru. Zadatak 13.7 - fiksni parametri geometrije # nacrtajte graf ovisnosti potrošnje o težini automobila # koristite geometriju točke # točke neka budu crvene boje, neka oblik broj 4 (iksić) i veličinu 3 ggplot(mtcars, aes(x = wt, y = mpg)) + geom_point(color = &quot;red&quot;, shape = 4, size = 3) 13.3.3 Aspekti statistike i pozicije Vratimo se sada na prvi graf koji je uspoređivao težinu i potrošnju. Što ako smo htjeli ovu povezanost prikazati linijom? Pokušajte donjem pozivu dodati sloj koji koristi postojeće aspekte, ali koristi linijsku geometriju. Možete koristiti funkciju layer sa postavljenim geom parametrom na \"line\", no popularniji pristup je korištenje pomoćne funkcije geom_line koja radi slično kao funkcija geom_point. Zadatak 13.8 - dodavanje linijskog sloja # budući da stalno koristimo istu &quot;osnovicu&quot; grafa možemo ju # pohraniti u zasebnu varijablu npr. imena `graf` graf &lt;- ggplot(mtcars, aes(x = wt, y = mpg)) # dodajte varijabli `graf` geometriju točaka a potom linijsku geometriju graf + geom_point() + geom_line() Dobili smo što smo tražili, no rezultat nije pretjerano uspješan jer je linija isprekidana i vizualno “zakrčuje” graf umjesto da nam donosi dodatnu informaciju (inače, linijska geometrija je vrlo popularna kada radimo sa vremenskim nizovima). Ono što bi nam vjerojatno bilo podesnije jest “izglađena” linija, tj. linija koja aproksimira položaje točaka koje opisuju težinu i potrošnju, umjesto da ih direktno opisuje. Za ovo su nam potrebni dodatni aspekti koje smo već vidjeli u inicijalnom pozivu funkcije ggplot (točnije, funkcije layer) a koje smo u tom trenutku zanemarili, a to su aspekti statistike i pozicije. Statistika je aspekt koji provodi neke dodatne izračune nad podatkovnim skupom prije njegove vizualizacije. To su najčešće izračuni koje lako možemo i sami provesti “ručno”, no koje je puno praktičnije ostaviti na odgovornost vizualizacijskom alatu, pogotovo ako se radi o izračunu koji se koristi samo za potrebe vizualizacije i nije nam trajno potreban (npr. stupčasti graf - bar chart - prebrojava koliko puta se pojavljuje koja kategorijska varijabla i to prikazuje visinom stupca). Većina statistika provode agregaciju, ali nije pravilo. Neke od češće korištenih statistika su: count - prebrojavanje pojava (za kategorijske varijable) bin - raspoređivanje pojava u ladice i prebrojavanje (za kontinuirane varijable) smooth - “zaglađivanje” tj. “usrednjenje” korištenjem odabrane metode (najčešće lm za linearno ili loess za zakrivljeno zaglađivanje) unique - uklanjanje duplikata identity - direktno preslikavanje, tj. “ostavljanje kako jest” Ovo su samo neke statistike, a dodatne se mogu naći u dokumentaciji. Svaka statistika ima svoju pomoćnu funkciju koja prati oblik stat_&lt;ime_statistike&gt; i koja stvara vlastiti sloj vezan uz tu statistiku. Vratimo se na naš graf ovisnosti potrošnje o težini automobila, ali ovaj put umjesto dodavanja sloja linijske geometrije dodajmo sloj koji će prikazati “zaglađivanje” (tj. statistiku smooth). Ovo je odličan primjer korištenja statističkog aspekta - umjesto da se točke direktno povežu linijom, uz pomoć posebne funkcije ćemo “usrednjiti” vrijednosti a potom ćemo tako usrednjene vrijednosti povezati linijom ili krivuljom. Za ovo je idealna funkcija stat_smooth koja će - ukoliko koristimo default-ne parametre - stvoriti novi sloj sa “zaglađenim” prikazom osi y u ovisnosti o osi x, korištenjem tzv. loess metode, uz prikaz intervala pouzdanosti. Ovakav sloj možemo lako dodati već prije definiranoj varijabli graf. Zadatak 13.9 - funkcija ‘stat_smooth’ i metoda ‘lm’ # dodajte geometriju točaka na varijablu `graf` # te potom dodatni sloj sa krivuljom zaglađivanja # koristite funkciju `stat_smooth` uz parametar `method` # postavljen na `&quot;lm&quot;` (linearno zaglađivanje) # i parametar `formula` na `y~x` graf + geom_point() + stat_smooth(formula = y ~ x,method = &#39;lm&#39;) Zadatak 13.10 - funkcija ‘stat_smooth’ i metoda ‘loess’ # ponovite postupak ali metodu zaglađivanja # postavite na `loess` graf + geom_point() + stat_smooth(formula = y ~ x, method = &#39;loess&#39;) Zadatak 13.11 - ‘group’ estetika # stvorite još jednom isti graf ali sloju zaglađivanja # dodajte estetiku `group` postavljenu na `cyl` # Što smo ovime postigli? graf + geom_point() + stat_smooth(formula = y ~ x, aes(group = cyl), method = &#39;loess&#39;) U zadnjem primjeru vidjeli smo tzv. group estetiku. Ona radi slično group_by funkciji iz SQL-a ili dplyr-a, tj. ako računamo agregacije nad nekim skupom podataka, onda se umjesto nad cijelim podatkovnim skupom one rade nad svakom definiranom grupom zasebno. Korištenjem ove estetike možemo na grafu prikazati zasebne izračune prema odabranoj grupi, pa tako je i u ovom primjeru zaglađivanje rađeno po “podgrupama” ovisno o broju cilindara. Kod nekih vizualizacija može se dogoditi da su podaci već “grupirani” ali mi želimo dodati geometriju koja radi nad cijelim podatkovnim skupom - u tom slučaju najlakše je jednostavno postaviti group estetiku na brojku 1, što će R interpretirati kao “sve je jedna grupa” te to tako i prikazati. 13.3.4 Povezanost geometrije i statistike U pravilu određene geometrije prirodno koriste “svoje” statistike (npr. stupčasti graf nastaje tako što se prebrojavaju pojave određene kategorije što se onda reprezentira visinom stupca). U praksi ovo znači da kod vizualizacije “statističkih” slojeva zapravo imamo mogućnost definiranja geom sloja sa stat parametrom ili stat sloja sa geom parametrom - pri čemu često nije potrebno ni posebno podešavati “prateći” parametar budući da je po default-u postavljen na onaj koji nam treba. Tako npr. geom_bar već unaprijed koristi count statistiku, a ponaša se analogno stat_count funkciji koja već ima postavljenu bar geometriju. Koju onda pomoćnu funkciju izabrati, stat ili geom? Ovo je zapravo potpuno nebitno, budući da je učinak isti, ali u praksi se nešto češće koriste geom funkcije većinom zbog malo konzistentnije sintakse izgradnje grafa. Pokušajmo sada napraviti stupčani graf (engl. bar plot) koji će visinom stupića prikazati broj pojavljivanja određene kategorije - npr. zastupljenost pojedinog broja cilindara u okviru mtcars. Za ovo koristimo pomoćnu funkciju geom_bar koja ima unaprijed postavljenu count statistiku. Zadatak 13.12 - stupčasti graf # nacrtajte stupčani graf varijable `cyl` tablice `mtcars` # koristite funkciju `geom_bar` ili `stat_count` ggplot(mtcars, aes(x = cyl)) + geom_bar() Na sličan način možemo prikazati i kontinuirane varijable. Za razliku od stupčanog grafa, gdje imamo jasno definirane kategorije, ovdje ćemo morati prvo grupirati vrijednosti u tzv. “ladice” (engl. bins) na osnovu kojih gradimo graf koji se zove histogram. Opet koristimo statistiku bin, a za samo stvaranje histograma koristit ćemo pomoćnu funkciju geom_histogram. Zadatak 13.13 - histogram # nacrtajte histogram varijable `wt` tablice `mtcars` # težine podijelite jednoliko u četiri ladice # koristite funkciju `geom_histogram` ggplot(mtcars, aes(x = wt)) + geom_histogram(bins = 4) Kako zapravo radi statistički aspekt? U pravilu se na osnovu postojećih varijabli izračunavaju jedna ili više novih, najčešće agregiranih varijabli. U dokumentaciji možemo naći konkretne informacije o nazivima tih novih varijabli i njihovom značenju. Na primjer, ako pogledamo dokumentaciju za funkciju stat_bin, možemo vidjeti da ona stvara varijable imena count, ncount, density i ndensity. Bilo koja od ovih varijabli može se koristiti kao “visina stupića”, tj. kao estetika y. Razlog zašto ovu estetiku nismo eksplicitno navodili u prethodnom primjeru jest činjenica da funkcija statistike automatski odabire onu agregatnu funkciju koja se očekivano najčešće koristi (u našem slučaju je to bila count). Ukoliko želimo obaviti neku drugu agregaciju, možemo i eksplicitno postaviti estetiku y na odabranu varijablu, samo moramo koristiti ggplot2 konvenciju gdje takve varijable omatamo funkcijom after_stat, kao npr: aes(x = hp, after_stat(density)`) Pokušajmo ovo isprobati na primjeru. Zadatak 13.14 - histogram / ‘ncount’ # nacrtajte histogram varijable `wt` tablice `mtcars` # težine podijelite jednoliko u četiri ladice # koristite funkciju `geom_histogram` # za agregacijsku varijablu postavite `ncount` # prokomentirajte dobiveni rezultat ggplot(mtcars, aes(x = wt, y =after_stat(ncount))) + geom_histogram(bins = 4) Otiđimo sada korak dalje. Nacrtajte isti histogram (sa default-nom count agregacijom), no prikažite na njemu i koliko je unutar svake kategorije zastupljen koji broj cilindara. Ovo ćete lako izvesti dodavanjem estetike fill koja reprezentira “punjenje” stupića bojom (za razliku od estetike color koja bi u slučaju stupčanog grafa bojala linije oko pravokutnika). Zadatak 13.15 - ‘fill’ estetika u histogramu # nacrtajte histogram varijable `wt`, uz dodanu varijablu `cyl` na estetici `fill` ggplot(mtcars, aes(x = wt, fill = cyl)) + geom_histogram(bins = 4) Ovdje vidimo primjer “kombiniranog” histograma - funkcija će zapravo izračunati frekvencije pojavljivanja za svaku kategoriju težine te za svaki broj cilindara. Jedan od načina kako ovo prikazati bio bi trodimenzionalni graf gdje bi u baznoj ravnini bile kombinacije dvije navedene varijable dok bi treća dimenzija bila rezervirana za visinu stupića - no kod projekcije takvog grafa na dvodimenzionalnu ravninu stupići bi se međusobno prekrivali. Kako bi se rezultati mogli učinkovito prikazati na dvodimenzionalnom grafu, stupići su “repozicionirani” tako da su je stupić za pojedine cilindre postavljen jedan na drugi u sklopu iste kategorije težine. Ovo je zapravo primjer korištenja tzv. pozicijskog aspekta ili jednostavno pozicije. Pozicija je aspekt koji omogućuje “razmještanje” određenog aspekta grafa ukoliko je to potrebno zbog jasnoće prikaza. U prethodnom primjeru već smo uočili “raslojavanje” stupića prema kategorijskoj varijabli. U ovom slučaju funkcija je zapravo koristila pozicijski aspekt \"stack\" koji “male” stupiće razmješta tako da ih slaže jedan na drugi. Alternativa je postavljanje aspekta pozicije (position) na “izbjegavanje” - \"dodge\"- kod kojeg će stupići biti nacrtani u grupicama jedan pored drugog. Zadatak 13.16 - pozicijski aspekt ‘dodge’ # nacrtajte isti histogram, ali pozicijski aspekt `position` postavite na `&quot;dodge&quot;` ggplot(mtcars, aes(x = wt, fill = cyl)) + geom_histogram(bins = 4, position = &quot;dodge&quot;) Uočite da smo korištenjem “izbjegavanja” izgubili precizan prikaz intervala pojedine ladice, ali smo dobili jasniji prikaz odnosa između zastupljenosti pojedinih kategorija unutar pojedine ladice. Zadatak 13.17 - pozicijski aspekt ‘identity’ # nacrtajte opet isti histogram, ali pozicijski aspekt # `position` postavite na `&quot;identity&quot;` # parametar geometrije `alpha` postavite na 0.2 ggplot(mtcars, aes(x = wt, fill = cyl)) + geom_histogram(bins = 4, position = &quot;identity&quot;, alpha = 0.4) Kao što vidimo, pozicijski aspekt \"identity\" znači “bez repozicioniranja”. Pokažimo još jedan pozicijski aspekt - \"fill\" (nemojte ga miješati sa estetikom fill!). Zadatak 13.18 - pozicijski aspekt ‘fill’ # nacrtajte isti histogram, ali uz pozicijski aspekt postavljen na `fill` # radi bolje vidljivosti pravokutnike uokvirite crnom linijom # objasnite rezultat. Što smo postigli ovakvim histogramom? ggplot(mtcars, aes(x = wt, fill = cyl)) + geom_histogram(bins = 4, color = &quot;Black&quot;, position = &quot;fill&quot;) Konačni primjer pozicijskog aspekta kojeg ćemo prikazati je dodavanje “šuma” obzervacijama koje prikazujemo točkastim grafom a koje prekrivaju jedna drugu te djeluju kao jedna obzervacija. Dodavanjem pozicijskog aspekta jitter možemo bolje vizualno komunicirati da se radi o većem broju obzervacija (ovo je učinkovito za manje podatkovne skupove, za veće ćemo često bolje rezultate postići korištenjem parametra transparentnosti, smanjivanjem veličine točaka ili uzorkovanjem skupa prije vizualizacije). Za primjer ćemo stvoriti jedan “umjetni” podatkovni okvir od 100 “prekrivajućih” obzervacija. Zadatak 13.19 - pozicijski aspekt ‘jitter’ df &lt;- data.frame( x = c(rep(1, 90), rep(2, 9), 3), y = c(rep(1, 70), rep(2, 25), rep(3, 5))) # prikažite navedeni okvir uz pomoć `scatterplot` grafa, tj. točkaste geometrije ggplot(df, aes(x = x, y = y)) + geom_point() Zadatak 13.20 - pozicijski aspekt ‘jitter’ (2) # prikažite isti graf, ali umjesto `geom_point` upotrijebite # pomoćnu funkciju `geom_jitter` koja ima ugrađen `jitter` pozicijski aspekt # postavite `width` i `height` parametre na 0.3 (30% dodanog šuma) # dodatno postavite `color` parametar geometrije na &quot;blue&quot; # i `alpha` parametar (&quot;prozirnost&quot;) na 0.4 ggplot(df, aes(x = x, y = y)) + geom_jitter(width = 0.3, height = 0.3, alpha = 0.4, color = &quot;blue&quot;) 13.3.4.1 Spremanje slike u datoteku Za kraj ovog dijela naučimo spremiti sliku u datoteku kako bi ju mogli lako ugraditi u neki drugi izvještajni dokument, znanstveni rad, proslijediti elektroničkom poštom i sl. R po default-u koristi zaslon kao “grafički uređaj” (engl. graphical device). Opcionalno, grafiku možemo “preusmjeriti” na neki drugi “uređaj”, najčešće datoteku određenog tipa (png, tiff, pdf i sl.). Popis svih mogućnosti možemo pogledati uz pomoć naredbe ?Devices. Za spremanje grafova u rasterskom formatu preporučuju se png i tiff formati, dok je za vektorski format uobičajeno koristiti pdf. Spremanje grafova može se obaviti pozivom funkcije koja odgovara formatu u kojeg želimo pohraniti sliku (npr. funkcija pdf spremiti će iduću sliku u pdf datoteku), no paket ggplot2 nudi nešto praktičniji način - funkcija ggsave pohraniti će zadnje iscrtani* graf u datoteku odabranog imena, pri čemu će format slike zaključiti sama iz ekstenzije datoteke koju odaberemo. Ovaj način je bolji utoliko što imamo šansu prvo vidjeti graf i tek onda se odlučiti na pohranu. Zadatak 13.21 - spremanje grafa u datoteku # spremite sljedeći graf u datoteke `figure1.pdf`i `figure1.png` ggplot(mtcars, aes(x = hp, y = mpg, col = as.factor(cyl))) + geom_point() + geom_smooth(formula = y ~ x, aes(x = hp, y = mpg), method = &#39;loess&#39;, linetype = 4, color = &quot;grey&quot;, se = F, inherit.aes = F) + labs(x = &quot;broj konjskih snaga&quot;, y = &quot;potrošnja&quot;, col = &quot;broj cilindara&quot;) ggsave(&quot;figure1.pdf&quot;) ggsave(&quot;figure1.png&quot;) 13.3.5 Aspekti skale, koordinatnog sustava i teme Već smo ponovili da se stvaranje ggplot2 grafova često svodi na mapiranje stupaca podatkovnog skupa na estetike grafa. Skale su aspekt koji kontrolira način kako se to mapiranje provodi, tj. metodu preslikavanja samih podataka na vizualne elemente estetike. U slučaju koordinatnih osi tu se radi o preslikavanju numeričkih ili kategorijskih vrijednosti na konkretne udaljenosti na samim osima, dok npr. kod estetike boje skala odlučuje koja boja označava koju vrijednost originalnih podataka. Skala je također osnovica za stvaranje legende grafa. Ovaj aspekt je do sada uvijek bio implicitno prisutan, ali smo dopuštali ggplot2 paketu da “odabere” default-ne vrijednosti za nas. U općenitom slučaju ggplot2 relativno dobro kontrolira aspekt skale neovisno o estetikama koje koristimo, ali vrlo često iz raznih razloga želimo utjecati na samo mapiranje kako bi npr. promijenili opseg vrijednosti koje se nalaze na grafu, oznake na osima, boje ili oblike koji se koriste i sl. U ovoj lekciji usredotočiti ćemo se samo na one skale koje se relativno često susreću u praksi. Ostale funkcije i opcije vezane uz aspekte skaliranje mogu se pronaći u dokumentaciji (ili na RStudio ggplot2 podsjetniku). Kada radimo sa skalama, najčešće se koristimo ovim pomoćnim funkcijama (* predstavlja “ime estetike”, kao npr. x, y, color itd.): scale_*_continuous - za mapiranje kontinuiranih (numeričkih) vrijednosti scale_*_discrete - za mapiranje diskretnih vrijednosti scale_*_ordinal - za mapiranje ordinalnih diskretnih vrijednosti Svaka od ovih funkcija ima niz parametara koje možemo koristiti kako bi utjecali na postupak mapiranja. Npr. ako pogledamo dokumentaciju za scale_x_continuous možemo vidjeti da između ostalog možemo postaviti parametre: name - ime skale koje ujedno postaje i naziv osi/legende breaks - na kojim pozicijama se stavljaju crtice labels - koje vrijednosti se ispisuju ispod crtica limits - raspon vrijednosti koji će se nalaziti na osi itd. Važno je napomenuti da ggplot2 ima puno dodatnih pomoćnih funkcija koje omogućuju da na neke od ovih stvari podešavamo i mimo funkcija skaliranja, kao npr. već viđeni labs s kojim smo preimenovali naziv grafa, osi i legendi, ali također i funkcije xlim/ylim kojima utječemo samo na raspon osi i sl. Često se isplati pomno pogledati dokumentaciju budući da se mogu naći zgodne funkcije koje nam uvelike olakšavaju posao skraćivanjem sintakse za vizualizacijske zadatke koje obavljamo. Isprobajmo neke od navedenih funkcija na primjerima. Koristiti ćemo se podatkovnim skupom diamonds paketa ggplot2, kojeg smo upoznali u zadacima za vježbu iz prethodne lekcije, a koji opisuje značajke dijamanata uz njihovu procijenjenu vrijednost. Zadatak 13.22 - upoznavanje sa podatkovnim skupom ‘diamonds’ # proučite podatkovni okvir `diamonds` # proučite podatkovni okvir `diamonds` glimpse(diamonds) head(diamonds) ## Rows: 53,940 ## Columns: 10 ## $ carat &lt;dbl&gt; 0.23, 0.21, 0.23, 0.29, 0.31, 0.24, 0.24, 0.26, 0.22, 0.23, 0.… ## $ cut &lt;ord&gt; Ideal, Premium, Good, Premium, Good, Very Good, Very Good, Ver… ## $ color &lt;ord&gt; E, E, E, I, J, J, I, H, E, H, J, J, F, J, E, E, I, J, J, J, I,… ## $ clarity &lt;ord&gt; SI2, SI1, VS1, VS2, SI2, VVS2, VVS1, SI1, VS2, VS1, SI1, VS1, … ## $ depth &lt;dbl&gt; 61.5, 59.8, 56.9, 62.4, 63.3, 62.8, 62.3, 61.9, 65.1, 59.4, 64… ## $ table &lt;dbl&gt; 55, 61, 65, 58, 58, 57, 57, 55, 61, 61, 55, 56, 61, 54, 62, 58… ## $ price &lt;int&gt; 326, 326, 327, 334, 335, 336, 336, 337, 337, 338, 339, 340, 34… ## $ x &lt;dbl&gt; 3.95, 3.89, 4.05, 4.20, 4.34, 3.94, 3.95, 4.07, 3.87, 4.00, 4.… ## $ y &lt;dbl&gt; 3.98, 3.84, 4.07, 4.23, 4.35, 3.96, 3.98, 4.11, 3.78, 4.05, 4.… ## $ z &lt;dbl&gt; 2.43, 2.31, 2.31, 2.63, 2.75, 2.48, 2.47, 2.53, 2.49, 2.39, 2.… ## # A tibble: 6 × 10 ## carat cut color clarity depth table price x y z ## &lt;dbl&gt; &lt;ord&gt; &lt;ord&gt; &lt;ord&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 0.23 Ideal E SI2 61.5 55 326 3.95 3.98 2.43 ## 2 0.21 Premium E SI1 59.8 61 326 3.89 3.84 2.31 ## 3 0.23 Good E VS1 56.9 65 327 4.05 4.07 2.31 ## 4 0.29 Premium I VS2 62.4 58 334 4.2 4.23 2.63 ## 5 0.31 Good J SI2 63.3 58 335 4.34 4.35 2.75 ## 6 0.24 Very Good J VVS2 62.8 57 336 3.94 3.96 2.48 Zadatak 13.23 - uzorkovanje skupa ‘diamonds’ set.seed(1001) # stvorite okvir `diamondsSample` u koji ćete staviti # 5000 nasumičnih redaka iz okvira `diamonds` set.seed(1001) # stvorite okvir `diamondsSample` u koji ćete staviti # 5000 nasumičnih redaka iz okvira `diamonds` diamondsSample &lt;- slice_sample(diamonds, n = 5000) Zadatak 13.24 - korištenje aspekta skale # &quot;popravite&quot; osi i legendu grafa koji prikazuje ovisnost # veličine dijamanta, boje i cijene # - osi x i y nazovite &quot;volumen u mm3&quot; i &quot;cijena u $&quot; # - legendu nazovite &quot;kvaliteta boje&quot; # - os x ograničite od 0 do 450 # - na osi y postavite crtice na 1000, 5000, 10000 i 15000 # - kategorije kvalitete boje postavite na brojeve # od 1 do 7 gdje 1 predstavlja &quot;najbolju&quot; boju ggplot(diamondsSample, aes(x*y*z, price, color = color)) + geom_point(alpha = 0.4) ggplot(diamondsSample, aes(x*y*z, price, color = color)) + geom_point(alpha = 0.6) + scale_x_continuous(name = &quot;volumen u mm3&quot; , limits = c(0, 450)) + scale_y_continuous(name = &quot;cijena u $&quot;, breaks = c(1000, 5000, 10000, 15000)) + scale_color_ordinal(name = &quot;kvaliteta boje&quot;, labels = 1:7) ## Warning: Removed 3 rows containing missing values (`geom_point()`). Uočite kako ggplot za svaki slučaj javlja kako neke obzervacije nisu prikazane. Ukoliko želimo spriječiti ovo upozorenje, dovoljno je dodati argument na.rm = T u sloj geometrije. Vrlo često se događa da na grafovima uočavamo tzv. “eksponencijalni trend”, tj. da nas ovisnost jedna varijable u drugoj podsjeća na eksponencijalnu funkciju. Prethodni graf također je primjer takvog scenarija - može se primijetiti da cijena dijamanta na početku “blago” raste sa veličinom dijamanta, da bi kasnije počela strmije rasti. U analizi podataka u ovakvim slučajevima često provodimo transformacije podataka - npr. u ovom slučaju mogli bismo pokušati logaritmirati cijenu kako bi eksponencijalni trend probali pretvorili u linearni kojeg u općenitom slučaju preferiramo. No transformacija cijene u logaritam nosi sa sobom problem interpretacije - graf bolje komunicira informaciju ako se na njemu nalazi doslovni, a ne izvedeni podatak (1000 dolara naspram 3 “logaritma od dolara”). Skale nam u ovome slučaju mogu pomoći - umjesto da “diramo” podatke, mi jednostavno koristimo logaritmiranu (ili neku drugu) skalu. Konkretno, umjesto funkcije scale_*_continuous možemo odabrati: scale_*_log10 - logaritmira skalu po bazi 10 scale_*_reverse - “obrće” skalu s desna na lijevo scale_*_sqrt - “korjenuje” vrijednosti skale Zadatak 13.25 - logaritamska skala # logaritmirajte cijenu dijamanta u prethodno izvedenom grafu ggplot(diamondsSample, aes(x*y*z, price, color = color)) + geom_point(na.rm = T, alpha = 0.6) + scale_x_continuous(name = &quot;volumen u mm3&quot; , limits = c(0, 450)) + scale_y_continuous(name = &quot;cijena u $&quot;, breaks = c(1000, 5000, 10000, 15000)) + scale_color_ordinal(name = &quot;kvaliteta boje&quot;, labels = 1:7) # logaritmirajte cijenu dijamanta u prethodno izvedenom grafu ggplot(diamondsSample, aes(x*y*z, price, color = color)) + geom_point(na.rm = T, alpha = 0.6) + scale_x_continuous(name = &quot;volumen u mm3&quot; , limits = c(0, 450)) + scale_y_log10(name = &quot;cijena u $&quot;, breaks = c(1000, 5000, 10000, 15000)) + scale_color_ordinal(name = &quot;kvaliteta boje&quot;, labels = 1:7) Jedna stvar koju vrlo često volimo “popravljati” na grafovima su boje - bilo da želimo bolje naglasiti informacije koje graf prenosi, uklopiti graf u okolinu u kojoj se nalazi, ili jednostavno želimo da nam graf koristi boje koje nalazimo estetski ugodnima. Upravo zbog toga estetike color i fill se vrlo često dodatno podešavaju uz pomoć skala. Za ovo imamo zgodne funkcije (dajemo primjere za fill estetike iako većina funkcija postoji i za color): scale_fill_brewer - odabir jedne od unaprijed pripremljenih paleta boja namijenjenih prikazu diskretnih vrijednosti; imena paleta mogu se pogledati u dokumentaciji scale_fill_distiller - prilagođava palete za diskretne vrijednosti kontinuiranim varijablama scale_fill_gradient - odabir početne i konačne boje koje će se “prelijevati” jedna u drugu; koristimo za prikaz kontinuiranih vrijednosti scale_fill_gradient2, scale_fill_gradientn - ako želimo više “prelijevanja” scale_fill_grey - za crno bijele vizualizacije Paket RColorBrewer je odličan alat za prilagodbu boja na vizualizacijama, a pomoću funkcije display.brewer.all možemo dobiti pregled dostupnih paleta: library(RColorBrewer) display.brewer.all() Zadatak 13.26 - prilagodba boja na grafu # podesite `fill` estetiku sljedećeg grafa korištenjem # funkcije `scale_fill_brewer` # podesite `fill` estetiku sljedećeg grafa korištenjem funkcije `scale_fill_brewer` # parametar `palette` postavite na jednu od gore prikazanih paleta ggplot(diamondsSample, aes(x = x*y*z, fill = color)) + geom_histogram(bins = 30, na.rm = T) + xlim(0, 500) # podesite `fill` estetiku sljedećeg grafa korištenjem funkcije `scale_fill_brewer` # parametar `palette` postavite na jednu od gore prikazanih paleta ggplot(diamondsSample, aes(x = x*y*z, fill = color)) + geom_histogram(bins = 30, na.rm = T) + xlim(0, 500) + scale_fill_brewer(palette = &quot;Greens&quot;) # podesite `fill` estetiku sljedećeg grafa korištenjem funkcije `scale_fill_brewer` # parametar `palette` postavite na jednu od gore prikazanih paleta ggplot(diamondsSample, aes(x = x*y*z, fill = color)) + geom_histogram(bins = 30, na.rm = T) + xlim(0, 500) + scale_fill_brewer(palette = &quot;YlOrRd&quot;) Aspekt koordinatnog sustava vrlo rijetko mijenjamo. Razlog tome je što u najvećem broju slučajeva želimo koristiti Kartezijev koordinatni sustav koji ggplot koristi po default-u. Ukoliko smatramo da naša vizualizacija zahtijeva nešto drugo - bilo da se radi o polarnom koordinatnom sustavu, ili želimo “izvrnuti” naš Kartezijev sustav na stranu, ili - što je posebno važno kod analize zemljopisnih podataka - želimo da naša vizualizacija prikazuje zemljopisnu kartu, možemo između ostalog koristiti sljedeće funkcije: coord_cartesian - nazivni odabir - kartezijev koordinatni sustav coord_polar - polarni koordinatni sustav coord_flip - mijenja x i y osi coord_map - koristi karte iz paketa maps i mapproj Trenutno u ovim paketima nažalost još ne postoje karte Republike Hrvatske, no ambiciozniji čitatelji mogu pokušati stvoriti istu (i podijeliti sa lokalnom R zajednicom) prateći upute na ovoj i ovoj poveznici. Zadatak 13.27 - izvrnuti i polarni koordinatni sustavi # pogledajte kako sljedeći graf izgleda u &quot;izvrnutom&quot; a kako u polarnom koordinatnom sustavu ggplot(diamondsSample, aes(x = x*y*z, fill = color)) + geom_histogram(bins = 30, na.rm = T) + xlim(40, 100) # pogledajte kako sljedeći graf izgleda u &quot;izvrnutom&quot; # a kako u polarnom koordinatnom sustavu ggplot(diamondsSample, aes(x = x*y*z, fill = color)) + geom_histogram(bins = 30, na.rm = T) + xlim(40, 100) + coord_polar() # pogledajte kako sljedeći graf izgleda u &quot;izvrnutom&quot; # a kako u polarnom koordinatnom sustavu ggplot(diamondsSample, aes(x = x*y*z, fill = color)) + geom_histogram(bins = 30, na.rm = T) + xlim(40, 100) + coord_flip() Uočimo da smo u prethodnom zadatku koristili funkciju xlim() koja je - slično funkciji ylim() - pomoćna funkcija za limitiranje raspona aspekta skale. Točnije, graf prikazuje samo opservacije koje se nalaze u tom opsegu, dok one koje nisu u tom opsegu tretira kao nedostajuće vrijednosti (zbog čega smo i dodavali parametar na.rm = T u geometriju). Ako pogledamo dokumentaciju pomoćnih funkcija za aspekt koordinatnog sustava, možemo vidjeti da one između ostalog spominju i parametre xlim i ylim, za koje je lako pogrešno pretpostaviti da rade na istom principu kao i istoimene funkcije. Razlika je u sljedećem - kroz aspekt koordinatnog sustava mi modificiramo “pogled” na već postojeći graf, kao što smo vidjeli kroz primjere izvrtanja ili preoblikovanja grafa. Parametri xlim i ylim ograničavaju pogled na odabrani segment grafa, pri čemu su ostale opservacije i dalje tu, samo nisu vidljive - efektivno postižemo “zumiranje” na odabrano područje. U sljedećem primjeru koristiti ćemo i funkciju xlim i parametar xlim - pogledajte rezultat i usporedite sa inicijalnim grafom iz prethodnog zadatka. ggplot(diamondsSample, aes(x = x*y*z, fill = color)) + geom_histogram(bins = 30, na.rm = T) + xlim(40, 100) + coord_cartesian(xlim = c(50, 60)) Konačno aspekt teme grafa nam omogućuje da utječemo na sve vizualne aspekte grafa koji nisu povezani s podacima. To znači da možemo birati boju i izgled pozadine, font i veličinu slova, margine, poravnavanja i još niz drugih parametara grafa. Tema nam daje iznimno detaljnu kontrolu nad izgledom grafa, a budući da se zapravo radi o objektu (klase theme), temu grafa možemo pohraniti i reciklirati za sve buduće vizualizacije. Isto tako, ggplot2 nudi niz već unaprijed pripremljenih tema za korištenje i daljnju prilagodbu, a koje dohvaćamo uz skup pomoćnih funkcija od kojih su neke: theme_gray - default-na tema theme_bw - crno-bijele osi, pogodna za projiciranje grafova theme_classic - “klasična” tema slična onoj koju producira plot funkcija theme_void - “prazna” tema Zadatak 13.28 - odabir druge teme grafa # promijenite temu sljedećem grafu na `theme_classic` ggplot(diamondsSample, aes(x = x*y*z, fill = color)) + geom_histogram(bins = 30, na.rm = T) + xlim(0, 500) # promijenite temu sljedećem grafu po izboru ggplot(diamondsSample, aes(x = x*y*z, fill = color)) + geom_histogram(bins = 30, na.rm = T) + xlim(0, 500) + theme_classic() Često želimo promijeniti samo neki od aspekata grafa koji nije vezan uz podatke (npr. veličina ili orijentacija slova, izgled crtica na osima i sl.). Za ove stvari koristimo funkciju theme koja sadrži vrlo bogati niz parametara (pogledati dokumentaciju!). Neke od tih parametara su tzv. “elementi” teme (npr. element_line, element_text) koje namještamo pozivom pripadne funkcije unutar poziva funkcije theme, npr: # mijenjamo izgled naziva grafa # (za obitelj fontova preporučeno koristiti #`serif`, `sans` ili `mono`) ... + theme( title = element_text(family = &#39;serif&#39;, face = &#39;bold.italic&#39;)) Zadatak 13.29 - izmjena elementa teme grafa # promijenite orijentaciju slova na x osi # tako da budu pod kutem od 45 stupnjeva ggplot(diamondsSample, aes(cut)) + geom_bar() ggplot(diamondsSample, aes(cut)) + geom_bar() + theme(axis.text.x = element_text(angle = 45)) 13.3.6 Uvjetni (facetirani) grafovi Već smo se upoznali sa estetikom grupiranja, koja prije vizualizacije unutar skupa podataka radi podskupove po odabranoj varijabli te ih shodno tome na adekvatan način vizualizira. Također smo naučili da možemo raditi implicitna grupiranja uz pomoć estetika boje, oblika, veličine i sl. Ono što je zajedničko navedenim principima jest da se vizualno razdvajanje u ovisnosti o nekoj varijabli provodi na istom grafu, tj. koristimo se raznim estetikama kako bi prikazali nekoliko različitih vizualizacijama u sklopu jedinstvenog grafa. Uvjetni (facetirani) grafovi rade na istom principu, ali razdvajanje po odabranoj varijabli (ili varijablama) radi se na način da se vizualizira više grafova koji se onda prikazuju jedan pored drugoga. Rezultantni grafovi prikazuju istu informaciju kao i estetika (implicitne ili eksplicitne) grupe, ali je ovako nešto lakše proučiti svaki podgraf zasebno. Prije demonstracije kako radimo uvjetno grafove moramo objasniti pojam tzv. “notacije statističkih formula” (statistical formula notation). Ova notacija se često koristi u R-u, pogotovo kod treniranja raznih statističkih modela, a radi se zapravo o formalnoj notaciji međuovisnosti varijabli nekog podatkovnog skupa zamišljenoj na način da se može na što kraći i jednostavniji način zapisati i ugraditi u programski kod. Formule ćemo detaljnije obrađivati kasnije, a za sada ćemo pokazati samo vrlo jednostavan primjer. Ako želimo zapisati “y u ovisnosti o x-u”, onda formula izgleda ovako: y ~ x # znači &quot;y u ovisnosti o x-u&quot; ovo možemo čitati i kao “y kao funkcija od x” ili - u slučaju linearnih modela - “y = ax + b”. Dakle, znak tilda (~) zapravo znači “u ovisnosti o”. Prikažimo još neke jednostavnije oblike formula: # z u ovisnost o x i y (plus ovdje nije aritmetičko zbrajanje!) z ~ x + y # y u ovisnosti o &quot;svim ostalim varijablama&quot; y ~ . # &quot;sve ostale varijable&quot; u ovisnosti o y . ~ y # tzv. &quot;jednostrana&quot; formula, &quot;u ovisnosti o y&quot; ~ y Zadnja dva primjera je malo teže matematički definirati no znaju se koristiti u pozivima funkcija za različite svrhe, većinom zbog jednostavnog zapisa i lake interpretacije. Vratimo se sada na uvjetne grafove. Postoji dva osnovna načina stvaranja uvjetnih grafova, a to je uz pomoć funkcija facet_grid - za organizaciju “podgrafova” u mrežu tj. matricu facet_wrap - za organizaciju “podgrafova” u jedan ili više redaka Funkciju facet_grid koristimo kad podskupove radimo po jednoj ili dvije kategorijske varijable. Rastavljanje po dvije varijable prirodno radi “matricu”, dok rastavljanje po jednoj će napraviti redak ili stupac, što možemo kontrolirati formulom. Funkciju facet_wrap koristimo kada želimo rastaviti po jednoj varijabli, ali ne želimo da svi budu u jednom stupcu ili retku već ih želimo presložiti u više redaka (zato je i wrap, slično kao word wrap u uređivaču teksta koji prenosi tekst u drugi red). Zadatak 13.30 - funkcija ‘facet_grid’ # reduciramo uzorak kako bi radili sa # faktorima sa manjim brojem razina diamondsSample %&gt;% filter(color %in% c(&quot;G&quot;, &quot;H&quot;, &quot;I&quot;, &quot;J&quot;), cut %in% c(&quot;Very Good&quot;, &quot;Premium&quot;, &quot;Ideal&quot;)) -&gt; diamondsSample2 # napravite uvjetni graf u ovisnosti o kombinaciji # boje (`color`) i reza (`cut`) # koristite funkciju `facet_grid` i # formulu kao parametar ggplot(diamondsSample2, aes(depth, fill = clarity)) + geom_histogram(bins = 5, position = &#39;dodge&#39;) ggplot(diamondsSample2, aes(depth, fill = clarity)) + geom_histogram(bins = 5, position = &#39;dodge&#39;) + facet_grid(color ~ cut) Zadatak 13.31 - funkcija ‘facet_grid’ (2) # ponovite postupak, ali sada rastavite samo po boji # grafove organizirajte u stupac # koristite funkciju `facet_grid` i notaciju formule sa točkom ggplot(diamondsSample2, aes(depth, fill = clarity)) + geom_histogram(bins = 5, position = &#39;dodge&#39;) ggplot(diamondsSample2, aes(depth, fill = clarity)) + geom_histogram(bins = 5, position = &#39;dodge&#39;) + facet_grid(color ~ .) Uočite jednu bitnu značajku uvjetnih grafova - koordinatne osi (tj. skale) su poravnate. Naime, prije vizualizacije, ggplot prvo “trenira” skale na način da pronađe maksimalni raspon koji se onda koristi kao zajednička značajka svih grafova. Ukoliko to ne želimo, može određenu os (ili obje) učiniti slobodnom uz pomoć parametra scales kojeg postavimo na \"free\" (za obje osi) ili \"free_x\" odnosno \"free_y\" (ako želimo da samo jedna os bude poravnata a druga “slobodna”). Pogledajmo još kako radi funkcija facet_wrap: Zadatak 13.32 - funkcija ‘facet_wrap’ # razdvojite sljedeći graf u ovisnosti o prozirnosti (`clarity`) # koristite funkciju `facet_wrap` i jednostranu formulu ggplot(diamondsSample2, aes(x*y*z, price)) + geom_point() ggplot(diamondsSample2, aes(x*y*z, price)) + geom_point() + facet_wrap( ~ clarity) Ovime završavamo priču o gramatičkoj geometriji, njezinim aspektima i primjeni uz pomoć paketa ggplot2. Ovdje nisu ni približno objašnjenje sve mogućnosti ovoga paketa, zbog čega se snažno preporučuje dodatno čitanje dokumentacije i referenciranje na podsjetnik koji sadrži niz geometrija i opcija za koje u ovim lekcijama nije bilo mjesta. Također, ne treba zaboraviti na niz dodatnih paketa koji dodatno proširuju mogućnosti paketa ggplot2, a koje bi trebalo potražiti u ovisnosti o našim zahtjevima i željama glede vizualizacija koje želimo stvoriti za naše projekte podatkovne analize. Za inspiraciju zgodno je pogledati galeriju grafova i slika nastalih uz pomoć jezika R, a koja je dostupna na ovoj poveznici . 13.4 Grafovi u eksploratornoj analizi i izvještavanju Za kraj možemo se kratko osvrnuti na razliku između grafova rađenih za eksploratornu analizu podataka i onih koje koristimo u izvještajima, za komunikaciju naših zaključaka drugim ljudima i prenošenje dobivenih saznanja. Kod eksploratorne analize podataka često je glavni cilj - kvantiteta. Već je rečeno da se eksploratorna analiza svodi na traženje odgovora za niz pitanja koje analitičar postavlja vezano uz podatke. Estetika ovdje često nije bitna - glavno je da grafovi imaju dovoljno informacija da se kod naknadnog pregledavanja može ono što je predočeno staviti u odgovarajući kontekst. Analitičar će također često isprobavati različite kombinacije estetika, geometrija i statistika. Ponekad je zgodno koristiti i dodatne pakete koji omogućuju prikaz većeg broja varijabli na istom grafu, npr. funkcija ggpairs paketa GGally: #library(GGally) #ako je potrebno # uzimamo samo četiri stupca zbog jasnijeg prikaza ggpairs(data = diamondsSample[,c(1, 2, 5, 7)]) Eksploratorne grafove analitičar koristi radi predočavanja samih podataka, kako bi potražio uzorke, prepoznao distribucije ili prirodna grupiranja podataka ili uočio iskočne vrijednosti (tzv. outlier-e). Isto tako, eksploratorni grafovi se koriste za predočavanje raznih agregiranih statistika. Ukoliko se radi o prediktivnoj analizi podataka, tj. cilj analize jest razviti metodu predviđanja nekih varijabli na osnovu drugih varijabli podatkovnog skupa, analitičar će često u tijeku eksploratorne analize stvoriti nekoliko jednostavnijih prediktivnih modela koje će onda vizualizirati na grafu kako bi mogao slikom predočiti učinkovitost modela te na osnovu uočenih nedostataka razviti strategiju za daljnje korake analize. Kod izvještavanja s druge strane ključna je kvaliteta grafa u smislu jasnog i preglednog predstavljanja informacije. Izvještajne vizualizacije često su ključne za jasno i jezgrovito komuniciranje rezultata istraživanja što u određenom kontekstu može imati dalekosežne posljedice, kao što je slučaj kod jedne od najpoznatijih povijesnih vizualizacija, grafa kojeg je stvorila medicinska sestra i matematičarka Florence Nightingale kako bi popravila higijenske uvjete u vojnim bolnicama sredinom 19. stoljeća: Slika 13.1: Diagram of the causes of mortality in the army in the East by Florence Nightingale, 1858, Wikimedia Commons Izvještajni graf mora jasno komunicirati informacije koje su njime predočene, uz pažljivo odabrana objašnjenja i pomno odabrano korištenje tzv. metapodataka, tj. dodatnog teksta i anotacija. Za stvaranje izvještajnih grafova preporučuje se koristiti dodatne geom_text slojeve za tekstualnim oznakama na odgovarajućim područjima grafa gdje one mogu najviše doprinijeti, a također i kreativno korištenje geom_point, geom_hline, geom_vline, geom_rect i sličnih geometrijskih slojeva koji će dodatno pojasniti određene segmente grafa. Isto tako, preporučuje se unaprijed pripremiti temu koju ćemo onda konzistentno primjenjivati na sve grafove. U velikom broju slučajeva grafovi u izvještajima su zapravo probrani i “uljepšani” grafovi dobiveni tijekom eksploratorne analize. No analitičar bi trebao posebnu pažnju posvetiti činjenici da se grafovi u izvještajima često rade za publiku koja je daleko manje upoznata sa podatkovnim skupom i raznim detaljnim saznanjima koje je analitičar dobio tijekom eksploratorne analize. Izvještajni grafovi stoga moraju biti orijentirani krajnjem korisniku, te s tim ciljem i pažljivo dizajnirani. Zbog toga se preporučuje da svi elementi grafa - uključujući i naslov, legende i sl. budu orijentirani komunikaciji informacije i razjašnjenju što graf prikazuje, a što je u skladu sa zaključcima koje publikacija iznosi. Konačno, ponekad želimo zbog štednje prostora unutar jedne slike staviti više različitih grafova. Ovo obično radimo uz pomoć više zasebnih slika koje slažemo unutar sučelja kojeg koristimo za pisanje publikacije čiji su dio navedeni grafovi, no možemo i unaprijed pripremiti grafove uz pomoć paketa gridExtra. Između ostalog, ovaj paket nudi funkciju grid.arrange uz pomoć koje grafove slažemo u matricu s odabranim brojem redaka i stupaca. #library(gridExtra) # ukoliko je potrebno # grafove koje slažem u matricu pohranjujem u varijable g1 &lt;- ggplot(diamondsSample, aes(x*y*z, price, color = color)) + geom_point(alpha = 0.6) g2 &lt;- ggplot(diamondsSample, aes(x = x*y*z, fill = color)) + geom_histogram(bins = 30, na.rm = T) + scale_fill_brewer(palette = &quot;Greens&quot;) g3 &lt;- ggplot(diamondsSample, aes(x = cut)) + geom_bar(fill = &quot;blue&quot;, alpha = 0.5) g4 &lt;- ggplot(diamondsSample, aes(x = color, fill = clarity)) + geom_bar() + coord_polar() # pozivam funkciju `grid.arrange` grid.arrange(g1, g2, g3, g4, nrow = 2, ncol = 2) Zadaci za vježbu Učitajte i proučite podatkovni skup diamonds koji dolazi zajedno s paketom ggplot2. Prikažite raspodjelu cijene dijamanata uz pomoć dva grafa - histograma i tzv. frekvencijskih poligona (funkcija geom_freqpoly)). Cijene podijelite u 10 ladica. Grafovima iz a) dodajte “čistoću” dijamanta (stupac clarity) koji ćete postaviti na fill estetiku (histogram) odnosno color estetiku (frekvencijski poligoni). Koju razliku između grafova uočavate obzirom na default-ni aspekt pozicije? Učitajte i proučite podatkovni skup mpg. Pokušajte rekonstruirati sljedeće grafove. Nepoznate geometrije identificirajte uz pomoć podsjetnika. Uz pomoć funkcija skaliranja na sljedećem grafu: os x nazovite \"broj cilindara\" os y nazovite \"ukupno\" i povećajte raspon do 100 legendu za godine nazovite \"godina\" za boju pravokutnika odaberite paletu \"Dark2\" ggplot(mpg, aes(x = as.factor(cyl), fill = as.factor(year))) + geom_bar() Promijenite temu sljedećeg grafa na sljedeći način: prilagodite prikaz projekciji na platno okrenite nazive na x osi vertikalno ggplot(mpg, aes(x = as.factor(trans), y = displ)) + geom_boxplot() Sljedeći graf prikazuje histogram potrošnje na autocesti pri čemu boja pravokutnika odražava broj cilindara. Pokušajte poboljšati interpretabilnost grafa tako da estetiku boje zamijenite prikazom više grafova uvjetovanih brojem cilindara. Grafove organizirajte u matricu 2 x 2. ggplot(mpg, aes(hwy, fill = as.factor(cyl))) + geom_histogram(bins = 10, position = &quot;dodge&quot;) Pretpostavimo da imamo sljedeći podatkovni okvir: prodaja &lt;- data.frame(mjesec = 1:12, ukupno = c(10000, 5000, 12000, 3000, 5000, 7000, 10000, 2000, 4000, 8000, 11000, 14000)) i da ga želimo predočiti stupčastim grafom (engl. bar chart), no funkcija geom_bar po default-u radi sa samo jednom varijablom za koju računa sumarne statistike. Kako riješiti ovaj problem? Predložite rješenje i stvorite odgovarajući stupčasti graf. Programirajmo u R-u by Damir Pintar is licensed under a Creative Commons Attribution-NonCommercial-NoDerivatives 4.0 International License.Based on a work at https://ratnip.github.io/FER_OPJR/ "],["razdiobe.html", "14 Razdiobe i simulacije 14.1 Rad sa razdiobama vjerojatnosti u jeziku R 14.2 Binomna razdioba 14.3 Normalna razdioba 14.4 Generiranje nasumičnih opservacija 14.5 Procjenu funkcije gustoće razdiobe i kvantil-kvantil graf 14.6 Monte Carlo Simulacije Zadaci za vježbu", " 14 Razdiobe i simulacije R se između ostalog definira kao jezik za “statističko programiranje” što znači da je jedna od njegovih osnovnih funkcija omogućiti provođenje statističkih analiza. Za razliku od drugih programskih jezika, za R se često kaže da je stvoren “od statističara, za statističare”, što znači da usprkos činjenici da je R kao jezik uvelike napredovao i evoluirao od svojih početaka kao izvedenice jezika S, statistika je i dalje u srži samog jezika a R kao takav sadrži iznimno bogatu podršku orijentiranu upravo statističarima i njihovim potrebama. Cilj lekcije koja slijedi nije naučiti čitatelja statistiku. Budući da se radi o kompleksnom i relativno zahtjevnom znanstvenom polju za bilo kakav svrsishodan pregled trebalo bi daleko više prostora od onoga koji imamo ovdje na raspolaganju. Ideja lekcije jest primarno prikazati funkcije rada sa razdiobama, objasniti osnove provedbe simulacija te objasniti neke osnovne metode deskriptivne i inferencijalne statistike uz naglasak na njihovo provođenje kroz programski jezik R. Čitatelji koji nisu upoznati sa statistikom mogu lekciju koristiti kao prvi korak prema upoznavanju svijeta statistike, dok oni koji upravljaju znanjem barem osnovnih statističkih metoda mogu saznati kako neke poslove (koje su možda obavljali uz pomoć nekih drugih alata) mogu izvršavati programski uz pomoć podrške koju nudi jezik R. Kao puno opsežniji uvod u statistiku snažno preporučujemo knjigu “OpenIntro Statistics” (Diez, Barr, and Çetinkaya-Rundel 2015). Važno je napomenuti da knjiga ima i svoj prateći CRAN paket, zvan ‘openintro’, koji omogućuje paralelno čitanje knjige i rješavanje zadanih problema direktno u R-u na istim podatkovnim skupovima koji se referenciraju u knjizi. 14.1 Rad sa razdiobama vjerojatnosti u jeziku R U ovom dijelu lekcije prikazat ćemo podršku jezika R za rad sa različitim razdiobama vjerojatnosti. Važno je naglasiti da se ovdje nećemo baviti temeljitim pregledom teorije vezanim uz pojmove razdiobe vjerojatnosti diskretne i kontinuirane slučajne varijable (već spomenuti izvor “OpenIntro Statistics” može pružiti vrlo kvalitetan uvod ove tematike). Cilj lekcije koja slijedi primarno je prikazati što jezik R - ili konkretnije paket stats - nudi kao podršku za lak i učinkovit rad sa razdiobama. Pojam razdiobe vjerojatnosti predstavlja funkciju koja opisuje vjerojatnost pojave nekog slučajnog događaja. Tako kod bacanja novčića imamo dva moguća ishoda - “pismo” ili “glava”, a ako je novčić regularan vjerojatnost pojedinog ishoda jest 0.5, tj. 50%. Zbroj brojeva kod bacanja dvije kockice može biti od 2 do 12, pri čemu svi ishodi nemaju istu vjerojatnost; npr. broj 7 ima najveću vjerojatnost (17%) dok 2 i 12 imaju najmanju (samo 3%). Možemo razlikovati diskretne i kontinuirane razdiobe vjerojatnosti, u ovisnosti o tome da li je skup mogućih ishoda nekog slučajnog događaja konačan ili beskonačan (gdje pod “beskonačnosti” uglavnom mislimo na primanje vrijednosti iz beskonačnog skupa realnih brojeva). Slika 14.1: Diskretna i kontinuirana razdioba Kod diskretnih razdiobi uglavnom razmatramo vjerojatnost pojave nekog od ishoda, npr. ako slučajni događaj označimo sa slučajnom varijablom \\(X\\), a jedan od mogućih ishoda sa \\(x\\), onda nam funkcija razdiobe odgovara na pitanje koliko je: \\[P(X = x)\\] Ovu vjerojatnost možemo direktno očitati iz grafa funkcije razdiobe pogledom na vrijednost na y osi za odabrani ishod na x osi. Za kontinuirane razdiobe ovo pitanje ne možemo postaviti, budući da je zbog beskonačnosti skupa ishoda vjerojatnost bilo kojeg ishoda jednaka nuli - drugim riječima, vrijednost na y osi ne odgovara vjerojatnosti određenog ishoda, zbog čega ovakvu funkciju i zovemo funkcija gustoće razdiobe, a ne funkcija razdiobe kao kod diskretnih slučajnih varijabli. Pitanje na koje možemo odgovoriti jest koja je vjerojanost da ishod bude unutar određenog intervala, npr. za slučajni događaj opisan varijablom \\(X\\) i vrijednosti \\(a\\) i \\(b\\) preko grafa gustoće razdiobe možemo pronaći: \\[P(a \\lt X \\lt b)\\] i to na način da integriramo površinu ispod krivulje na intervalu \\([a,b]\\). Postoji veliki broj razdioba vjerojatnosti koje nam mogu poslužiti u različitim scenarijima. Binomna razdioba opisuje vjerojatnost uočavanja nekog događaja u eksperimentu kojeg ponavljamo određeni broj puta (npr. vjerojatnost da u 10 bacanja novčića dobijemo pismo 8 puta). Geometrijska razdioba opisuje vjerojatnost broja ponavljanja nekog eksperimenta dok ne dočekamo neki ishod ishoda (npr. vjerojatnost da se prvo “pismo” pojavi tek u petom bacanju novčića). Konačno, možda najpoznatija razdioba je Gaussova ili normalna razdioba koja se često pojavljuje u prirodi i koju statističari vrlo često koriste za potrebe inferencijalne statistike. Poznavanje funkcija za rad sa različitim razdiobama može nam uvelike pomoći u različitim scenarijima. Na sreću, ne moramo poznavati veliki broj razdiobi niti u detalje učiti matematičku podlogu svake od njih. Dovoljno je početi sa nekoliko osnovnih razdiobi (npr. normalna i uniformna) a potom polako širiti znanje o ostalim razdiobama kada se suočimo sa problemima gdje se one mogu pokazati korisnima. Jezik R nam ovdje prilično pomaže budući da koristi jedinstven predložak za podršku svim funkcijama razdiobe koje imamo na raspolaganju tako da kad naučimo upravljati podrškom za jednu razdiobu imamo kvalitetnu podlogu za korištenje bilo koje druge razdiobe, jednom kad se upoznamo s njenim specifičnostima i scenarijima uporabe. Broj razdiobi koje imaju ugrađenu podršku u jeziku R je prilično velik. Popis razdiobi koje imamo na raspolaganju - ne računajući dodatne CRAN pakete! - možemo dobiti naredbom: help(Distributions) U pravilu za svaku raspodjelu imamo na raspolaganju četiri funkcije koje prate isti uzorak imenovanja - funkcije slijede naziv distribucije (npr. norm za normalnu razdiobu, unif za uniformnu, binom za binomnu i sl.). Ovom nazivu daje se prefiks od jednog slova kako slijedi: d - za funkciju razdiobe tj. gustoće razdiobe za diskretne slučajne varijable ova funkcija odgovara na pitanje koliko je \\(P(X = x)\\) p - za kumulativnu funkciju razdiobe odgovara na pitanje koliko je \\(P(X \\lt x)\\) q - za funkciju kvantila (inverz od funkcije razdiobe) odgovara na pitanje koja se vrijednost nalazi na određenom postotku skupa teoretskih vrijednosti poredanih po veličini r - za nasumično generiranje jedne ili više varijabli iz odabrane razdiobe Svaka od ovih funkcija prima parametre specifične za njenu funkcionalnost (tako funkcija za nasumični odabir varijabli iz razdiobe prima parametar n koji joj daje informaciju broju slučajnih varijabli koje želimo generirati) te parametre specifične za tu razdiobu (tako sve funkcije za normalnu razdiobu primaju aritmetičku sredinu i standardnu devijaciju tj. parametre mean i sd, geometrijska razdioba traži vektor vjerojatnosti prob, a Poissonova parametar lambda). 14.2 Binomna razdioba Za početak upoznajmo se sa binomnom razdiobom. Ovo je diskretna razdioba koja se naslanja na tzv. Bernoullijev eksperiment, tj. eksperiment koji ima samo dva moguća ishoda (pozitivni i negativni) pri čemu je vjerojatnost pozitivnog ishoda uvijek jednaka i iznosi neki broj \\(p\\) (u intervalu \\([0,1]\\)). Binomna razdioba odgovara na sljedeće pitanje: “Ako \\(n\\) puta ponovimo Bernoullijev eksperiment sa vjerojatnosti pozitivnog ishoda \\(p\\), koja je vjerojatnost da dobijemo vjerojanost x?” Odgovor možemo dobiti preko jednostavne kombinatorike: \\[P(brojIshoda = x;n, p) = {n\\choose x}p^x(1-p)^{n-x}\\] Pomoćne funkcije mogu nam pomoći kod izračuna vrijednosti vezanih uz binomnu razdiobu. Imamo na raspolaganju sljedeće funkcije: dbinom(x, size, prob) vjerojatnost da ćemo pozitivni ishod dobiti x puta u size ponavljanja ako je vjerojatnost pozitivnog ishoda prob x može biti vektor (dobivamo vektor vjerojatnosti) pbinom(q, size, prob) vjerojatnost da ćemo pozitivni ishod dobiti q puta ili manje u size ponavljanja ako je vjerojatnost pozitivnog ishoda prob qbinom(p, size, prob) vrijednost koja se nalazi na p-tom kvantilu binomne razdiobe u kojoj imamo size ponavljanja i vjerojatnost pozitivnog ishoda prob Isprobajmo ih u sljedećem zadatku. Zadatak 14.1 - Binomna razdioba # koja je vjerojatnost da u 10 bacanja novčića vrijednost &quot;pismo&quot; dobijete točno jednom? # koja je vjerojatnost da u 20 bacanja novčića broj dobivanja vrijednosti &quot;pismo&quot; bude manji ili jednak 10? # koja je vrijednost prvog, drugog i trećeg kvartila u bacanju novčića 100 puta? # nacrtajte funkciju razdiobe eksperimenta bacanja novčića 100 puta ## NAPUTAK: napravite pomoćni numerički vektor svih mogućih ishoda, ## konstruirajte podatkovni okvir sa potrebnim podacima a potom nacrtajte razdiobu ## na grafu odabrane geometrije (točkasta, linijska ili stupčasta) # koja je vjerojatnost da u 10 bacanja novčića vrijednost &quot;pismo&quot; dobijete točno jednom? dbinom(x = 1, size = 10, prob = 0.5) # koja je vjerojatnost da u 20 bacanja novčića broj dobivanja vrijednosti &quot;pismo&quot; bude manji ili jednak 10? pbinom(q = 10, size = 20, prob = 0.5) # koja je vrijednost prvog, drugog i trećeg kvartila u bacanju novčića 100 puta? qbinom(p = c(0.25, 0.5, 0.75), size = 100, prob = 0.5) ## [1] 0.009765625 ## [1] 0.5880985 ## [1] 47 50 53 # nacrtajte funkciju razdiobe eksperimenta bacanja novčića 10 puta ## NAPUTAK: napravite pomoćni numerički vektor svih mogućih ishoda, ## konstruirajte podatkovni okvir sa potrebnim podacima a potom nacrtajte razdiobu ## na grafu odabrane geometrije (točkasta, linijska ili stupčasta) data.frame(brojIshoda = 0:10, vjerojatnost = dbinom(0:10, 10, 0.5)) %&gt;% ggplot(aes(x = brojIshoda, y = vjerojatnost)) + geom_bar(stat = &quot;identity&quot;) 14.3 Normalna razdioba Normala razdioba je kontinuirana razdioba sa dva parametra - aritmetičkom sredinom mean i standardnom devijacijom sd. Funkcija gustoće razdiobe ima sljedeći oblik: \\[ f(x) = \\frac{1}{\\sigma\\sqrt{2\\pi}} \\exp\\left( -\\frac{1}{2}\\left(\\frac{x-\\mu}{\\sigma}\\right)^{\\!2}\\,\\right)\\] Pomoćne funkcije za rad sa ovom funkcijom su sljedeće: dnorm(x, mean = 0, sd = 1) vrijednost funkcije gustoće razdiobe za vrijednost x kod normalne razdiobe sa sredinom mean i standardnom devijacijom sd pnorm(q, mean = 0, sd = 1) vrijednost kumulativne funkcije razdiobe za vrijednost x kod normalne razdiobe sa sredinom mean i standardnom devijacijom sd qnorm(p, mean = 0, sd = 1) vrijednost koja se nalazi na p-tom kvantilu kod normalne razdiobe sa sredinom mean i standardnom devijacijom sd Osnovna razlika između normalne razdiobe (kao kontinuirane) i binomne (kao diskretne) jest da funkciju sa prefiksom d ne možemo koristiti za izračun vjerojatnosti konkretnog ishoda. Možemo računati vjerojatnost pripadnosti intervalu, za što koristimo funkciju sa prefiksom p. S druge strane funkciju sa prefiksom d možemo koristiti kada želimo vizualizirati samu funkciju gustoće razdiobe, budući da nam vraća vrijednosti koje mapiramo na os y. Zadatak 14.2 - Normalna razdioba # ako pretpostavimo normalnu razdiobu sa sredinom 50 i standardnom devijacijom 5, koja je vjerojatnost # da će slučajno odabrana opservacija imati vrijednost između 55 i 65? # koja se vrijednost nalazi na 1., 25., 50., 75. i 99.-om percentilu? # na jednom grafu prikažite funkcije gustoće razdiobe sa sljedećim parametrima # - sredina: 50, st.dev: 5 (plava linija) # - sredina: 50, st.dev: 20 (crvena linija) # - sredina: 70, st.dev: 5 (zelena linija) # ## NAPUTAK: koristite trik s &quot;pomoćnim vektorom&quot; iz prethodnog zadatka ## na isti graf stavite tri geometrije sa redefinicijom y estetike # ako pretpostavimo normalnu razdiobu sa sredinom 50 i standardnom devijacijom 5, koja je vjerojatnost # da će slučajno odabrana opservacija imati vrijednost između 55 i 65? pnorm(65, 50, 5) - pnorm(55, 50, 5) ## [1] 0.1573054 # koja se vrijednost nalazi na 1., 25., 50., 75. i 99.-om percentilu? qnorm(c(0.01, 0.25, 0.50, 0.75, 0.99), 50, 25) ## [1] -8.158697 33.137756 50.000000 66.862244 108.158697 # n istom grafu prikažite funkcije gustoće razdiobe sa sljedećim parametrima # - sredina: 50, st.dev: 5 (plava linija) # - sredina: 50, st.dev: 20 (crvena linija) # - sredina: 70, st.dev: 5 (zelena linija) # ## NAPUTAK: koristite trik s &quot;pomoćnim vektorom&quot; iz prethodnog zadatka ## na isti graf stavite tri geometrije sa redefinicijom y estetike x &lt;- seq(0, 100, 0.5) df &lt;- data.frame(x = x, y1 = dnorm(x, 50, 5), y2 = dnorm(x, 50, 20), y3 = dnorm(x, 70, 5)) ggplot(df, aes(x = x)) + geom_line(aes(y = y1), color = &quot;blue&quot;) + geom_line(aes(y = y2), color = &quot;red&quot;) + geom_line(aes(y = y3), color = &quot;green&quot;) 14.4 Generiranje nasumičnih opservacija Jedna od najčešće korištenih obitelji funkcija vezanih uz razdiobe su funkcije za generiranje nasumičnih opservacija koje odgovaraju zadanoj razdiobi. Kako je već spomenute, sve ove funkcije počinju slovom r (od eng. random) te nizom znakova koji označavaju naziv razdiobe. Dodatni parametri funkcije ovise o korištenoj razdiobi, a mogu se pronaći u dokumentaciji. Svako pokretanje Zadatak 14.3 - Generiranje nasumičnih opservacija iz odabrane razdiobe set.seed(1237) # za potrebe ponovljivosti # generirajte 1000 opservacija koje odgovaraju broju pozitivnih ishoda # kod 100 ponavljanja Bernoullijevog eksperimenta sa vjerojatnosti # pozitivnog ishoda od 0.2 # generirajte 1000 opservacija koje odgovaraju normalnoj razdiobi # sa srednjom vrijednosti 20 i standardnom devijacijom 4 # na istom grafu nacrtajte histograme oba skupa opservacija # (sami odaberite prikladnu širinu ladice) set.seed(1237) # za potrebe ponovljivosti # generirajte 1000 opservacija koje odgovaraju broju pozitivnih ishoda # kod 100 ponavljanja Bernoullijevog eksperimenta sa vjerojatnosti # pozitivnog ishoda od 0.2 x1 &lt;- rbinom(1000, 100, 0.2) # generirajte 1000 opservacija koje odgovaraju normalnoj razdiobi # sa srednjom vrijednosti 20 i standardnom devijacijom 4 x2 &lt;- rnorm(1000, 20, 4) # na istom grafu nacrtajte histograme oba skupa opservacija # (sami odaberite prikladnu širinu ladice) data.frame(x1 = x1, x2 = x2) %&gt;% ggplot(aes(x = x1)) + geom_histogram(fill = &#39;blue&#39;, alpha = 0.5, bins = 30) + geom_histogram(aes(x = x2), fill = &#39;orange&#39;, alpha = 0.5, bins = 30) 14.5 Procjenu funkcije gustoće razdiobe i kvantil-kvantil graf Kada radimo sa realnim podacima kontinuiranog tipa, često želimo provjeriti odgovaraju li oni nekoj normalnoj razdiobi. Jedan od načina kako ovo izvesti jest uz pomoć histograma koje smo već spominjali u poglavlju o vizualizaciji te kojima ćemo se vratiti u poglavlju o deskriptivnoj statistici. Drugi način jest koristiti funkciju geom_density paketa ggplot2 koja će uz pomoć posebnog algoritma pokušati “pogoditi” funkciju razdiobe te ju vizualizirati na grafu. Prikažimo kako uz pomoć spomenute funkcije vizualno provjeriti da li se skup vrijednosti nekih obzervacija ravna po nekoj normalnoj razdiobi. Zadatak 14.4 - Funkcija geom_density # učitajte podatke iz datoteke &quot;podaci.csv&quot; i prikažite izgled # procjenjene funkcije razdiobe za svaki od stupaca # komentirajte izgled tj. prirodu prikazanih razdiobi df &lt;- read_csv(&quot;podaci.csv&quot;, show_col_types = F) # grafove ćemo složiti u 2 x 2 matricu radi bolje preglednosti g1 &lt;- ggplot(df, aes(x1)) + geom_density() + labs(x = &quot;&quot;, title = &quot;Normalna&quot;) + xlim(c(160, 180)) g2 &lt;- ggplot(df, aes(x2)) + geom_density() + labs(x = &quot;&quot;, title = &quot;Lijevo nagnuta&quot;) + xlim(c(170, 176)) g3 &lt;- ggplot(df, aes(x3))+ geom_density() + labs(x = &quot;&quot;, title = &quot;Desno nagnuta&quot;) + xlim(c(160, 170)) g4 &lt;- ggplot(df, aes(x4)) + geom_density() + labs(x = &quot;&quot;, title = &quot;Bimodalna&quot;) + xlim(c(90, 190)) grid.arrange(g1, g2, g3, g4, nrow = 2, ncol = 2) Za provjeru normalnosti razdiobe odabrane varijable često se koristi i tzv. “QQ graf” (od engl. quantile-quantile). Ovaj graf radi na sljedeći način: opservacije se poredaju na jednu os prema svojoj vrijednosti dok na drugu os stavljamo njihovu očekivanu Z-vrijednost (engl. Z-score) koji predstavlja “udaljenost od sredine po broju standardnih devijacija”). Kod normalne razdiobe QQ graf leži na dijagonali grafa, dok se odstupanje od normalne razdiobe očituje u “izvijenosti” grafa tj. odstupanju od “pravca normalnosti”. Funkcija geometrije geom_qq uz definiranu estetiku sample nam omogućuje jednostavno stvaranje QQ grafa odabrane varijable. Zadatak 14.5 - Funkcija geom_qq # nacrtajte QQ grafove varijabli iz prethodnog zadatka #library(gridExtras) # ukoliko je potrebno g1 &lt;- ggplot(df, aes(sample = x1)) + geom_qq() + labs(title = &quot;Normalna&quot;) g2 &lt;- ggplot(df, aes(sample = x2)) + geom_qq() + labs(title = &quot;Lijevo nagnuta&quot;) g3 &lt;- ggplot(df, aes(sample = x3)) + geom_qq() + labs(title = &quot;Desno nagnuta&quot;) g4 &lt;- ggplot(df, aes(sample = x4)) + geom_qq() + labs(title = &quot;Bimodalna&quot;) grid.arrange(g1, g2, g3, g4, nrow = 2, ncol = 2) Ovdje završavamo priču o razdiobama. Ponovimo da prikazane funkcije imaju svoje korespondentne alternative za niz drugih razdiobi, pa tako npr. Poissonova razdioba ima funkcije dpois, ppois, qpois i rpois s kojima radimo vrlo slično prikazanim metodama normalne razdiobe, vodeći naravno računa o specifičnostima odabrane razdiobe (kao što smo već rekli, Poissonova razdioba očekivano nema parametre mean i sd već samo parametar lambda). 14.6 Monte Carlo Simulacije Pojam “Monte Carlo simulacije” označava klasu računalnih algoritama gdje provodimo višestruko uzorkovanje te na osnovu dobivenih rezultata donosimo određene zaključke (npr. o radziobi nekog slučajnog događaja). Ovaj način modeliranja slučajnih događaja često se koristi kad želimo zaobići (ili provjeriti valjanost) matematičkog modela. Za provedbu Monte Carlo simulacija možemo koristiti funkcije upoznate u prethodnom poglavlju te već upoznatu funkciju sample. sample(x, size, replace = FALSE, prob = NULL) gdje je x vektor iz kojeg odabiremo vrijednosti, size broj vrijednosti koje želimo odabrati, replace zastavica koja opisuje da li se vrijednosti mogu ponavljati te konačno vektor probs pomoću kojeg zadajemo vjerojatnosti odabira pojedinih elemenata. Po default-u svi elementi imaju jednake vjerojatnosti, a ukoliko koristimo ovaj parametar moramo voditi računa da broj elemenata odgovara broju elemenata originalnog vektora; vjerojatnosti ne moraju imati zbroj 1 budući da će ih R skalirati prije uporabe (tako da ih više možemo tretirati kao “težine”). Podsjetimo se kako radi sample funkcija na vrlo jednostavnom primjeru Monte Carlo simulacije bacanja novčića. Zadatak 14.6 - Funkcija sample set.seed(1234) # napišite funkciju `baciNovcic(n)` koja će vratiti vektor duljine `n` sa nasumično # odabranim vrijednostima 0 (pismo) i 1 (glava) # bacite novčić 10, 100, 1000 i 100,000 puta te ispišite postotak slučajeva kada je ispala &quot;glava&quot; baciNovcic &lt;- function(n) sample(c(0,1), n, replace = T) baciNovcic(10) %&gt;% mean baciNovcic(100) %&gt;% mean baciNovcic(1000) %&gt;% mean baciNovcic(100000) %&gt;% mean ## [1] 0.6 ## [1] 0.55 ## [1] 0.473 ## [1] 0.50207 Na sličan način možemo provjeriti kolika je vjerojatnost pojedinog zbroja kod bacanja dvije kockice. Ovdje nam nije dosta jedan poziv funkcije sample, već trebamo zbroj dva poziva te funkcije kojeg ćemo računati velikih broj puta. Jedno od mogućih rješenja kako ovo isprogramirati jest uz pomoć petlje, no budući da znamo kako je u jeziku R poželjno izbjeći petlje ukoliko je to moguće, preporučljivije je koristiti funkciju replicate: replicate(n, expr, simplify = &quot;array&quot;) Ova funkcija uzima izraz expr i ponavlja ga n puta, pri čemu slaže međurezultate u prikladnu strukturu (ukoliko pogledamo dokumentaciju, uvidjet ćemo da je ova funkcija zapravo izvedenica funkcije sapply). Zadatak 14.7 - funkcija replicate set.seed(1234) # napravite funkciju `baci2kockice(n)` koja vraća vektor od n elemenata # gdje je svaki element zbroj rezultata jednog bacanja dvije kockice # ispišite vjerojatnosti svakog mogućeg zbroja za 100, 1000 i 1,000,000 bacanja kockice baci2kockice &lt;- function(n) replicate(n, sample(1:6, 1) + sample(1:6, 1)) table(baci2kockice(100)) / 100 table(baci2kockice(1000)) / 1000 round(table(baci2kockice(1000000)) / 1000000, 3) ## ## 2 3 4 5 6 7 8 9 10 11 12 ## 0.02 0.04 0.08 0.09 0.15 0.17 0.17 0.12 0.05 0.07 0.04 ## ## 2 3 4 5 6 7 8 9 10 11 12 ## 0.023 0.051 0.082 0.119 0.130 0.152 0.132 0.132 0.086 0.056 0.037 ## ## 2 3 4 5 6 7 8 9 10 11 12 ## 0.028 0.056 0.083 0.111 0.139 0.167 0.139 0.111 0.083 0.056 0.028 Zadatak 14.8 - funkcija replicate (2) set.seed(1234) # igra &quot;belot&quot; se igra sa mađarskim kartama - 32 karte u 4 različite boje # svaki igrač dobiva po 8 karata # jedan od rijetkih događaja u igri je zvanje &quot;belot&quot; kod kojeg (barem) jedan od igrača # dobije sve karte jednake boje # simulacijom procijenite vjerojatnost ovog događaja set.seed(1234) # zanimaju me samo boje spil &lt;- c(rep(1, 8), rep(2, 8), rep(3, 8), rep(4, 8)) belotExp &lt;- function() { spil &lt;- sample(spil, 32) # mijesanje # prvi igrač dobija karte od 1 do 8, drugi od 9 do 16 itd. zvanjeBelot &lt;- (length(unique(spil[1:8])) == 1) || (length(unique(spil[9:16])) == 1) || (length(unique(spil[17:24])) == 1) || (length(unique(spil[25:32])) == 1) zvanjeBelot } replicate(1000000, belotExp()) %&gt;% sum # sum umjesto mean radi lakše interpretacije ## [1] 3 Ponekad želimo imati zapis svih provedenih simulacija. Npr. recimo da želimo 1000 puta ponoviti simulaciju bacanja kockice 100 puta te da sve rezultate želimo imati trajno pohranjene kako bi nad njima mogli raditi različite izračune. Za ovo nam je pogodno koristiti matricu dimenzija 1000 x 100 gdje svaki redak predstavlja jednu simulaciju od 100 bacanja. Već smo prikazali funkciju replicate koja će u slučaju da dani izraz expr vraća jednu vrijednost kao konačni rezultat vratiti vektor. Ukoliko expr vraća vektor konzistentne duljine replicate će vratiti matricu. Potencijalni problem nam može predstavljati činjenica da će replicate rezultate poredati “po stupcima”, tako da je uputno njezin rezultat prije daljnjeg korištenja transponirati uz pomoć funkcije t. Zadatak 14.9 - matrica kao rezultat funkcije replicate set.seed(1234) # 1000 puta ponovite simulaciju bacanja kockice 100 puta # rezultate pohranite u varijablu `rez` # koristite funkciju `replicate` čiji rezultat ćete transponirati # budite oprezni ako koristite ternarni operator (razmislite zašto!) replicate(1000, sample(1:6, 100, T)) %&gt;% t -&gt; rez Zadatak 14.10 - vizualizacija rezultata simulacije # nacrtajte razdiobu suma bacanja dobivenih u simulacijama pohranjenim u varijabli `rez` # za računanje sumi koristite funkciju `apply` ili `rowSums` # u varijablu `prosjSum` upišite prosječnu sumu zaokruženu na 2 decimale # za crtanje razdiobe koristite `ggplot` i `geom_density` # dodajte crvenu vertikalnu liniju na sredini uz pomoć fukcije `geom_vline` # (estetika `xintercept` postavljena na `prosjSum`) # i iznos sredine crvene boje uz pomoć funkcije `geom_text` # ( parametar `label` postavljen na `prosjSum`, parametri `x` i `y` uz liniju) df &lt;- data.frame(x = 1:1000, y = rowSums(rez)) prosjSum &lt;- mean(df$y) ggplot(df, aes(y)) + geom_density() + geom_vline(aes(xintercept = prosjSum), color = &quot;red&quot;) + geom_text(x = prosjSum + 6, y = 0.0015, label = round(prosjSum,2), color = &quot;red&quot;) U ovome dijelu saznali smo neke osnovne alate jezika R za provođenje simulacija: kod simulacija se uglavnom koristimo funkcijom sample te funkcijama razdiobi sa prefiksom r funkcija replicate je vrlo korisna za ponavljanje velikog broja simulacija i pomaže nam da izbjegnemo korištenje petlje (iako i petlje mogu biti korisne i ne treba ih u potpunosti zanemariti) matematičke metode te d i p funkcije razdiobi nam često mogu pomoći kod izračuna i ocjene vjerojatnosti dobivene simulacijom Simulacijama ćemo se vratiti u poglavlju o inferencijalnoj statistici, budući da one predstavljaju jednu od metoda provjere koliko je neka uočena pojava “vjerojatna” ako pretpostavimo da pripada određenoj razdiobi. Za više informacija o simulacijama te njihovoj uporabi za potrebe statistike možemo preporučiti knjigu “IntroStat with Randomization and Simulation” koja je otvoreno dostupna na ovoj poveznici. Ova knjiga okvirno prolazi kroz iste teme kao i knjiga “OpenIntro Statistics”, no s većim naglaskom na simulacije i korištenje nasumično odabranih vrijednosti uz pomoć jezika R. Zadaci za vježbu Procijenite vjerojatnost dobivanja 4 asa u pokeru, pri čemu pretpostavljate da će igrač prvo vući 5 karata, a potom odbaciti sve karte koje nisu asevi i ponovo vući toliko karata (simulirajte 100,000 ovakvih postupaka i ispišite konačnu vjerojatnost). Jedan od stožernih teorema statistike je “centralni granični teorem” koji (pojednostavljeno rečeno) kaže da će se sredine uzoraka određene veličine ponašati po normalnoj razdiobi u kojoj je sredina jednaka sredini originalne razdiobe populacije a varijanca jednaka varijanci populacije podijeljenoj sa veličinom uzorka. Simulacijom dokažite ovu tvrdnju. Ponovite 1000 puta eksperiment nasumičnog uzorkovanja 100 mjera iz normalne razdiobe sa sredinom 50 i standardnom devijacijom 10 (rezultate pohranite u matricu 1000 x 100, svaki redak predstavlja jedno provedeno uzorkovanje). Potom na istom grafu nacrtajte histogram svih 10,000 mjera i histogram aritmetičkih sredina svakog pojedinog uzorkovanja (tj. histogram 1000 dobivenih sredina svakog uzorkovanja). Programirajmo u R-u by Damir Pintar is licensed under a Creative Commons Attribution-NonCommercial-NoDerivatives 4.0 International License.Based on a work at https://ratnip.github.io/FER_OPJR/ "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
